/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/chapter04.js":
/*!*****************************!*\
  !*** ./src/js/chapter04.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_utils_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/utils/common.js */ \"./src/lib/utils/common.js\");\n/* harmony import */ var _lib_simulator_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/simulator/core.js */ \"./src/lib/simulator/core.js\");\n/* harmony import */ var _lib_simulator_gates_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/simulator/gates.js */ \"./src/lib/simulator/gates.js\");\n/* harmony import */ var _lib_simulator_circuit_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/simulator/circuit.js */ \"./src/lib/simulator/circuit.js\");\n\n\n\n\nfunction uniform(n) {\n    let q = new _lib_simulator_circuit_js__WEBPACK_IMPORTED_MODULE_3__.QuantumRegister(n);\n    let qc = new _lib_simulator_circuit_js__WEBPACK_IMPORTED_MODULE_3__.QuantumCircuit(q);\n\n    for (let i = 0; i < q.length; i++) {\n        qc.h(i); // Apply Hadamard gate\n    }\n\n    return qc;\n}\n\nfunction binomial(n, theta) {\n    let q = new _lib_simulator_circuit_js__WEBPACK_IMPORTED_MODULE_3__.QuantumRegister(n);\n    let qc = new _lib_simulator_circuit_js__WEBPACK_IMPORTED_MODULE_3__.QuantumCircuit(q);\n\n    for (let i = 0; i < q.length; i++) {\n        qc.ry(theta, i); // Apply Ry gate with specified angle theta\n    }\n\n    return qc;\n}\n\nlet sharedContext = {\n    math: math,\n    state: [],\n    state_table_to_html: _lib_utils_common_js__WEBPACK_IMPORTED_MODULE_0__.state_table_to_html,\n    init_state: _lib_simulator_core_js__WEBPACK_IMPORTED_MODULE_1__.init_state,\n    is_close: _lib_utils_common_js__WEBPACK_IMPORTED_MODULE_0__.is_close,\n    prepare_state: _lib_simulator_core_js__WEBPACK_IMPORTED_MODULE_1__.prepare_state,\n    is_power_of_two: _lib_simulator_core_js__WEBPACK_IMPORTED_MODULE_1__.is_power_of_two,\n    cis: _lib_utils_common_js__WEBPACK_IMPORTED_MODULE_0__.cis,\n    print_state: _lib_utils_common_js__WEBPACK_IMPORTED_MODULE_0__.print_state,\n    x:_lib_simulator_gates_js__WEBPACK_IMPORTED_MODULE_2__.x,z:_lib_simulator_gates_js__WEBPACK_IMPORTED_MODULE_2__.z,phase:_lib_simulator_gates_js__WEBPACK_IMPORTED_MODULE_2__.phase,h:_lib_simulator_gates_js__WEBPACK_IMPORTED_MODULE_2__.h,rz:_lib_simulator_gates_js__WEBPACK_IMPORTED_MODULE_2__.rz,y:_lib_simulator_gates_js__WEBPACK_IMPORTED_MODULE_2__.y,rx:_lib_simulator_gates_js__WEBPACK_IMPORTED_MODULE_2__.rx,ry:_lib_simulator_gates_js__WEBPACK_IMPORTED_MODULE_2__.ry,\n    process_pair: _lib_simulator_core_js__WEBPACK_IMPORTED_MODULE_1__.process_pair,\n    choices: _lib_utils_common_js__WEBPACK_IMPORTED_MODULE_0__.choices,\n    squaredMagnitude: _lib_utils_common_js__WEBPACK_IMPORTED_MODULE_0__.squaredMagnitude,\n    pair_generator_pattern: _lib_simulator_core_js__WEBPACK_IMPORTED_MODULE_1__.pair_generator_pattern,\n    transform: _lib_simulator_core_js__WEBPACK_IMPORTED_MODULE_1__.transform,\n    is_bit_set: _lib_simulator_core_js__WEBPACK_IMPORTED_MODULE_1__.is_bit_set,\n    c_transform: _lib_simulator_core_js__WEBPACK_IMPORTED_MODULE_1__.c_transform,\n    measure: _lib_simulator_core_js__WEBPACK_IMPORTED_MODULE_1__.measure,\n    QuantumCircuit: _lib_simulator_circuit_js__WEBPACK_IMPORTED_MODULE_3__.QuantumCircuit,\n    QuantumRegister: _lib_simulator_circuit_js__WEBPACK_IMPORTED_MODULE_3__.QuantumRegister,\n    QuantumTransformation: _lib_simulator_circuit_js__WEBPACK_IMPORTED_MODULE_3__.QuantumTransformation,\n    uniform: uniform,\n    binomial: binomial\n  };\n\nrequire.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.37.0/min/vs' }});\n\nrequire(['vs/editor/editor.main'], function() {\n    let codeHistory = [];\n\n    function displayStepAndEditor(title, code) {\n        const tutorialDiv = document.getElementById(\"tutorial\");\n\n        // Step container\n        const stepDiv = document.createElement(\"div\");\n        stepDiv.className = \"step-container\";\n\n        // Title\n        const titleEl = document.createElement(\"p\");\n        titleEl.className = \"step-title\";\n        titleEl.textContent = title;\n\n        // Editor container\n        const editorContainer = document.createElement(\"div\");\n        editorContainer.className = \"editor-container\";\n\n        // Run Button\n        const runButton = document.createElement(\"button\");\n        runButton.className = \"run-button\";\n        runButton.innerText = \"Run Code\";\n\n        // Output container\n        const outputContainer = document.createElement(\"div\");\n        outputContainer.className = \"output\";\n\n        // Append elements\n        editorContainer.appendChild(runButton);\n        stepDiv.appendChild(titleEl);\n        stepDiv.appendChild(editorContainer);\n        stepDiv.appendChild(outputContainer);\n        tutorialDiv.appendChild(stepDiv);\n\n        // Monaco Editor setup\n        const editor = monaco.editor.create(editorContainer, {\n        value: code,\n        language: \"javascript\",\n        theme: \"vs-light\",\n        automaticLayout: true // Dynamically adjust to container size\n        });\n\n        // Run Code Button Logic\n        runButton.onclick = function () {\n        runCode(editor, outputContainer);\n        };\n    }\n\n\n    function runCode(editor, outputContainer) {\n        const code = editor.getValue();\n        outputContainer.innerText = ''; // Clear previous output\n\n        // Combine previous code with the current editor's code\n        const fullCode = codeHistory.join('\\n') + '\\n' + code;\n\n        try {\n          let result = (function() {\n            // Pass the context (math, state) into the function, but avoid reassigning 'state'\n            let { math, state, state_table_to_html, init_state, is_close, prepare_state, \n                is_power_of_two, cis, print_state, x, z, phase, h, rz, y, rx, ry, process_pair, \n                choices, squaredMagnitude, pair_generator_pattern, transform, is_bit_set, \n                c_transform, measure, QuantumRegister, QuantumTransformation, QuantumCircuit,\n                uniform, binomial } = sharedContext;\n            return eval(fullCode);  // Execute the accumulated code with the shared context\n          })();\n\n          // If result is undefined, return a default message\n          if (result === undefined) {\n            result = \"No return value from the code.\";\n          }\n\n          // Update the shared output and display it\n          sharedContext.output = result;\n          outputContainer.innerText = result;\n\n          // Save the current code for the next step\n          codeHistory.push(code);\n\n        } catch (error) {\n          outputContainer.innerText = error.message;\n        }\n      }\n\n    let tutorialDiv = document.getElementById(\"tutorial\");\n    let titleEl = document.createElement(\"h1\");\n    titleEl.textContent = \"Building Quantum Software: Chapter 4\";\n    tutorialDiv.appendChild(titleEl);\n\n    titleEl = document.createElement(\"h1\");\n    titleEl.className = \"subheading\";\n    titleEl.textContent = \"Two-qubit states (section 4.2.1)\";\n    tutorialDiv.appendChild(titleEl);\n\ndisplayStepAndEditor(\n    \"A two-qubit quantum state can be represented as a list of four complex numbers.\",\n    `let [p0, p1, p2, p3] = [1, 0, 0, 0];\nlet [theta0, theta1, theta2, theta3] = [0, 0, 0, 0];\n\nlet state = [\n    math.complex(math.sqrt(p0) * math.cos(theta0), math.sqrt(p0) * math.sin(theta0)),\n    math.complex(math.sqrt(p1) * math.cos(theta1), math.sqrt(p1) * math.sin(theta1)),\n    math.complex(math.sqrt(p2) * math.cos(theta2), math.sqrt(p2) * math.sin(theta2)),\n    math.complex(math.sqrt(p3) * math.cos(theta3), math.sqrt(p3) * math.sin(theta3)),\n];`\n);\n\ndisplayStepAndEditor(\n    \"Generate normalized random probabilities and angles.\",\n    `let probs = Array(4).fill(0).map(() => Math.random());\nlet total = probs.reduce((sum, val) => sum + val, 0);\nlet normalizedProbs = probs.map(p => p / total);\n\nlet angles = Array(4).fill(0).map(() => Math.random() * 2 * Math.PI);\n\nstate = normalizedProbs.map((p, i) => \n    math.complex(math.sqrt(p) * math.cos(angles[i]), math.sqrt(p) * math.sin(angles[i]))\n);`\n);\n\ndisplayStepAndEditor(\n    \"Display the quantum state table using state_table_to_html.\",\n    `(async () => {\n    await state_table_to_html(state, \"t1\");\n})();`\n);\n\n// Create a placeholder for the table display\nconst t1 = document.createElement(\"div\");\nt1.id = \"t1\";\ndocument.getElementById(\"tutorial\").appendChild(t1);\n\ntutorialDiv = document.getElementById(\"tutorial\");\ntitleEl = document.createElement(\"h1\");\ntitleEl.textContent = \"Product states: composing a state from two independent single-qubit states\";\ntutorialDiv.appendChild(titleEl);\n\ndisplayStepAndEditor(\n        \"Shortcut cis function\",\n        `function cis(theta) {\n    return math.complex(math.cos(theta), math.sin(theta));\n}`\n    )\n\n// Step 1: Define the first quantum state\ndisplayStepAndEditor(\n  \"Define the first quantum state with p = 0.75 and directions θ₀ = 0° and θ₁ = 60°.\",\n  `let p = 0.75;\nlet theta0 = 0;\nlet theta1 = 60 * (Math.PI / 180); // Convert to radians\n\nlet first_state = [\n  math.complex(math.sqrt(p) * math.cos(theta0), math.sqrt(p) * math.sin(theta0)),\n  math.complex(math.sqrt(1 - p) * math.cos(theta1), math.sqrt(1 - p) * math.sin(theta1))\n];\n\nfirst_state.map(amp => amp.toString());`\n);\n\n// Step 2: Define the second quantum state\ndisplayStepAndEditor(\n  \"Define the second quantum state with q = 0.5 and directions ϕ₀ = 0° and ϕ₁ = -120°.\",\n  `let q = 0.5;\nlet phi0 = 0;\nlet phi1 = -120 * (Math.PI / 180); // Convert to radians\n\nlet second_state = [\n  math.complex(math.sqrt(q) * math.cos(phi0), math.sqrt(q) * math.sin(phi0)),\n  math.complex(math.sqrt(1 - q) * math.cos(phi1), math.sqrt(1 - q) * math.sin(phi1))\n];\n\nsecond_state.map(amp => amp.toString());`\n);\n\n// Step 3: Combine two states to form a two-qubit state\ndisplayStepAndEditor(\n  \"Create a two-qubit state by combining the two single-qubit states.\",\n  `let new_state = [\n  math.multiply(first_state[0], second_state[0]),\n  math.multiply(first_state[0], second_state[1]),\n  math.multiply(first_state[1], second_state[0]),\n  math.multiply(first_state[1], second_state[1])\n];\n\nnew_state.map(amp => amp.toString());`\n);\n\n// Step 4: Alternate definition for the two-qubit state\ndisplayStepAndEditor(\n  \"Alternative definition of the two-qubit state using probabilities and angles.\",\n  `new_state = [\n  math.complex(math.sqrt(p * q) * math.cos(theta0 + phi0), math.sqrt(p * q) * math.sin(theta0 + phi0)),\n  math.complex(math.sqrt(p * (1 - q)) * math.cos(theta0 + phi1), math.sqrt(p * (1 - q)) * math.sin(theta0 + phi1)),\n  math.complex(math.sqrt((1 - p) * q) * math.cos(theta1 + phi0), math.sqrt((1 - p) * q) * math.sin(theta1 + phi0)),\n  math.complex(math.sqrt((1 - p) * (1 - q)) * math.cos(theta1 + phi1), math.sqrt((1 - p) * (1 - q)) * math.sin(theta1 + phi1))\n];\n\nnew_state.map(amp => amp.toString());`\n);\n\n\ntitleEl = document.createElement(\"h1\");\ntitleEl.textContent = \"Examples of non-product states: Bell states\";\ntutorialDiv.appendChild(titleEl);\n\ndisplayStepAndEditor(\n    \"Define Bell states 1 and 2\",\n    `let bell_state1 = [math.sqrt(0.5), math.complex(0, 0), math.complex(0, 0), math.sqrt(0.5)];\nlet bell_state2 = [math.sqrt(0.5), math.complex(0, 0), math.complex(0, 0), math.complex(-math.sqrt(0.5), 0)];\n\n(async () => {\n    await state_table_to_html(bell_state1, \"t2\");\n    await state_table_to_html(bell_state2, \"t3\");\n})();`\n);\n\nlet table2 = document.createElement(\"div\");\ntable2.id = \"t2\";\ndocument.getElementById(\"tutorial\").appendChild(table2);\n\nlet table3 = document.createElement(\"div\");\ntable3.id = \"t3\";\ndocument.getElementById(\"tutorial\").appendChild(table3);\n\ndisplayStepAndEditor(\n    \"Define Bell states 3 and 4\",\n    `let bell_state3 = [math.complex(0, 0), math.sqrt(0.5), math.sqrt(0.5), math.complex(0, 0)];\nlet bell_state4 = [math.complex(0, 0), math.sqrt(0.5), math.complex(-math.sqrt(0.5), 0), math.complex(0, 0)];\n\n(async () => {\n    await state_table_to_html(bell_state3, \"t4\");\n    await state_table_to_html(bell_state4, \"t5\");\n})();`\n);\n\nlet table4 = document.createElement(\"div\");\ntable4.id = \"t4\";\ndocument.getElementById(\"tutorial\").appendChild(table4);\n\nlet table5 = document.createElement(\"div\");\ntable5.id = \"t5\";\ndocument.getElementById(\"tutorial\").appendChild(table5);\n\n\ntitleEl = document.createElement(\"h1\");\ntitleEl.textContent = \"Two-qubit states (section 4.2.2)\";\ndocument.getElementById(\"tutorial\").appendChild(titleEl);\n\n// Step 1: Define the amplitude list\ndisplayStepAndEditor(\n    \"Let's define a state with the following eight complex numbers\",\n    `let amplitude_list = [\n    math.complex(0.09858, 0.03637), \n    math.complex(0.07478, 0.06912), \n    math.complex(0.04852, 0.10526), \n    math.complex(0.00641, 0.16322), \n    math.complex(-0.12895, 0.34953), \n    math.complex(0.58403, -0.6318), \n    math.complex(0.18795, -0.08665), \n    math.complex(0.12867, -0.00506)\n];`\n);\n\n// Step 2: Prepare the state (no implementation for `is_power_of_two`)\ndisplayStepAndEditor(\n    \"Function for validating a list of complex numbers as a valid quantum state\",\n    `function prepare_state(...a) {\n    const state = [...a];\n    if (!is_power_of_two(state.length)) {\n        throw new Error(\"Length of state must be a power of two\");\n    }\n    const norm = state.reduce((acc, val) => acc + math.pow(math.abs(val), 2), 0);\n    if (!is_close(norm, 1.0)) {\n        throw new Error(\"State is not normalized\");\n    }\n    return state;\n}`\n);\n\ndisplayStepAndEditor(\n    \"\",\n    `state = prepare_state(...amplitude_list);`\n);\n\ntitleEl = document.createElement(\"h1\");\ntitleEl.textContent = \"Building state tables\";\ndocument.getElementById(\"tutorial\").appendChild(titleEl);\n\n\n// Step 1: List for outcomes and corresponding amplitudes\ndisplayStepAndEditor(\n    \"List outcomes and their corresponding amplitudes\",\n    `let outcome_amplitudes = state.map((amp, index) => [index, amp]);\n\nlet output1 = \"\";\noutcome_amplitudes.forEach(row => {\n    output1 += \\`[\\${row[0]}, \\${row[1]}]\\\\n\\`;\n});\noutput1;`\n);\n\n// Step 2: Add probabilities with direction, derived from amplitudes\ndisplayStepAndEditor(\n    \"Add probabilities with direction, derived from amplitudes\",\n    `let table1 = state.map((amp, index) => [\n    index,\n    math.round((math.atan2(amp.im, amp.re) / (2 * math.PI)) * 360, 5), // Direction\n    math.round(math.pow(math.abs(amp), 2), 5) // Probability\n]);\n\nlet output2 = \"\";\ntable1.forEach(row => {\n    output2 += \\`[\\${row[0]}, \\${row[1]}, \\${row[2]}]\\\\n\\`;\n});\noutput2;`\n);\n\n// Step 3: Expanded version with amplitude, direction, magnitude, and probability\ndisplayStepAndEditor(\n    \"Build an expanded state table with amplitude, direction, magnitude, and probability\",\n    `let expanded_table = state.map((amp, index) => [\n    index,\n    amp,\n    math.round((math.atan2(amp.im, amp.re) / (2 * math.PI)) * 360, 5), // Direction\n    math.round(math.abs(amp), 5), // Magnitude\n    math.round(math.pow(math.abs(amp), 2), 5) // Probability\n]);\n\nlet output3 = \"\";\nexpanded_table.forEach(row => {\n    output3 += \\`[\\${row[0]}, \\${row[1]}, \\${row[2]}, \\${row[3]}, \\${row[4]}]\\\\n\\`;\n});\noutput3;`\n);\n\n// Step 4: Get amplitudes back from directions and probabilities\ndisplayStepAndEditor(\n    \"Get amplitudes back from directions and probabilities\",\n    `let table2 = table1.map(row => [\n    row[0], // Outcome\n    math.complex(\n        math.round(math.sqrt(row[2]) * math.cos(row[1] * (math.PI / 180)), 5), \n        math.round(math.sqrt(row[2]) * math.sin(row[1] * (math.PI / 180)), 5)\n    )\n]);\n\nlet output4 = \"\";\ntable2.forEach(row => {\n    output4 += \\`[\\${row[0]}, \\${row[1]}]\\\\n\\`;\n});\noutput4;`\n);\n\n// Step 5: Visualize the expanded state table\ndisplayStepAndEditor(\n    \"Visualize the expanded state table\",\n    `(async () => {\n    await state_table_to_html(state, \"t8\");\n})();`\n);\n\n// Create a new table div\nlet table8 = document.createElement(\"div\");\ntable8.id = \"t8\";\ndocument.getElementById(\"tutorial\").appendChild(table8);\n\ntitleEl = document.createElement(\"h1\");\ntitleEl.textContent = \"Simulating multi-qubit states (section 4.2.3)\";\ndocument.getElementById(\"tutorial\").appendChild(titleEl);\n\ndisplayStepAndEditor(\n    \"Function to create a default quantum state\",\n    `function init_state(n) {\n    const state = Array(Math.pow(2, n)).fill(null).map(() => math.complex(0, 0));\n\n    state[0] = math.complex(1, 0);\n\n    return state;\n}\n    `\n)\n\ndisplayStepAndEditor(\n    \"Initialize a two-qubit state\",\n    `state = init_state(2);\nstate;\n    `\n)\n\ntitleEl = document.createElement(\"h1\");\ntitleEl.textContent = \"Pair selection in Python (section 4.3.2)\";\ndocument.getElementById(\"tutorial\").appendChild(titleEl);\n\n\ndisplayStepAndEditor(\n    \"Listing 4.3 Traverse by chunk method selecting pairs\",\n`function* pair_generator_pattern(n, t) {\n    const distance = 2 ** t;\n    for (let j = 0; j < 2 ** (n - t - 1); j++) {\n        for (let k0 = 2 * j * distance; k0 < (2 * j + 1) * distance; k0++) {\n            const k1 = k0 + distance;\n            yield [k0, k1];\n        }\n    }\n}`\n)\n\ndisplayStepAndEditor(\n    \"Example of generate the pairs using this method for three qubits (n = 3) and target qubit 0 (t = 0)\",\n`let output = \"\";\nfor (const [k0, k1] of pair_generator_pattern(3, 0)) {\n    output += \\`\\${k0} \\${k1}\\\\n\\`;\n}\noutput;`\n);\n\ntitleEl = document.createElement(\"h1\");\ntitleEl.textContent = \"Simulating amplitude changes (section 4.3.3)\";\ndocument.getElementById(\"tutorial\").appendChild(titleEl);\n\ndisplayStepAndEditor(\n    \"Listing 4.4 Functions for simulating a gate transformation on a multi-qubit state\",\n    `function process_pair(state, gate, k0=0, k1=1) {\nconst x = state[k0];\nconst y = state[k1];\nstate[k0] = math.add(math.multiply(x, gate[0][0]), math.multiply(y, gate[0][1]));\nstate[k1] = math.add(math.multiply(x, gate[1][0]), math.multiply(y, gate[1][1]));\n}\n\nfunction transform(state, t, gate) {\n    const n = Math.log2(state.length);\n    for (const [k0, k1] of pair_generator(n, t)) {\n        if (k1 >= state.length) {\n            continue;\n        }\n        process_pair(state, gate, k0, k1);\n    }\n}`\n);\n\ndisplayStepAndEditor(\n    ``,\n    `const pair_generator = pair_generator_pattern;\n`\n)\n\ndisplayStepAndEditor(\n    \"Apply an X-gate to target qubit 0:\",\n`state = [\n    math.complex(0.09858, 0.03637), math.complex(0.07478, 0.06912),\n    math.complex(0.04852, 0.10526), math.complex(0.00641, 0.16322),\n    math.complex(-0.12895, 0.34953), math.complex(0.58403, -0.6318),\n    math.complex(0.18795, -0.08665), math.complex(0.12867, -0.00506)\n];\n\ntransform(state, 0, x);\nstate;`\n);\n\ntitleEl = document.createElement(\"h1\");\ntitleEl.textContent = \"Encoding a uniform distribution in a multi-qubit quantum system (section 4.3.4)\";\ndocument.getElementById(\"tutorial\").appendChild(titleEl);\n\ndisplayStepAndEditor(\n    \"First, we initialize a three-qubit state:\",\n`let state = init_state(3);\nstate;`\n);\n\ndisplayStepAndEditor(\n    \"Apply a Hadamard gate to target qubit 0:\",\n`transform(state, 0, h);\nstate;`\n);\n\ndisplayStepAndEditor(\n    \"Apply a Hadamard gate to target qubit 1:\",\n`state = init_state(3);\ntransform(state, 1, h);\nstate;`\n);\n\ndisplayStepAndEditor(\n    \"Apply a Hadamard gate to each qubit:\",\n`state = init_state(3);\ntransform(state, 0, h);\ntransform(state, 1, h);\ntransform(state, 2, h);\nstate;`\n);\n\n// Step 5: Visualize the expanded state table\ndisplayStepAndEditor(\n    \"Visualize the uniform state table:\",\n`(async () => {\n    await state_table_to_html(state, \"t9\");\n})();`\n);\n\n// Create a new table div\nlet table9 = document.createElement(\"div\");\ntable9.id = \"t9\";\ndocument.getElementById(\"tutorial\").appendChild(table9);\n\ntitleEl = document.createElement(\"h1\");\ntitleEl.textContent = \"Simulating controlled gates in Python (section 4.4.1)\";\ndocument.getElementById(\"tutorial\").appendChild(titleEl);\n\n\n\ndisplayStepAndEditor(\n    \"Listing 4.5 Function for applying controlled gate transformations to a state\",\n`function is_bit_set(m, k) {\n    return (m & (1 << k)) !== 0;\n}\n\nfunction c_transform(state, c, t, gate) {\n    const n = Math.log2(state.length);\n    for (const [k0, k1] of Array.from(pair_generator(n, t)).filter(p => is_bit_set(p[0], c))) {\n        process_pair(state, gate, k0, k1);\n    }\n}\n`\n);\n\ndisplayStepAndEditor(\n    \"Example state:\",\n`state = [\n    math.complex(0.09858, 0.03637), math.complex(0.07478, 0.06912),\n    math.complex(0.04852, 0.10526), math.complex(0.00641, 0.16322),\n    math.complex(-0.12895, 0.34953), math.complex(0.58403, -0.6318),\n    math.complex(0.18795, -0.08665), math.complex(0.12867, -0.00506)\n];\nstate;`\n);\n\ndisplayStepAndEditor(\n    \"Apply a controlled X-gate to target qubit 2 with control qubit 1:\",\n`c_transform(state, 1, 2, x);\nstate;`\n);\n\ntitleEl = document.createElement(\"h1\");\ntitleEl.textContent = \"Simulating multi-control gates in Python (section 4.4.2)\";\ndocument.getElementById(\"tutorial\").appendChild(titleEl);\n\ndisplayStepAndEditor(\n    \"Listing 4.5 Function for applying controlled gate transformations to a state\",\n`function mc_transform(state, cs, t, gate) {\n    if (cs.includes(t)) {\n        throw new Error(\"Target qubit cannot be one of the control qubits\");\n    }\n    const n = Math.log2(state.length);\n    for (const [k0, k1] of Array.from(pair_generator(n, t)).filter(p => cs.every(c => is_bit_set(p[0], c)))) {\n        process_pair(state, gate, k0, k1);\n    }\n}`\n);\n\ndisplayStepAndEditor(\n    \"Example state:\",\n`state = [\n    math.complex(0.09858, 0.03637), math.complex(0.07478, 0.06912),\n    math.complex(0.04852, 0.10526), math.complex(0.00641, 0.16322),\n    math.complex(-0.12895, 0.34953), math.complex(0.58403, -0.6318),\n    math.complex(0.18795, -0.08665), math.complex(0.12867, -0.00506)\n];\nstate;`\n);\n\ndisplayStepAndEditor(\n    \"If we apply a controlled transformation with two control qubits to a three-qubit state, there will be only one pair. For example, if the target qubit is 0, and the control qubits are 1 and 2, the pair selected will be '110' and '111' (outcomes 6 and 7).\",\n`mc_transform(state, [1, 2], 0, x);\nstate;`\n);\n\n\ntitleEl = document.createElement(\"h1\");\ntitleEl.textContent = \"Simulating measurement of multi-qubit states (section 4.5.1)\";\ndocument.getElementById(\"tutorial\").appendChild(titleEl);\n\ndisplayStepAndEditor(\n    \"Listing 4.7 Function for simulating measurement of a quantum state\",\n`function measure(state, shots) {\n    const probabilities = state.map(c => Math.pow(math.abs(c), 2)); // Calculate probabilities\n    const counts = {};\n\n    for (let i = 0; i < shots; i++) {\n        const r = Math.random(); // Random value between 0 and 1\n        let cumulative = 0;\n\n        // Determine the outcome based on cumulative probabilities\n        for (let k = 0; k < probabilities.length; k++) {\n            cumulative += probabilities[k];\n            if (r <= cumulative) {\n                counts[k] = (counts[k] || 0) + 1; // Increment the count for outcome k\n                break;\n            }\n        }\n    }\n\n    return counts;\n}`\n);\n\ndisplayStepAndEditor(\n    \"Example state:\",\n`state = [\n    math.complex(0.09858, 0.03637), math.complex(0.07478, 0.06912),\n    math.complex(0.04852, 0.10526), math.complex(0.00641, 0.16322),\n    math.complex(-0.12895, 0.34953), math.complex(0.58403, -0.6318),\n    math.complex(0.18795, -0.08665), math.complex(0.12867, -0.00506)\n];\nstate;`\n);\n\ndisplayStepAndEditor(\n    \"Calculate and display the probabilities of each outcome:\",\n`let probabilities = state.map((amplitude, k) => [k, Math.pow(math.abs(amplitude), 2)]);\nlet output = \"\";\nprobabilities.forEach(([k, prob]) => {\n    output += \\`probability of outcome \\${k} : \\${prob.toFixed(3)}\\\\n\\`;\n});\noutput;`\n);\n\ndisplayStepAndEditor(\n    \"Let's simulate the outcomes of 100 executions of the computation which creates our example state:\",\n`let samples = measure(state, 100);\nJSON.stringify(samples, null, 2);`\n);\n\ntitleEl = document.createElement(\"h1\");\ntitleEl.textContent = \"Quantum registers and circuits in code (section 4.5.2)\";\ndocument.getElementById(\"tutorial\").appendChild(titleEl);\n\ndisplayStepAndEditor(\n    \"Listing 4.8 The quantum register class\",\n`class QuantumRegister {\n    constructor(size, shift = 0) {\n        this.size = size;\n        this.shift = shift;\n    }\n\n    get(key) {\n        if (typeof key === 'number') {\n            if (key < 0) {\n                key += this.size;\n            }\n            if (key >= 0 && key < this.size) {\n                return this.shift + key;\n            }\n        } else if (Array.isArray(key)) {\n            return key.map(k => this.get(k));\n        }\n    }\n\n    *[Symbol.iterator]() {\n        for (let i = 0; i < this.size; i++) {\n            yield this.shift + i;\n        }\n    }\n\n    reverse() {\n        return [...this].reverse();\n    }\n\n    length() {\n        return this.size;\n    }\n}`\n);\n\n\ndisplayStepAndEditor(\n    \"Listing 4.9 The quantum transformation class:\",\n`class QuantumTransformation {\n    constructor(gate, target, controls = [], name = null, arg = null) {\n        this.gate = gate;\n        this.target = target;\n        this.controls = controls;\n        this.name = name;\n        this.arg = arg;\n    }\n\n    toString() {\n        return \\`\\${this.name} \\${this.arg !== null ? Math.round(this.arg * 100) / 100 : \"\"} \\${this.controls} \\${this.target}\\`;\n    }\n\n    clone() {\n        return new QuantumTransformation(this.gate, this.target, [...this.controls], this.name, this.arg);\n    }\n}`\n);\n\ndisplayStepAndEditor(\n    \"Listing 4.10 Partial implementation of the quantum circuit class\",\n`class QuantumCircuit {\n    constructor(...args) {\n        let bits = 0;\n        let regs = [];\n\n        for (let reg of args) {\n            if (typeof reg === 'number') {\n                reg = { size: reg, shift: bits };\n            } else if (typeof reg.size === 'number') {\n                reg.shift = bits;\n            } else {\n                throw new Error('Invalid argument passed to QuantumCircuit constructor');\n            }\n\n            bits += reg.size;\n            regs.push(reg.size);\n        }\n\n        this.state = init_state(bits); // Initialize the quantum state\n        this.transformations = [];     // List to store transformations\n        this.regs = regs;              // Register sizes\n    }\n\n    initialize(state) {\n        this.state = state;\n    }\n\n    x(t) {\n        this.transformations.push(new QuantumTransformation(x, t, [], 'x'));\n    }\n\n    h(t) {\n        this.transformations.push(new QuantumTransformation(h, t, [], 'h'));\n    }\n\n    ry(theta, t) {\n        this.transformations.push(new QuantumTransformation(ry(theta), t, [], 'ry', theta));\n    }\n\n    cx(c, t) {\n        this.transformations.push(new QuantumTransformation(x, t, [c], 'cx'));\n    }\n\n    mcx(cs, t) {\n        this.transformations.push(new QuantumTransformation(x, t, cs, 'mcx'));\n    }\n\n    measure(shots = 0) {\n        const state = this.run();\n        const samples = measure(state, shots);\n        return { 'state vector': state, counts: samples };\n    }\n\n    run() {\n        for (let tr of this.transformations) {\n            const cs = tr.controls;\n\n            if (cs.length === 0) {\n                transform(this.state, tr.target, tr.gate); // Single-qubit gate\n            } else if (cs.length === 1) {\n                c_transform(this.state, cs[0], tr.target, tr.gate); // Controlled gate\n            } else {\n                mc_transform(this.state, cs, tr.target, tr.gate); // Multi-controlled gate\n            }\n        }\n        this.transformations = []; // Reset transformations after execution\n        return this.state;\n    }\n}\n`\n);\n\ndisplayStepAndEditor(\n    \"Example three-qubit circuit:\",\n`let q = new QuantumRegister(3);\nlet qc = new QuantumCircuit(q);\n\nqc.h(0);            // Apply Hadamard gate to qubit 0\nqc.h(1);            // Apply Hadamard gate to qubit 1\nqc.mcx([0, 1], 2); // Multi-controlled X gate with q[0] and q[1] as controls, q[2] as target`\n);\n\ndisplayStepAndEditor(\n    \"\",\n`state = qc.run();`\n);\n\n\n// Step 1.2: Print the state table\ndisplayStepAndEditor(\n    \"Print the state table:\",\n`(async () => {\n    await state_table_to_html(state, \"t10\");\n})();`\n);\n\n// Create a new table div\nlet table10 = document.createElement(\"div\");\ntable10.id = \"t10\";\ndocument.getElementById(\"tutorial\").appendChild(table10);\n\n// Step 2.1: Simulate measurements\ndisplayStepAndEditor(\n    \"Simulate measurement on the resulting state with the measure function:\",\n`let samples = measure(state, 1000);\nJSON.stringify(samples, null, 2);`\n);\n\n\n// Add section title in bold\ntitleEl = document.createElement(\"h1\");\ntitleEl.textContent = \"Reimplementing the uniform distribution with registers and circuits (section 4.5.3)\";\ndocument.getElementById(\"tutorial\").appendChild(titleEl);\n\n// Step 2.1: Apply Hadamard gates to all qubits\ndisplayStepAndEditor(\n    \"\",\n`let q = new QuantumRegister(3);\nlet qc = new QuantumCircuit(q);\n\nfor (let i = 0; i < 3; i++) {\n    qc.h(i); // Apply Hadamard gate to each qubit\n}\n\nstate = qc.run();`\n);\n\n// Step 2.2: Print the state table\ndisplayStepAndEditor(\n    \"Print the uniform distribution state table:\",\n`(async () => {\n    await state_table_to_html(state, \"t11\");\n})();`\n);\n\n// Create a new table div\nlet table11 = document.createElement(\"div\");\ntable11.id = \"t11\";\ndocument.getElementById(\"tutorial\").appendChild(table11);\n\n// Uniform Distribution Function\ndisplayStepAndEditor(\n    \"Function for encoding the uniform distribution:\",\n`function uniform(n) {\n    let q = new QuantumRegister(n);\n    let qc = new QuantumCircuit(q);\n\n    for (let i = 0; i < q.length; i++) {\n        qc.h(i); // Apply Hadamard gate\n    }\n\n    return qc;\n}`\n);\n\n// Add section title for Binomial Distribution\nlet titleEl2 = document.createElement(\"h1\");\ntitleEl2.textContent = \"Encoding the Binomial distribution in a multi-qubit state (section 4.5.4)\";\ndocument.getElementById(\"tutorial\").appendChild(titleEl2);\n\n// Binomial Distribution\ndisplayStepAndEditor(\n    \"Apply Ry gates to encode the binomial distribution:\",\n`q = new QuantumRegister(3);\nqc = new QuantumCircuit(q);\n\nfor (let i = 0; i < 3; i++) {\n    qc.ry(Math.PI / 3, i); // Apply Ry gate with theta = π/3\n}\n\nstate = qc.run();`\n);\n\n// Print state table\ndisplayStepAndEditor(\n    \"Print the binomial distribution state table:\",\n`(async () => {\n    await state_table_to_html(state, \"t13\");\n})();`\n);\nlet table13 = document.createElement(\"div\");\ntable13.id = \"t13\";\ndocument.getElementById(\"tutorial\").appendChild(table13);\n\n// Binomial Distribution Function\ndisplayStepAndEditor(\n    \"Function for encoding the binomial distribution:\",\n`function binomial(n, theta) {\n    let q = new QuantumRegister(n);\n    let qc = new QuantumCircuit(q);\n\n    for (let i = 0; i < q.length; i++) {\n        qc.ry(theta, i); // Apply Ry gate with specified angle theta\n    }\n\n    return qc;\n}`\n);\n\n// Add section title for Implementing the Bell States\nlet titleEl3 = document.createElement(\"h1\");\ntitleEl3.textContent = \"Implementing the Bell states (section 4.5.5)\";\ndocument.getElementById(\"tutorial\").appendChild(titleEl3);\n\n// First Bell State\ndisplayStepAndEditor(\n    \"Create the first Bell state:\",\n`q = new QuantumRegister(2);\nqc = new QuantumCircuit(q);\n\nqc.h(0);        // Apply Hadamard gate to qubit 0\nqc.cx(0, 1);    // Controlled-X gate (CNOT) with qubit 0 controlling qubit 1\n\nstate = qc.run();`\n);\n\n// Print state table for first Bell state\ndisplayStepAndEditor(\n    \"Print the first Bell state table:\",\n`(async () => {\n    await state_table_to_html(state, \"t14\");\n})();`\n);\nlet table14 = document.createElement(\"div\");\ntable14.id = \"t14\";\ndocument.getElementById(\"tutorial\").appendChild(table14);\n\n// Third Bell State\ndisplayStepAndEditor(\n    \"Create the third Bell state:\",\n`q = new QuantumRegister(2);\nqc = new QuantumCircuit(q);\n\nqc.h(0);        // Apply Hadamard gate to qubit 0\nqc.x(1);        // Apply Pauli-X gate to qubit 1\nqc.cx(0, 1);    // Controlled-X gate (CNOT) with qubit 0 controlling qubit 1\n\nstate = qc.run();`\n);\n\n// Print state table for third Bell state\ndisplayStepAndEditor(\n    \"Print the third Bell state table:\",\n`(async () => {\n    await state_table_to_html(state, \"t15\");\n})();`\n);\nlet table15 = document.createElement(\"div\");\ntable15.id = \"t15\";\ndocument.getElementById(\"tutorial\").appendChild(table15);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n});\n\n\n\n//# sourceURL=webpack://humejs/./src/js/chapter04.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd define */
/******/ 	(() => {
/******/ 		__webpack_require__.amdD = function () {
/******/ 			throw new Error('define cannot be used indirect');
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"chapter04": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkhumejs"] = self["webpackChunkhumejs"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["vendors-node_modules_microsoft_quantum-viz_js_dist_qviz_min_js-node_modules_d3_src_index_js-n-46cfdf","src_lib_simulator_core_js-src_lib_simulator_gates_js","src_lib_simulator_circuit_js"], () => (__webpack_require__("./src/js/chapter04.js")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;