/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhumejs"] = self["webpackChunkhumejs"] || []).push([["src_lib_simulator_circuit_js"],{

/***/ "?d4c0":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://humejs/crypto_(ignored)?");

/***/ }),

/***/ "./src/lib/simulator/circuit.js":
/*!**************************************!*\
  !*** ./src/lib/simulator/circuit.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IQFT: () => (/* binding */ IQFT),\n/* harmony export */   QFT: () => (/* binding */ QFT),\n/* harmony export */   QuantumCircuit: () => (/* binding */ QuantumCircuit),\n/* harmony export */   QuantumRegister: () => (/* binding */ QuantumRegister),\n/* harmony export */   QuantumTransformation: () => (/* binding */ QuantumTransformation),\n/* harmony export */   Swap: () => (/* binding */ Swap)\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./src/lib/simulator/core.js\");\n/* harmony import */ var _gates_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gates.js */ \"./src/lib/simulator/gates.js\");\n/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/matrix.js */ \"./src/lib/utils/matrix.js\");\n\n\n\n\n\nconst pi = Math.PI;\n\nclass Swap {\n    constructor(i, j) {\n        this.name = 'swap';\n        this.i = i;\n        this.j = j;\n    }\n\n    toString() {\n        return `swap ${this.i} ${this.j}`;\n    }\n}\n\nclass QuantumRegister {\n    constructor(size, shift = 0) {\n        this.size = size;\n        this.shift = shift;\n    }\n\n    get(key) {\n        if (typeof key === 'number') {\n            if (key < 0) {\n                key += this.size;\n            }\n            if (key >= 0 && key < this.size) {\n                return this.shift + key;\n            }\n        } else if (Array.isArray(key)) {\n            return key.map(k => this.get(k));\n        }\n    }\n\n    *[Symbol.iterator]() {\n        for (let i = 0; i < this.size; i++) {\n            yield this.shift + i;\n        }\n    }\n\n    reverse() {\n        return [...this].reverse();\n    }\n\n    length() {\n        return this.size;\n    }\n}\n\nclass QuantumTransformation {\n    constructor(gate, target, controls = [], name = null, arg = null) {\n        this.gate = gate;\n        this.target = target;\n        this.controls = controls;\n        this.name = name;\n        this.arg = arg;\n    }\n\n    toString() {\n        return `${this.name} ${this.arg !== null ? Math.round(this.arg * 100) / 100 : \"\"} ${this.controls} ${this.target}`;\n    }\n\n    clone() {\n        return new QuantumTransformation(this.gate, this.target, [...this.controls], this.name, this.arg);\n    }\n}\n\nclass QuantumCircuit {\n    constructor(...args) {\n        let bits = 0;\n        let regs = [];\n\n        for (let reg of args) {\n            if (typeof reg === 'number') {\n\n                reg = { size: reg, shift: bits };\n            } else if (typeof reg.size === 'number') {\n  \n                reg.shift = bits;\n            } else {\n                throw new Error('Invalid argument passed to QuantumCircuit constructor');\n            }\n\n            bits += reg.size;\n            regs.push(reg.size);\n        }\n\n        this.state = (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.init_state)(bits);\n        this.transformations = [];\n        this.regs = regs;\n        this.reports = {};\n    }\n\n    initialize(state) {\n        this.state = state;\n    }\n\n    x(t) { this.transformations.push(new QuantumTransformation(_gates_js__WEBPACK_IMPORTED_MODULE_1__.x, t, [], 'x')); }\n    y(t) { this.transformations.push(new QuantumTransformation(_gates_js__WEBPACK_IMPORTED_MODULE_1__.y, t, [], 'y')); }\n    z(t) { this.transformations.push(new QuantumTransformation(_gates_js__WEBPACK_IMPORTED_MODULE_1__.z, t, [], 'z')); }\n    h(t) { this.transformations.push(new QuantumTransformation(_gates_js__WEBPACK_IMPORTED_MODULE_1__.h, t, [], 'h')); }\n    p(theta, t) { this.transformations.push(new QuantumTransformation((0,_gates_js__WEBPACK_IMPORTED_MODULE_1__.phase)(theta), t, [], 'p', theta)); }\n    rx(theta, t) { this.transformations.push(new QuantumTransformation((0,_gates_js__WEBPACK_IMPORTED_MODULE_1__.rx)(theta), t, [], 'rx', theta)); }\n    ry(theta, t) { this.transformations.push(new QuantumTransformation((0,_gates_js__WEBPACK_IMPORTED_MODULE_1__.ry)(theta), t, [], 'ry', theta)); }\n    rz(theta, t) { this.transformations.push(new QuantumTransformation((0,_gates_js__WEBPACK_IMPORTED_MODULE_1__.rz)(theta), t, [], 'rz', theta)); }\n    cx(c, t) { this.transformations.push(new QuantumTransformation(_gates_js__WEBPACK_IMPORTED_MODULE_1__.x, t, [c], 'cx')); }\n    cy(c, t) { this.transformations.push(new QuantumTransformation(_gates_js__WEBPACK_IMPORTED_MODULE_1__.y, t, [c], 'cy')); }\n    cz(c, t) { this.transformations.push(new QuantumTransformation(_gates_js__WEBPACK_IMPORTED_MODULE_1__.z, t, [c], 'cz')); }\n    cp(theta, c, t) { this.transformations.push(new QuantumTransformation((0,_gates_js__WEBPACK_IMPORTED_MODULE_1__.phase)(theta), t, [c], 'cp', theta)); }\n    cry(theta, c, t) { this.transformations.push(new QuantumTransformation((0,_gates_js__WEBPACK_IMPORTED_MODULE_1__.ry)(theta), t, [c], 'cry', theta)); }\n    mcx(cs, t) { this.transformations.push(new QuantumTransformation(_gates_js__WEBPACK_IMPORTED_MODULE_1__.x, t, cs, 'mcx')); }\n    mcp(theta, cs, t) { this.transformations.push(new QuantumTransformation((0,_gates_js__WEBPACK_IMPORTED_MODULE_1__.phase)(theta), t, cs, 'mcp', theta)); }\n\n    measure(shots = 0) {\n        const state = this.run();\n        const samples = (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.measure)(state, shots);\n        return { 'state vector': state, 'counts': samples };\n    }\n\n    report(name = null) {\n        let start_state = (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.init_state)(this.regs.reduce((acc, reg) => acc + reg, 0));\n        let tr_count = 0;\n\n        for (let report of Object.values(this.reports)) {\n            if (report[3] > tr_count) {\n                tr_count = report[3];\n                start_state = report[2];\n            }\n        }\n\n        const qc = new QuantumCircuit();\n        qc.regs = [...this.regs];\n        qc.initialize([...start_state]);\n        qc.transformations = this.transformations.slice(tr_count);\n\n        const end_state = qc.run();\n        if (!name) {\n            name = Object.keys(this.reports).length;\n        }\n        this.reports[name] = [start_state, this.transformations.slice(tr_count), end_state, this.transformations.length];\n\n        return this.reports[name];\n    }\n\n    run() {\n        for (let tr of this.transformations) {\n            if (tr.name === 'unitary') {\n                const cs = tr.controls;\n                if (cs.length === 0) {\n                    (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.transform_u)(this.state, tr.gate, tr.target);\n                } else if (cs.length === 1) {\n                    (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.c_transform_u)(this.state, tr.gate, cs[0], tr.target);\n                }\n            } else if (tr instanceof Swap) {\n                (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.c_transform)(this.state, tr.i, tr.j, _gates_js__WEBPACK_IMPORTED_MODULE_1__.x);\n                (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.c_transform)(this.state, tr.j, tr.i, _gates_js__WEBPACK_IMPORTED_MODULE_1__.x);\n                (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.c_transform)(this.state, tr.i, tr.j, _gates_js__WEBPACK_IMPORTED_MODULE_1__.x);\n            } else {\n                const cs = tr.controls;\n                if (cs.length === 0) {\n                    (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.transform)(this.state, tr.target, tr.gate);\n                } else if (cs.length === 1) {\n                    (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.c_transform)(this.state, cs[0], tr.target, tr.gate);\n                } else {\n                    (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.mc_transform)(this.state, cs, tr.target, tr.gate);\n                }\n            }\n        }\n        this.transformations = [];\n        return this.state;\n    }\n\n    swap(i, j) {\n        this.transformations.push(new Swap(i, j));\n    }\n\n    mswap(targets) {\n        for (let j = 0; j < Math.floor(targets.length / 2); j++) {\n            this.swap(targets[j], targets[targets.length - 1 - j]);\n        }\n    }\n\n    inverse() {\n        const qs = this.regs.map(size => new QuantumRegister(size));\n        const qc = new QuantumCircuit(...qs);\n\n        for (let tr of this.transformations.reverse()) {\n            if (tr instanceof Swap) {\n                qc.swap(tr.i, tr.j);\n            } else if (tr.name === 'unitary') {\n                const cs = tr.controls;\n                if (cs.length === 0) {\n                    qc.unitary((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_2__.dagger)(tr.gate), tr.target);\n                } else if (cs.length === 1) {\n                    qc.c_unitary((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_2__.dagger)(tr.gate), cs[0], tr.target);\n                }\n            } else {\n                const prefix = tr.controls.length === 0 ? '' : tr.controls.length === 1 ? 'c' : 'mc';\n                const method = qc[prefix + tr.name].bind(qc);\n                const t = tr.target;\n\n                if (tr.arg) {\n                    method(-tr.arg, ...tr.controls, t);\n                } else {\n                    method(...tr.controls, t);\n                }\n            }\n        }\n        return qc;\n    }\n\n    qft(targets, swap = true) {\n        qft(this, targets, swap);\n    }\n\n    append_qft(reg, reversed = false, swap = true) {\n        this.append(new QFT(reg.size, reversed, swap), reg);\n    }\n\n    iqft(targets, swap = true) {\n        iqft(this, targets, swap);\n    }\n\n    append_iqft(reg, reversed = false, swap = true) {\n        this.append(new IQFT(reg.size, reversed, swap), reg);\n    }\n\n    append(circuit, reg) {\n        if (reg.size !== circuit.regs.reduce((acc, size) => acc + size, 0)) {\n            throw new Error(\"Mismatched register sizes.\");\n        }\n\n        for (let tr of circuit.transformations) {\n            if (tr instanceof Swap) {\n                this.transformations.push(new Swap(reg.shift + tr.i, reg.shift + tr.j));\n            } else {\n                this.transformations.push(new QuantumTransformation(\n                    tr.gate,\n                    reg.shift + tr.target,\n                    tr.controls.map(c => reg.shift + c),\n                    tr.name,\n                    tr.arg\n                ));\n            }\n        }\n    }\n\n    c_append(circuit, c, reg) {\n        if (reg.size <= circuit.regs.reduce((acc, size) => acc + size, 0)) {\n            throw new Error(\"Mismatched register sizes.\");\n        }\n\n        for (let tr of circuit.transformations) {\n            if (tr instanceof Swap) {\n                this.transformations.push(new Swap(reg.shift + tr.i, reg.shift + tr.j));\n            } else {\n                this.transformations.push(new QuantumTransformation(\n                    tr.gate,\n                    reg.shift + tr.target,\n                    [c].concat(tr.controls.map(c => reg.shift + c)),\n                    tr.name,\n                    tr.arg\n                ));\n            }\n        }\n    }\n\n    mc_append(circuit, cs, reg) {\n        if (new Set(cs).size !== cs.length) {\n            throw new Error(\"Control qubits must be unique.\");\n        }\n\n        for (let c of cs) {\n            if (c >= reg.shift && c < reg.shift + reg.size) {\n                throw new Error(\"Control qubits must be outside the target register.\");\n            }\n        }\n\n        for (let tr of circuit.transformations) {\n            if (tr instanceof Swap) {\n                this.transformations.push(new Swap(reg.shift + tr.i, reg.shift + tr.j));\n            } else {\n                this.transformations.push(new QuantumTransformation(\n                    tr.gate,\n                    reg.shift + tr.target,\n                    cs.concat(tr.controls.map(c => reg.shift + c)),\n                    tr.name,\n                    tr.arg\n                ));\n            }\n        }\n    }\n\n    unitary(U, t) {\n        this.transformations.push(new QuantumTransformation(U, t, [], 'unitary'));\n    }\n\n    append_u(U, q) {\n        if (U.length !== U[0].length || U.length !== 2 ** q.length()) {\n            throw new Error(\"Invalid unitary matrix size.\");\n        }\n        this.unitary(U, q.shift);\n    }\n\n    c_unitary(U, c, t) {\n        this.transformations.push(new QuantumTransformation(U, t, [c], 'unitary'));\n    }\n\n    c_append_u(U, c, q) {\n        if (U.length !== U[0].length || U.length !== 2 ** q.length()) {\n            throw new Error(\"Invalid unitary matrix size.\");\n        }\n        this.c_unitary(U, c, q.shift);\n    }\n}\n\nclass QFT extends QuantumCircuit {\n    constructor(m, reversed = false, swap = true) {\n        super(new QuantumRegister(m));\n        const targets = reversed ? [...Array(m).keys()].reverse() : [...Array(m).keys()];\n        qft(this, targets, swap);\n    }\n}\n\nclass IQFT extends QuantumCircuit {\n    constructor(m, reversed = false, swap = true) {\n        super(new QuantumRegister(m));\n        const targets = reversed ? [...Array(m).keys()].reverse() : [...Array(m).keys()];\n        iqft(this, targets, swap);\n    }\n}\n\nfunction qft(qc, targets, swap = true) {\n    for (let j = targets.length - 1; j >= 0; j--) {\n        qc.h(targets[j]);\n        for (let k = j - 1; k >= 0; k--) {\n            qc.cp(pi * 2 ** (k - j), targets[j], targets[k]);\n        }\n    }\n    if (swap) {\n        qc.mswap(targets);\n    }\n}\n\nfunction iqft(qc, targets, swap = true) {\n    for (let j = targets.length - 1; j >= 0; j--) {\n        qc.h(targets[j]);\n        for (let k = j - 1; k >= 0; k--) {\n            qc.cp(-pi * 2 ** (k - j), targets[j], targets[k]);\n        }\n    }\n    if (swap) {\n        qc.mswap(targets);\n    }\n}\n\n\n\n//# sourceURL=webpack://humejs/./src/lib/simulator/circuit.js?");

/***/ }),

/***/ "./src/lib/simulator/core.js":
/*!***********************************!*\
  !*** ./src/lib/simulator/core.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c_transform: () => (/* binding */ c_transform),\n/* harmony export */   c_transform_u: () => (/* binding */ c_transform_u),\n/* harmony export */   init_state: () => (/* binding */ init_state),\n/* harmony export */   is_bit_set: () => (/* binding */ is_bit_set),\n/* harmony export */   is_power_of_two: () => (/* binding */ is_power_of_two),\n/* harmony export */   mc_transform: () => (/* binding */ mc_transform),\n/* harmony export */   measure: () => (/* binding */ measure),\n/* harmony export */   pair_generator_check_digit: () => (/* binding */ pair_generator_check_digit),\n/* harmony export */   pair_generator_concatenate: () => (/* binding */ pair_generator_concatenate),\n/* harmony export */   pair_generator_pattern: () => (/* binding */ pair_generator_pattern),\n/* harmony export */   prepare_state: () => (/* binding */ prepare_state),\n/* harmony export */   process_pair: () => (/* binding */ process_pair),\n/* harmony export */   transform: () => (/* binding */ transform),\n/* harmony export */   transform_u: () => (/* binding */ transform_u)\n/* harmony export */ });\n/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mathjs */ \"./node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js\");\n/* harmony import */ var _utils_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/common.js */ \"./src/lib/utils/common.js\");\n\n\n\nfunction is_power_of_two(m) {\n    return Math.ceil(Math.log2(m)) === Math.floor(Math.log2(m));\n}\n\nfunction prepare_state(...a) {\n    const state = [...a];\n    if (!is_power_of_two(state.length)) {\n        throw new Error(\"Length of state must be a power of two\");\n    }\n    const norm = state.reduce((acc, val) => acc + mathjs__WEBPACK_IMPORTED_MODULE_1__.pow(mathjs__WEBPACK_IMPORTED_MODULE_1__.abs(val), 2), 0);\n    if (!(0,_utils_common_js__WEBPACK_IMPORTED_MODULE_0__.is_close)(norm, 1.0)) {\n        throw new Error(\"State is not normalized\");\n    }\n    return state;\n}\n\nfunction init_state(n) {\n    const state = Array(mathjs__WEBPACK_IMPORTED_MODULE_1__.pow(2, n)).fill(0);\n    state[0] = 1;\n    return state;\n}\n\nfunction is_bit_set(m, k) {\n    return (m & (1 << k)) !== 0;\n}\n\nfunction* pair_generator_check_digit(n, t) {\n    const distance = 2 ** t;\n    for (let k0 = 0; k0 < 2 ** n; k0++) {\n        if (!is_bit_set(k0, t)) {\n            const k1 = k0 + distance;\n            yield [k0, k1];\n        }\n    }\n}\n\nfunction* pair_generator_concatenate(n, t) {\n    const distance = 2 ** t;\n    const suffix_count = 2 ** t;\n    const prefix_count = 2 ** (n - t - 1);\n\n    for (let p = 0; p < prefix_count; p++) {\n        for (let s = 0; s < suffix_count; s++) {\n            const k0 = p * suffix_count * 2 + s;\n            const k1 = k0 + distance;\n            yield [k0, k1];\n        }\n    }\n}\n\nfunction* pair_generator_pattern(n, t) {\n    const distance = 2 ** t;\n    for (let j = 0; j < 2 ** (n - t - 1); j++) {\n        for (let k0 = 2 * j * distance; k0 < (2 * j + 1) * distance; k0++) {\n            const k1 = k0 + distance;\n            yield [k0, k1];\n        }\n    }\n}\n\nconst pair_generator = pair_generator_concatenate;\n\n\nfunction process_pair(state, gate, k0, k1) {\n    const x = state[k0];\n    const y = state[k1];\n    state[k0] = mathjs__WEBPACK_IMPORTED_MODULE_1__.add(mathjs__WEBPACK_IMPORTED_MODULE_1__.multiply(x, gate[0][0]), mathjs__WEBPACK_IMPORTED_MODULE_1__.multiply(y, gate[0][1]));\n    state[k1] = mathjs__WEBPACK_IMPORTED_MODULE_1__.add(mathjs__WEBPACK_IMPORTED_MODULE_1__.multiply(x, gate[1][0]), mathjs__WEBPACK_IMPORTED_MODULE_1__.multiply(y, gate[1][1]));\n}\n\nfunction transform(state, t, gate) {\n    const n = Math.log2(state.length);\n    for (const [k0, k1] of pair_generator(n, t)) {\n        if (k1 >= state.length) {\n            continue;\n        }\n        process_pair(state, gate, k0, k1);\n    }\n}\n\n\nfunction c_transform(state, c, t, gate) {\n    const n = Math.log2(state.length);\n    for (const [k0, k1] of Array.from(pair_generator(n, t)).filter(p => is_bit_set(p[0], c))) {\n        process_pair(state, gate, k0, k1);\n    }\n}\n\nfunction mc_transform(state, cs, t, gate) {\n    if (cs.includes(t)) {\n        throw new Error(\"Target qubit cannot be one of the control qubits\");\n    }\n    const n = Math.log2(state.length);\n    for (const [k0, k1] of Array.from(pair_generator(n, t)).filter(p => cs.every(c => is_bit_set(p[0], c)))) {\n        process_pair(state, gate, k0, k1);\n    }\n}\n\nfunction measure(state, shots) {\n    const probabilities = state.map(c => mathjs__WEBPACK_IMPORTED_MODULE_1__.pow(mathjs__WEBPACK_IMPORTED_MODULE_1__.abs(c), 2));\n    const samples = Array(shots).fill(0).map(() => mathjs__WEBPACK_IMPORTED_MODULE_1__.random(probabilities.length));\n    const counts = {};\n    samples.forEach(s => {\n        counts[s] = (counts[s] || 0) + 1;\n    });\n    return counts;\n}\n\nfunction transform_u(state, U, t) {\n    if (U.length !== U[0].length) {\n        throw new Error(\"Matrix U must be square\");\n    }\n    const m = Math.log2(U.length);\n    const n = Math.log2(state.length);\n\n    const vec = Array(2 ** m).fill(0);\n\n    for (let suffix = 0; suffix < 2 ** t; suffix++) {\n        for (let prefix = 0; prefix < 2 ** (n - m - t); prefix++) {\n            for (let target = 0; target < 2 ** m; target++) {\n                const k = prefix * 2 ** (t + m) + target * 2 ** t + suffix;\n                vec[target] = state[k];\n            }\n\n            const vec_out = mathjs__WEBPACK_IMPORTED_MODULE_1__.multiply(U, vec);\n\n            for (let target = 0; target < 2 ** m; target++) {\n                const k = prefix * 2 ** (t + m) + target * 2 ** t + suffix;\n                state[k] = vec_out[target];\n            }\n        }\n    }\n}\n\nfunction c_transform_u(state, U, c, t) {\n    if (U.length !== U[0].length) {\n        throw new Error(\"Matrix U must be square\");\n    }\n    const m = Math.log2(U.length);\n    const n = Math.log2(state.length);\n\n    const vec = Array(2 ** m).fill(0);\n\n    for (let suffix = 0; suffix < 2 ** t; suffix++) {\n        for (let prefix = 0; prefix < 2 ** (n - m - t); prefix++) {\n            const targets = [];\n            for (let idx = 0; idx < 2 ** m; idx++) {\n                const k = prefix * 2 ** (t + m) + idx * 2 ** t + suffix;\n                if (is_bit_set(k, c)) {\n                    vec[idx] = state[k];\n                    targets.push(k);\n                }\n            }\n\n            const vec_out = mathjs__WEBPACK_IMPORTED_MODULE_1__.multiply(U, vec);\n\n            for (let idx = 0; idx < 2 ** m; idx++) {\n                const k = prefix * 2 ** (t + m) + idx * 2 ** t + suffix;\n                if (is_bit_set(k, c)) {\n                    state[k] = vec_out[idx];\n                }\n            }\n        }\n    }\n}\n\n\n\n\n//# sourceURL=webpack://humejs/./src/lib/simulator/core.js?");

/***/ }),

/***/ "./src/lib/simulator/gates.js":
/*!************************************!*\
  !*** ./src/lib/simulator/gates.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ h),\n/* harmony export */   phase: () => (/* binding */ phase),\n/* harmony export */   rx: () => (/* binding */ rx),\n/* harmony export */   ry: () => (/* binding */ ry),\n/* harmony export */   rz: () => (/* binding */ rz),\n/* harmony export */   x: () => (/* binding */ x),\n/* harmony export */   y: () => (/* binding */ y),\n/* harmony export */   z: () => (/* binding */ z)\n/* harmony export */ });\n/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mathjs */ \"./node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js\");\n\n\nconst x = [\n    [0, 1],\n    [1, 0]\n];\n\nconst z = [\n    [1, 0],\n    [0, -1]\n];\n\nfunction phase(theta) {\n    return [\n        [1, 0],\n        [0, mathjs__WEBPACK_IMPORTED_MODULE_0__.complex(Math.cos(theta), Math.sin(theta))]\n    ];\n}\n\nconst h = [\n    [1 / Math.sqrt(2), 1 / Math.sqrt(2)],\n    [1 / Math.sqrt(2), -1 / Math.sqrt(2)]\n];\n\nfunction rz(theta) {\n    return [\n        [mathjs__WEBPACK_IMPORTED_MODULE_0__.complex(Math.cos(theta / 2), -Math.sin(theta / 2)), 0],\n        [0, mathjs__WEBPACK_IMPORTED_MODULE_0__.complex(Math.cos(theta / 2), Math.sin(theta / 2))]\n    ];\n}\n\nconst y = [\n    [0, mathjs__WEBPACK_IMPORTED_MODULE_0__.complex(0, -1)],\n    [mathjs__WEBPACK_IMPORTED_MODULE_0__.complex(0, 1), 0]\n];\n\nfunction rx(theta) {\n    return [\n        [Math.cos(theta / 2), mathjs__WEBPACK_IMPORTED_MODULE_0__.complex(0, -Math.sin(theta / 2))],\n        [mathjs__WEBPACK_IMPORTED_MODULE_0__.complex(0, -Math.sin(theta / 2)), Math.cos(theta / 2)]\n    ];\n}\n\nfunction ry(theta) {\n    return [\n        [Math.cos(theta / 2), -Math.sin(theta / 2)],\n        [Math.sin(theta / 2), Math.cos(theta / 2)]\n    ];\n}\n\n\n\n\n//# sourceURL=webpack://humejs/./src/lib/simulator/gates.js?");

/***/ }),

/***/ "./src/lib/utils/common.js":
/*!*********************************!*\
  !*** ./src/lib/utils/common.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   all_close: () => (/* binding */ all_close),\n/* harmony export */   circuit_to_string: () => (/* binding */ circuit_to_string),\n/* harmony export */   complex_to_rgb: () => (/* binding */ complex_to_rgb),\n/* harmony export */   draw_circuit: () => (/* binding */ draw_circuit),\n/* harmony export */   grid_state_to_html: () => (/* binding */ grid_state_to_html),\n/* harmony export */   is_close: () => (/* binding */ is_close),\n/* harmony export */   is_close_float: () => (/* binding */ is_close_float),\n/* harmony export */   state_table_to_html: () => (/* binding */ state_table_to_html)\n/* harmony export */ });\n/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mathjs */ \"./node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js\");\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"./node_modules/d3/src/index.js\");\n/* harmony import */ var _microsoft_quantum_viz_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @microsoft/quantum-viz.js */ \"./node_modules/@microsoft/quantum-viz.js/dist/qviz.min.js\");\n\n\n\n\nfunction is_close_float(a, b, rtol = 1e-5, atol = 1e-8) {\n    return Math.abs(a - b) < atol + rtol * Math.abs(b);\n}\n\nfunction is_close(a, b) {\n    if (typeof a === 'number') {\n        a = mathjs__WEBPACK_IMPORTED_MODULE_2__.complex(a, 0);\n    }\n\n    if (typeof b === 'number') {\n        b = mathjs__WEBPACK_IMPORTED_MODULE_2__.complex(b, 0);\n    }\n\n    return is_close_float(mathjs__WEBPACK_IMPORTED_MODULE_2__.re(a), mathjs__WEBPACK_IMPORTED_MODULE_2__.re(b)) && is_close_float(mathjs__WEBPACK_IMPORTED_MODULE_2__.im(a), mathjs__WEBPACK_IMPORTED_MODULE_2__.im(b));\n}\n\nfunction all_close(state1, state2) {\n    for (let i = 0; i < state1.length; i++) {\n        if (!is_close(state1[i], state2[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nlet colormapCache = null;\nasync function loadColormap() {\n    if (!colormapCache) {\n        const response = await fetch('./colormap.json');\n        colormapCache = await response.json();\n    }\n    return colormapCache;\n}\n\nasync function complex_to_rgb(c, ints = false) {\n    const colormap = await loadColormap();  \n    const a = mathjs__WEBPACK_IMPORTED_MODULE_2__.re(c);\n    const b = mathjs__WEBPACK_IMPORTED_MODULE_2__.im(c);\n\n    const magnitude = Math.sqrt(a * a + b * b);\n    let hue = Math.atan2(b, a) / Math.PI * 180;\n\n    if (hue < 0) {\n        hue += 360;\n    }\n\n    const hueIndex = Math.round(hue);\n    const boundedIndex = Math.min(hueIndex, colormap.length - 1);\n\n    const rgb = colormap[boundedIndex];\n\n    if (ints) {\n        return rgb;  \n    } else {\n        return [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255];\n    }\n}\n\nasync function state_table_to_html(state, id, decimals = 4, symbol = '█') {\n    const n = Math.log2(state.length);\n    const roundState = state.map(c => mathjs__WEBPACK_IMPORTED_MODULE_2__.complex(\n        parseFloat(mathjs__WEBPACK_IMPORTED_MODULE_2__.re(c).toFixed(decimals)),\n        parseFloat(mathjs__WEBPACK_IMPORTED_MODULE_2__.im(c).toFixed(decimals))\n    ));\n\n    const maxProbability = Math.max(...roundState.map(c => mathjs__WEBPACK_IMPORTED_MODULE_2__.pow(mathjs__WEBPACK_IMPORTED_MODULE_2__.abs(c), 2)));\n\n    const tableData = await Promise.all(roundState.map(async (c, k) => {\n        const direction = Math.round(Math.atan2(mathjs__WEBPACK_IMPORTED_MODULE_2__.im(c), mathjs__WEBPACK_IMPORTED_MODULE_2__.re(c)) * 180 / Math.PI * 100) / 100;\n        const amplitude = `${(mathjs__WEBPACK_IMPORTED_MODULE_2__.re(c) >= 0 ? ' ' : '-')}${Math.abs(mathjs__WEBPACK_IMPORTED_MODULE_2__.re(c)).toFixed(decimals)} ${\n            mathjs__WEBPACK_IMPORTED_MODULE_2__.im(c) >= 0 ? '+ ' : '- '}i${Math.abs(mathjs__WEBPACK_IMPORTED_MODULE_2__.im(c)).toFixed(decimals)}`;\n\n        const magnitude = mathjs__WEBPACK_IMPORTED_MODULE_2__.abs(c).toFixed(decimals);\n        const directionStr = magnitude > 0\n            ? `${(direction >= 0 ? ' ' : '-')}${Math.floor(Math.abs(direction))}.${(Math.abs(direction) % 1).toFixed(2).substring(2)}°`\n            : '';\n\n        const rgb = await complex_to_rgb(c, true);\n        const probability = mathjs__WEBPACK_IMPORTED_MODULE_2__.pow(mathjs__WEBPACK_IMPORTED_MODULE_2__.abs(c), 2).toFixed(decimals);\n\n        let amplitudeBar = '';\n        if (probability > 0) {\n            const normalizedBarLength = Math.round((probability)*20) + 1;\n            console.log(normalizedBarLength);\n            amplitudeBar = `<span style=\"color: rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]}); width: 200px; display: inline-block; overflow: hidden; text-align: left; font-size: 10px;\">${symbol.repeat(Math.max(1, normalizedBarLength))}</span>`;\n        }\n\n        return {\n            outcome: k,\n            binary: k.toString(2).padStart(n, '0'),\n            amplitude: amplitude,\n            magnitude: magnitude,\n            direction: directionStr,\n            amplitudeBar: amplitudeBar,\n            probability: probability,\n        };\n    }));\n\n    let htmlTable = `\n        <style>\n            table {\n                max-width: 100%;\n                border-collapse: collapse;\n                margin: 25px 0;\n                font-size: 0.9em;\n                border-radius: 10px;\n                overflow: hidden;\n                box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);\n            }\n            thead tr {\n                background-color: #3F72AF;\n                color: #ffffff;\n                text-align: left;\n                font-weight: bold;\n            }\n            th, td {\n                padding: 12px 15px;\n                text-align: left; /* Left aligned */\n            }\n            tbody tr {\n                border-bottom: 1px solid #DBE2EF;\n            }\n            tbody tr:nth-of-type(even) {\n                background-color: #F9F7F7;\n            }\n            tbody tr:last-of-type {\n                border-bottom: 2px solid #3F72AF;\n            }\n            tbody tr:hover {\n                background-color: #DBE2EF;\n            }\n        </style>\n\n        <table>\n            <thead>\n                <tr>\n                    <th>Outcome</th>\n                    <th>Binary</th>\n                    <th>Amplitude</th>\n                    <th>Magnitude</th>\n                    <th>Direction</th>\n                    <th>Amplitude Bar</th>\n                    <th>Probability</th>\n                </tr>\n            </thead>\n            <tbody>\n    `;\n\n    tableData.forEach(row => {\n        htmlTable += `\n            <tr>\n                <td>${row.outcome}</td>\n                <td>${row.binary}</td>\n                <td>${row.amplitude}</td>\n                <td>${row.magnitude}</td>\n                <td>${row.direction}</td>\n                <td>${row.amplitudeBar}</td>\n                <td>${row.probability}</td>\n            </tr>\n        `;\n    });\n\n    htmlTable += `\n            </tbody>\n        </table>\n    `;\n\n    document.getElementById(id).innerHTML = htmlTable;\n}\n\n\nasync function grid_state_to_html(state, m = 1, neg = false, showProbs = false, symbol = '\\u2588') {\n    const n = Math.log2(state.length) - m;\n    const cols = 2 ** m;\n    const rows = Math.floor(state.length / cols);\n\n    let htmlTable = `\n        <style>\n            table {\n                max-width: 100%;\n                border-collapse: collapse;\n                margin: 25px 0;\n                font-size: 0.9em;\n                border-radius: 10px;\n                box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);\n                text-align: center;\n            }\n            thead tr {\n                background-color: #3F72AF;\n                color: #ffffff;\n                font-weight: bold;\n            }\n            th, td {\n                padding: 12px 15px;\n                white-space: nowrap; /* Ensure text doesn't wrap */\n                text-overflow: ellipsis; /* Add ellipsis if text is too long */\n            }\n            tbody tr {\n                border-bottom: 1px solid #DBE2EF;\n            }\n            tbody tr:nth-of-type(even) {\n                background-color: #F9F7F7;\n            }\n            tbody tr:last-of-type {\n                border-bottom: 2px solid #3F72AF;\n            }\n            tbody tr:hover {\n                background-color: #DBE2EF;\n            }\n        </style>\n    `;\n\n    htmlTable += '<table><thead><tr><th></th>';\n\n    for (let l = 0; l < cols; l++) {\n        htmlTable += `<th>${l} = ${l.toString(2).padStart(m, '0')}</th>`;\n    }\n    htmlTable += '</tr></thead><tbody>';\n\n    const rangeFunc = neg\n        ? (x) => [...Array(x / 2).keys()].reverse().concat([...Array(x / 2).keys()].map(i => i + x / 2).reverse())\n        : (x) => [...Array(x).keys()].reverse();\n\n    for (let k of rangeFunc(rows)) {\n        const rowLabel = neg\n            ? `${(k < rows / 2 ? k : k - rows)} = ${k.toString(2).padStart(n, '0')}`\n            : `${k} = ${k.toString(2).padStart(n, '0')}`;\n\n        let row = `<tr><td>${rowLabel}</td>`;\n\n        for (let l = 0; l < cols; l++) {\n            const index = k * cols + l;\n            const re = state[index].re !== undefined ? state[index].re : state[index];\n            const im = state[index].im !== undefined ? state[index].im : 0;\n            const magnitude = Math.sqrt(re * re + im * im);\n            const complexValue = mathjs__WEBPACK_IMPORTED_MODULE_2__.complex(re, im);\n            const color = await complex_to_rgb(complexValue, true);\n            const magnitudeForDisplay = Math.floor(magnitude * 10);\n            const probability = showProbs && magnitude > 0.01 ? (magnitude ** 2).toFixed(2) : '';\n\n            row += `<td><font style=\"color: rgb(${color[0]}, ${color[1]}, ${color[2]});\">${symbol.repeat(magnitudeForDisplay)}</font>&nbsp;${probability}</td>`;\n        }\n\n        htmlTable += row + '</tr>';\n    }\n\n    htmlTable += '</tbody></table>';\n\n    return htmlTable;\n}\n\n\n\nfunction circuit_to_string(qc) {\n    const qs = Array.from({ length: qc.regs.reduce((a, b) => a + b, 0) }, (_, i) => ({ id: i }));\n\n    const ops = qc.transformations.map(tr => ({\n        gate: tr.arg === undefined ? tr.name.toUpperCase() : `${tr.name.toUpperCase()}(${Math.round(tr.arg * 100) / 100})`,\n        isControlled: tr.controls.length > 0,\n        controls: tr.controls.map(c => ({ qId: c })),\n        targets: [{ qId: tr.target }]\n    }));\n\n    const circ = { qubits: qs, operations: ops };\n\n    return JSON.stringify(circ).replace(/\"true\"/g, 'true').replace(/\"false\"/g, 'false');\n}\n\nfunction draw_circuit(circuit_string, circuit_div) {\n    circuit_string = JSON.parse(circuit_string);\n    if (circuit_div != null) {\n        _microsoft_quantum_viz_js__WEBPACK_IMPORTED_MODULE_1__.draw(circuit_string, circuit_div, _microsoft_quantum_viz_js__WEBPACK_IMPORTED_MODULE_1__.STYLES['Default'])\n    }\n}\n\n\n\n//# sourceURL=webpack://humejs/./src/lib/utils/common.js?");

/***/ }),

/***/ "./src/lib/utils/matrix.js":
/*!*********************************!*\
  !*** ./src/lib/utils/matrix.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   argmax: () => (/* binding */ argmax),\n/* harmony export */   asArray: () => (/* binding */ asArray),\n/* harmony export */   dagger: () => (/* binding */ dagger),\n/* harmony export */   eig: () => (/* binding */ eig),\n/* harmony export */   random_transformation: () => (/* binding */ random_transformation),\n/* harmony export */   shape: () => (/* binding */ shape)\n/* harmony export */ });\n/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mathjs */ \"./node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js\");\n\n\nfunction argmax(array) {\n    return array.indexOf(Math.max(...array));\n}\n\nfunction asArray(l) {\n    return Array.isArray(l) ? l : Array.from(l);\n}\n\nfunction shape(U) {\n    return mathjs__WEBPACK_IMPORTED_MODULE_0__.size(U)._data;\n}\n\nfunction dagger(U) {\n    return mathjs__WEBPACK_IMPORTED_MODULE_0__.transpose(mathjs__WEBPACK_IMPORTED_MODULE_0__.conj(U));\n}\n\nfunction eig(U) {\n    return mathjs__WEBPACK_IMPORTED_MODULE_0__.eigs(U);\n}\n\n// function rvs(dim) {\n//     let random_state = Math.random;\n//     let H = math.identity(dim)._data;\n//     let D = Array(dim).fill(1);\n\n//     for (let n = 1; n < dim; n++) {\n//         let x = Array(dim - n + 1).fill(0).map(() => math.randomNormal());\n//         D[n - 1] = Math.sign(x[0]);\n//         x[0] -= D[n - 1] * Math.sqrt(math.sum(math.square(x)));\n        \n//         let Hx = math.subtract(\n//             math.identity(dim - n + 1)._data,\n//             math.multiply(2, math.divide(math.multiply(x, math.transpose(x)), math.sum(math.square(x))))\n//         );\n\n//         let mat = math.identity(dim)._data;\n//         for (let i = n - 1; i < dim; i++) {\n//             for (let j = n - 1; j < dim; j++) {\n//                 mat[i][j] = Hx[i - (n - 1)][j - (n - 1)];\n//             }\n//         }\n\n//         H = math.multiply(H, mat);\n//     }\n\n//     D[dim - 1] = Math.pow(-1, 1 - (dim % 2)) * D.reduce((a, b) => a * b, 1);\n    \n//     H = math.multiply(D, math.transpose(H));\n    \n//     return H;\n// }\n\nfunction random_transformation(n) {\n    let U = rvs(Math.pow(2, n));\n\n    function fDirect(state) {\n        if (state.length !== Math.pow(2, n)) {\n            throw new Error('State vector length must be 2^n');\n        }\n        let s = mathjs__WEBPACK_IMPORTED_MODULE_0__.multiply(U, state);\n        for (let k = 0; k < s.length; k++) {\n            state[k] = s[k];\n        }\n    }\n\n    function f_inverse(state) {\n        if (state.length !== Math.pow(2, n)) {\n            throw new Error('State vector length must be 2^n');\n        }\n        let s = mathjs__WEBPACK_IMPORTED_MODULE_0__.multiply(dagger(U), state);\n        for (let k = 0; k < s.length; k++) {\n            state[k] = s[k];\n        }\n    }\n\n    return { fDirect, f_inverse };\n}\n\n\n\n\n//# sourceURL=webpack://humejs/./src/lib/utils/matrix.js?");

/***/ })

}]);