"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhumejs"] = self["webpackChunkhumejs"] || []).push([["src_lib_simulator_circuit_js"],{

/***/ "./src/lib/simulator/circuit.js":
/*!**************************************!*\
  !*** ./src/lib/simulator/circuit.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IQFT: () => (/* binding */ IQFT),\n/* harmony export */   QFT: () => (/* binding */ QFT),\n/* harmony export */   QuantumCircuit: () => (/* binding */ QuantumCircuit),\n/* harmony export */   QuantumRegister: () => (/* binding */ QuantumRegister),\n/* harmony export */   QuantumTransformation: () => (/* binding */ QuantumTransformation),\n/* harmony export */   Swap: () => (/* binding */ Swap)\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./src/lib/simulator/core.js\");\n/* harmony import */ var _gates_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gates.js */ \"./src/lib/simulator/gates.js\");\n/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/matrix.js */ \"./src/lib/utils/matrix.js\");\n\n\n\n\n\nconst pi = Math.PI;\n\nclass Swap {\n    constructor(i, j) {\n        this.name = 'swap';\n        this.i = i;\n        this.j = j;\n    }\n\n    toString() {\n        return `swap ${this.i} ${this.j}`;\n    }\n}\n\nclass QuantumRegister {\n    constructor(size, shift = 0) {\n        this.size = size;\n        this.shift = shift;\n    }\n\n    get(key) {\n        if (typeof key === 'number') {\n            if (key < 0) {\n                key += this.size;\n            }\n            if (key >= 0 && key < this.size) {\n                return this.shift + key;\n            }\n        } else if (Array.isArray(key)) {\n            return key.map(k => this.get(k));\n        }\n    }\n\n    *[Symbol.iterator]() {\n        for (let i = 0; i < this.size; i++) {\n            yield this.shift + i;\n        }\n    }\n\n    reverse() {\n        return [...this].reverse();\n    }\n\n    length() {\n        return this.size;\n    }\n}\n\nclass QuantumTransformation {\n    constructor(gate, target, controls = [], name = null, arg = null) {\n        this.gate = gate;\n        this.target = target;\n        this.controls = controls;\n        this.name = name;\n        this.arg = arg;\n    }\n\n    toString() {\n        return `${this.name} ${this.arg !== null ? Math.round(this.arg * 100) / 100 : \"\"} ${this.controls} ${this.target}`;\n    }\n\n    clone() {\n        return new QuantumTransformation(this.gate, this.target, [...this.controls], this.name, this.arg);\n    }\n}\n\nclass QuantumCircuit {\n    constructor(...args) {\n        let bits = 0;\n        let regs = [];\n\n        for (let reg of args) {\n            if (typeof reg === 'number') {\n\n                reg = { size: reg, shift: bits };\n            } else if (typeof reg.size === 'number') {\n  \n                reg.shift = bits;\n            } else {\n                throw new Error('Invalid argument passed to QuantumCircuit constructor');\n            }\n\n            bits += reg.size;\n            regs.push(reg.size);\n        }\n\n        this.state = (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.init_state)(bits);\n        this.transformations = [];\n        this.regs = regs;\n        this.reports = {};\n    }\n\n    initialize(state) {\n        this.state = state;\n    }\n\n    x(t) { this.transformations.push(new QuantumTransformation(_gates_js__WEBPACK_IMPORTED_MODULE_1__.x, t, [], 'x')); }\n    y(t) { this.transformations.push(new QuantumTransformation(_gates_js__WEBPACK_IMPORTED_MODULE_1__.y, t, [], 'y')); }\n    z(t) { this.transformations.push(new QuantumTransformation(_gates_js__WEBPACK_IMPORTED_MODULE_1__.z, t, [], 'z')); }\n    h(t) { this.transformations.push(new QuantumTransformation(_gates_js__WEBPACK_IMPORTED_MODULE_1__.h, t, [], 'h')); }\n    p(theta, t) { this.transformations.push(new QuantumTransformation((0,_gates_js__WEBPACK_IMPORTED_MODULE_1__.phase)(theta), t, [], 'p', theta)); }\n    rx(theta, t) { this.transformations.push(new QuantumTransformation((0,_gates_js__WEBPACK_IMPORTED_MODULE_1__.rx)(theta), t, [], 'rx', theta)); }\n    ry(theta, t) { this.transformations.push(new QuantumTransformation((0,_gates_js__WEBPACK_IMPORTED_MODULE_1__.ry)(theta), t, [], 'ry', theta)); }\n    rz(theta, t) { this.transformations.push(new QuantumTransformation((0,_gates_js__WEBPACK_IMPORTED_MODULE_1__.rz)(theta), t, [], 'rz', theta)); }\n    cx(c, t) { this.transformations.push(new QuantumTransformation(_gates_js__WEBPACK_IMPORTED_MODULE_1__.x, t, [c], 'cx')); }\n    cy(c, t) { this.transformations.push(new QuantumTransformation(_gates_js__WEBPACK_IMPORTED_MODULE_1__.y, t, [c], 'cy')); }\n    cz(c, t) { this.transformations.push(new QuantumTransformation(_gates_js__WEBPACK_IMPORTED_MODULE_1__.z, t, [c], 'cz')); }\n    cp(theta, c, t) { this.transformations.push(new QuantumTransformation((0,_gates_js__WEBPACK_IMPORTED_MODULE_1__.phase)(theta), t, [c], 'cp', theta)); }\n    cry(theta, c, t) { this.transformations.push(new QuantumTransformation((0,_gates_js__WEBPACK_IMPORTED_MODULE_1__.ry)(theta), t, [c], 'cry', theta)); }\n    mcx(cs, t) { this.transformations.push(new QuantumTransformation(_gates_js__WEBPACK_IMPORTED_MODULE_1__.x, t, cs, 'mcx')); }\n    mcp(theta, cs, t) { this.transformations.push(new QuantumTransformation((0,_gates_js__WEBPACK_IMPORTED_MODULE_1__.phase)(theta), t, cs, 'mcp', theta)); }\n\n    measure(shots = 0) {\n        const state = this.run();\n        const samples = (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.measure)(state, shots);\n        return { 'state vector': state, 'counts': samples };\n    }\n\n    report(name = null) {\n        let start_state = (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.init_state)(this.regs.reduce((acc, reg) => acc + reg, 0));\n        let tr_count = 0;\n\n        for (let report of Object.values(this.reports)) {\n            if (report[3] > tr_count) {\n                tr_count = report[3];\n                start_state = report[2];\n            }\n        }\n\n        const qc = new QuantumCircuit();\n        qc.regs = [...this.regs];\n        qc.initialize([...start_state]);\n        qc.transformations = this.transformations.slice(tr_count);\n\n        const end_state = qc.run();\n        if (!name) {\n            name = Object.keys(this.reports).length;\n        }\n        this.reports[name] = [start_state, this.transformations.slice(tr_count), end_state, this.transformations.length];\n\n        return this.reports[name];\n    }\n\n    run() {\n        console.log(this.transformations);\n        for (let tr of this.transformations) {\n            if (tr.name === 'unitary') {\n                \n                const cs = tr.controls;\n                if (cs.length === 0) {\n                    (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.transform_u)(this.state, tr.gate, tr.target);\n                } else if (cs.length === 1) {\n                    (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.c_transform_u)(this.state, tr.gate, cs[0], tr.target);\n                }\n            } else if (tr instanceof Swap) {\n                (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.c_transform)(this.state, tr.i, tr.j, _gates_js__WEBPACK_IMPORTED_MODULE_1__.x);\n                (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.c_transform)(this.state, tr.j, tr.i, _gates_js__WEBPACK_IMPORTED_MODULE_1__.x);\n                (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.c_transform)(this.state, tr.i, tr.j, _gates_js__WEBPACK_IMPORTED_MODULE_1__.x);\n            } else {\n                const cs = tr.controls;\n                console.log(\"trcontrols:\");\n                console.log(tr.controls);\n                if (cs.length === 0) {\n                    (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.transform)(this.state, tr.target, tr.gate);\n                } else if (cs.length === 1) {\n                    (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.c_transform)(this.state, cs[0], tr.target, tr.gate);\n                } else {\n                    (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.mc_transform)(this.state, cs, tr.target, tr.gate);\n                }\n            }\n        }\n        this.transformations = [];\n        return this.state;\n    }\n\n    swap(i, j) {\n        this.transformations.push(new Swap(i, j));\n    }\n\n    mswap(targets) {\n        for (let j = 0; j < Math.floor(targets.length / 2); j++) {\n            this.swap(targets[j], targets[targets.length - 1 - j]);\n        }\n    }\n\n    inverse() {\n        const qs = this.regs.map(size => new QuantumRegister(size));\n        const qc = new QuantumCircuit(...qs);\n\n        for (let tr of this.transformations.reverse()) {\n            if (tr instanceof Swap) {\n                qc.swap(tr.i, tr.j);\n            } else if (tr.name === 'unitary') {\n                const cs = tr.controls;\n                if (cs.length === 0) {\n                    qc.unitary((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_2__.dagger)(tr.gate), tr.target);\n                } else if (cs.length === 1) {\n                    qc.c_unitary((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_2__.dagger)(tr.gate), cs[0], tr.target);\n                }\n            } else {\n                const prefix = tr.controls.length === 0 ? '' : tr.controls.length === 1 ? 'c' : 'mc';\n                const method = qc[prefix + tr.name].bind(qc);\n                const t = tr.target;\n\n                if (tr.arg) {\n                    method(-tr.arg, ...tr.controls, t);\n                } else {\n                    method(...tr.controls, t);\n                }\n            }\n        }\n        return qc;\n    }\n\n    qft(targets, swap = true) {\n        qft(this, targets, swap);\n    }\n\n    append_qft(reg, reversed = false, swap = true) {\n        this.append(new QFT(reg.size, reversed, swap), reg);\n    }\n\n    iqft(targets, swap = true) {\n        iqft(this, targets, swap);\n    }\n\n    append_iqft(reg, reversed = false, swap = true) {\n        this.append(new IQFT(reg.size, reversed, swap), reg);\n    }\n\n    append(circuit, reg) {\n        if (reg.size !== circuit.regs.reduce((acc, size) => acc + size, 0)) {\n            throw new Error(\"Mismatched register sizes.\");\n        }\n\n        for (let tr of circuit.transformations) {\n            if (tr instanceof Swap) {\n                this.transformations.push(new Swap(reg.shift + tr.i, reg.shift + tr.j));\n            } else {\n                this.transformations.push(new QuantumTransformation(\n                    tr.gate,\n                    reg.shift + tr.target,\n                    tr.controls.map(c => reg.shift + c),\n                    tr.name,\n                    tr.arg\n                ));\n            }\n        }\n    }\n\n    c_append(circuit, c, reg) {\n        if (reg.size <= circuit.regs.reduce((acc, size) => acc + size, 0)) {\n            throw new Error(\"Mismatched register sizes.\");\n        }\n\n        for (let tr of circuit.transformations) {\n            if (tr instanceof Swap) {\n                this.transformations.push(new Swap(reg.shift + tr.i, reg.shift + tr.j));\n            } else {\n                this.transformations.push(new QuantumTransformation(\n                    tr.gate,\n                    reg.shift + tr.target,\n                    [c].concat(tr.controls.map(c => reg.shift + c)),\n                    tr.name,\n                    tr.arg\n                ));\n            }\n        }\n    }\n\n    mc_append(circuit, cs, reg) {\n        if (new Set(cs).size !== cs.length) {\n            throw new Error(\"Control qubits must be unique.\");\n        }\n\n        for (let c of cs) {\n            if (c >= reg.shift && c < reg.shift + reg.size) {\n                throw new Error(\"Control qubits must be outside the target register.\");\n            }\n        }\n\n        for (let tr of circuit.transformations) {\n            if (tr instanceof Swap) {\n                this.transformations.push(new Swap(reg.shift + tr.i, reg.shift + tr.j));\n            } else {\n                this.transformations.push(new QuantumTransformation(\n                    tr.gate,\n                    reg.shift + tr.target,\n                    cs.concat(tr.controls.map(c => reg.shift + c)),\n                    tr.name,\n                    tr.arg\n                ));\n            }\n        }\n    }\n\n    unitary(U, t) {\n        this.transformations.push(new QuantumTransformation(U, t, [], 'unitary'));\n    }\n\n    append_u(U, q) {\n        if (U.length !== U[0].length || U.length !== 2 ** q.length()) {\n            throw new Error(\"Invalid unitary matrix size.\");\n        }\n        this.unitary(U, q.shift);\n    }\n\n    c_unitary(U, c, t) {\n        this.transformations.push(new QuantumTransformation(U, t, [c], 'unitary'));\n    }\n\n    c_append_u(U, c, q) {\n        if (U.length !== U[0].length || U.length !== 2 ** q.length()) {\n            throw new Error(\"Invalid unitary matrix size.\");\n        }\n        this.c_unitary(U, c, q.shift);\n    }\n}\n\nclass QFT extends QuantumCircuit {\n    constructor(m, reversed = false, swap = true) {\n        super(new QuantumRegister(m));\n        const targets = reversed ? [...Array(m).keys()].reverse() : [...Array(m).keys()];\n        qft(this, targets, swap);\n    }\n}\n\nclass IQFT extends QuantumCircuit {\n    constructor(m, reversed = false, swap = true) {\n        super(new QuantumRegister(m));\n        const targets = reversed ? [...Array(m).keys()].reverse() : [...Array(m).keys()];\n        iqft(this, targets, swap);\n    }\n}\n\nfunction qft(qc, targets, swap = true) {\n    for (let j = targets.length - 1; j >= 0; j--) {\n        qc.h(targets[j]);\n        for (let k = j - 1; k >= 0; k--) {\n            qc.cp(pi * 2 ** (k - j), targets[j], targets[k]);\n        }\n    }\n    if (swap) {\n        qc.mswap(targets);\n    }\n}\n\nfunction iqft(qc, targets, swap = true) {\n    for (let j = targets.length - 1; j >= 0; j--) {\n        qc.h(targets[j]);\n        for (let k = j - 1; k >= 0; k--) {\n            qc.cp(-pi * 2 ** (k - j), targets[j], targets[k]);\n        }\n    }\n    if (swap) {\n        qc.mswap(targets);\n    }\n}\n\n\n\n//# sourceURL=webpack://humejs/./src/lib/simulator/circuit.js?");

/***/ }),

/***/ "./src/lib/utils/matrix.js":
/*!*********************************!*\
  !*** ./src/lib/utils/matrix.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   argmax: () => (/* binding */ argmax),\n/* harmony export */   asArray: () => (/* binding */ asArray),\n/* harmony export */   dagger: () => (/* binding */ dagger),\n/* harmony export */   eig: () => (/* binding */ eig),\n/* harmony export */   random_transformation: () => (/* binding */ random_transformation),\n/* harmony export */   shape: () => (/* binding */ shape)\n/* harmony export */ });\n/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mathjs */ \"./node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js\");\n\n\nfunction argmax(array) {\n    return array.indexOf(Math.max(...array));\n}\n\nfunction asArray(l) {\n    return Array.isArray(l) ? l : Array.from(l);\n}\n\nfunction shape(U) {\n    return mathjs__WEBPACK_IMPORTED_MODULE_0__.size(U)._data;\n}\n\nfunction dagger(U) {\n    return mathjs__WEBPACK_IMPORTED_MODULE_0__.transpose(mathjs__WEBPACK_IMPORTED_MODULE_0__.conj(U));\n}\n\nfunction eig(U) {\n    return mathjs__WEBPACK_IMPORTED_MODULE_0__.eigs(U);\n}\n\n// function rvs(dim) {\n//     let random_state = Math.random;\n//     let H = math.identity(dim)._data;\n//     let D = Array(dim).fill(1);\n\n//     for (let n = 1; n < dim; n++) {\n//         let x = Array(dim - n + 1).fill(0).map(() => math.randomNormal());\n//         D[n - 1] = Math.sign(x[0]);\n//         x[0] -= D[n - 1] * Math.sqrt(math.sum(math.square(x)));\n        \n//         let Hx = math.subtract(\n//             math.identity(dim - n + 1)._data,\n//             math.multiply(2, math.divide(math.multiply(x, math.transpose(x)), math.sum(math.square(x))))\n//         );\n\n//         let mat = math.identity(dim)._data;\n//         for (let i = n - 1; i < dim; i++) {\n//             for (let j = n - 1; j < dim; j++) {\n//                 mat[i][j] = Hx[i - (n - 1)][j - (n - 1)];\n//             }\n//         }\n\n//         H = math.multiply(H, mat);\n//     }\n\n//     D[dim - 1] = Math.pow(-1, 1 - (dim % 2)) * D.reduce((a, b) => a * b, 1);\n    \n//     H = math.multiply(D, math.transpose(H));\n    \n//     return H;\n// }\n\nfunction random_transformation(n) {\n    let U = rvs(Math.pow(2, n));\n\n    function fDirect(state) {\n        if (state.length !== Math.pow(2, n)) {\n            throw new Error('State vector length must be 2^n');\n        }\n        let s = mathjs__WEBPACK_IMPORTED_MODULE_0__.multiply(U, state);\n        for (let k = 0; k < s.length; k++) {\n            state[k] = s[k];\n        }\n    }\n\n    function f_inverse(state) {\n        if (state.length !== Math.pow(2, n)) {\n            throw new Error('State vector length must be 2^n');\n        }\n        let s = mathjs__WEBPACK_IMPORTED_MODULE_0__.multiply(dagger(U), state);\n        for (let k = 0; k < s.length; k++) {\n            state[k] = s[k];\n        }\n    }\n\n    return { fDirect, f_inverse };\n}\n\n\n\n\n//# sourceURL=webpack://humejs/./src/lib/utils/matrix.js?");

/***/ })

}]);