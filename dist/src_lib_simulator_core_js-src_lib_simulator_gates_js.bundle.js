/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhumejs"] = self["webpackChunkhumejs"] || []).push([["src_lib_simulator_core_js-src_lib_simulator_gates_js"],{

/***/ "?d4c0":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://humejs/crypto_(ignored)?");

/***/ }),

/***/ "./src/lib/simulator/core.js":
/*!***********************************!*\
  !*** ./src/lib/simulator/core.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c_transform: () => (/* binding */ c_transform),\n/* harmony export */   c_transform_u: () => (/* binding */ c_transform_u),\n/* harmony export */   init_state: () => (/* binding */ init_state),\n/* harmony export */   is_bit_set: () => (/* binding */ is_bit_set),\n/* harmony export */   is_power_of_two: () => (/* binding */ is_power_of_two),\n/* harmony export */   mc_transform: () => (/* binding */ mc_transform),\n/* harmony export */   measure: () => (/* binding */ measure),\n/* harmony export */   pair_generator_check_digit: () => (/* binding */ pair_generator_check_digit),\n/* harmony export */   pair_generator_concatenate: () => (/* binding */ pair_generator_concatenate),\n/* harmony export */   pair_generator_pattern: () => (/* binding */ pair_generator_pattern),\n/* harmony export */   prepare_state: () => (/* binding */ prepare_state),\n/* harmony export */   process_pair: () => (/* binding */ process_pair),\n/* harmony export */   transform: () => (/* binding */ transform),\n/* harmony export */   transform_u: () => (/* binding */ transform_u)\n/* harmony export */ });\n/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mathjs */ \"./node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js\");\n/* harmony import */ var _utils_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/common.js */ \"./src/lib/utils/common.js\");\n\n\n\nfunction is_power_of_two(m) {\n    return Math.ceil(Math.log2(m)) === Math.floor(Math.log2(m));\n}\n\nfunction prepare_state(...a) {\n    const state = [...a];\n    if (!is_power_of_two(state.length)) {\n        throw new Error(\"Length of state must be a power of two\");\n    }\n    const norm = state.reduce((acc, val) => acc + mathjs__WEBPACK_IMPORTED_MODULE_1__.pow(mathjs__WEBPACK_IMPORTED_MODULE_1__.abs(val), 2), 0);\n    if (!(0,_utils_common_js__WEBPACK_IMPORTED_MODULE_0__.is_close)(norm, 1.0)) {\n        throw new Error(\"State is not normalized\");\n    }\n    return state;\n}\n\nfunction init_state(n) {\n    const state = Array(Math.pow(2, n)).fill(null).map(() => mathjs__WEBPACK_IMPORTED_MODULE_1__.complex(0, 0));\n\n    state[0] = mathjs__WEBPACK_IMPORTED_MODULE_1__.complex(1, 0);\n\n    return state;\n}\n\nfunction is_bit_set(m, k) {\n    return (m & (1 << k)) !== 0;\n}\n\nfunction* pair_generator_check_digit(n, t) {\n    const distance = 2 ** t;\n    for (let k0 = 0; k0 < 2 ** n; k0++) {\n        if (!is_bit_set(k0, t)) {\n            const k1 = k0 + distance;\n            yield [k0, k1];\n        }\n    }\n}\n\nfunction* pair_generator_concatenate(n, t) {\n    const distance = 2 ** t;\n    const suffix_count = 2 ** t;\n    const prefix_count = 2 ** (n - t - 1);\n\n    for (let p = 0; p < prefix_count; p++) {\n        for (let s = 0; s < suffix_count; s++) {\n            const k0 = p * suffix_count * 2 + s;\n            const k1 = k0 + distance;\n            yield [k0, k1];\n        }\n    }\n}\n\nfunction* pair_generator_pattern(n, t) {\n    const distance = 2 ** t;\n    for (let j = 0; j < 2 ** (n - t - 1); j++) {\n        for (let k0 = 2 * j * distance; k0 < (2 * j + 1) * distance; k0++) {\n            const k1 = k0 + distance;\n            yield [k0, k1];\n        }\n    }\n}\n\nconst pair_generator = pair_generator_concatenate;\n\n\nfunction process_pair(state, gate, k0=0, k1=1) {\n    const x = state[k0];\n    const y = state[k1];\n    state[k0] = mathjs__WEBPACK_IMPORTED_MODULE_1__.add(mathjs__WEBPACK_IMPORTED_MODULE_1__.multiply(x, gate[0][0]), mathjs__WEBPACK_IMPORTED_MODULE_1__.multiply(y, gate[0][1]));\n    state[k1] = mathjs__WEBPACK_IMPORTED_MODULE_1__.add(mathjs__WEBPACK_IMPORTED_MODULE_1__.multiply(x, gate[1][0]), mathjs__WEBPACK_IMPORTED_MODULE_1__.multiply(y, gate[1][1]));\n}\n\nfunction transform(state, t, gate) {\n    const n = Math.log2(state.length);\n    for (const [k0, k1] of pair_generator(n, t)) {\n        if (k1 >= state.length) {\n            continue;\n        }\n        process_pair(state, gate, k0, k1);\n    }\n}\n\n\nfunction c_transform(state, c, t, gate) {\n    const n = Math.log2(state.length);\n    for (const [k0, k1] of Array.from(pair_generator(n, t)).filter(p => is_bit_set(p[0], c))) {\n        process_pair(state, gate, k0, k1);\n    }\n}\n\nfunction mc_transform(state, cs, t, gate) {\n    if (cs.includes(t)) {\n        throw new Error(\"Target qubit cannot be one of the control qubits\");\n    }\n    const n = Math.log2(state.length);\n    for (const [k0, k1] of Array.from(pair_generator(n, t)).filter(p => cs.every(c => is_bit_set(p[0], c)))) {\n        process_pair(state, gate, k0, k1);\n    }\n}\n\nfunction measure(state, shots) {\n    const probabilities = state.map(c => mathjs__WEBPACK_IMPORTED_MODULE_1__.pow(mathjs__WEBPACK_IMPORTED_MODULE_1__.abs(c), 2));\n    const samples = Array(shots).fill(0).map(() => mathjs__WEBPACK_IMPORTED_MODULE_1__.random(probabilities.length));\n    const counts = {};\n    samples.forEach(s => {\n        counts[s] = (counts[s] || 0) + 1;\n    });\n    return counts;\n}\n\nfunction transform_u(state, U, t) {\n    if (U.length !== U[0].length) {\n        throw new Error(\"Matrix U must be square\");\n    }\n    const m = Math.log2(U.length);\n    const n = Math.log2(state.length);\n\n    const vec = Array(2 ** m).fill(0);\n\n    for (let suffix = 0; suffix < 2 ** t; suffix++) {\n        for (let prefix = 0; prefix < 2 ** (n - m - t); prefix++) {\n            for (let target = 0; target < 2 ** m; target++) {\n                const k = prefix * 2 ** (t + m) + target * 2 ** t + suffix;\n                vec[target] = state[k];\n            }\n\n            const vec_out = mathjs__WEBPACK_IMPORTED_MODULE_1__.multiply(U, vec);\n\n            for (let target = 0; target < 2 ** m; target++) {\n                const k = prefix * 2 ** (t + m) + target * 2 ** t + suffix;\n                state[k] = vec_out[target];\n            }\n        }\n    }\n}\n\nfunction c_transform_u(state, U, c, t) {\n    if (U.length !== U[0].length) {\n        throw new Error(\"Matrix U must be square\");\n    }\n    const m = Math.log2(U.length);\n    const n = Math.log2(state.length);\n\n    const vec = Array(2 ** m).fill(0);\n\n    for (let suffix = 0; suffix < 2 ** t; suffix++) {\n        for (let prefix = 0; prefix < 2 ** (n - m - t); prefix++) {\n            const targets = [];\n            for (let idx = 0; idx < 2 ** m; idx++) {\n                const k = prefix * 2 ** (t + m) + idx * 2 ** t + suffix;\n                if (is_bit_set(k, c)) {\n                    vec[idx] = state[k];\n                    targets.push(k);\n                }\n            }\n\n            const vec_out = mathjs__WEBPACK_IMPORTED_MODULE_1__.multiply(U, vec);\n\n            for (let idx = 0; idx < 2 ** m; idx++) {\n                const k = prefix * 2 ** (t + m) + idx * 2 ** t + suffix;\n                if (is_bit_set(k, c)) {\n                    state[k] = vec_out[idx];\n                }\n            }\n        }\n    }\n}\n\n\n\n\n//# sourceURL=webpack://humejs/./src/lib/simulator/core.js?");

/***/ }),

/***/ "./src/lib/simulator/gates.js":
/*!************************************!*\
  !*** ./src/lib/simulator/gates.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ h),\n/* harmony export */   phase: () => (/* binding */ phase),\n/* harmony export */   rx: () => (/* binding */ rx),\n/* harmony export */   ry: () => (/* binding */ ry),\n/* harmony export */   rz: () => (/* binding */ rz),\n/* harmony export */   x: () => (/* binding */ x),\n/* harmony export */   y: () => (/* binding */ y),\n/* harmony export */   z: () => (/* binding */ z)\n/* harmony export */ });\n/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mathjs */ \"./node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js\");\n\n\nconst x = [\n    [0, 1],\n    [1, 0]\n];\n\nconst z = [\n    [1, 0],\n    [0, -1]\n];\n\nfunction phase(theta) {\n    return [\n        [1, 0],\n        [0, mathjs__WEBPACK_IMPORTED_MODULE_0__.complex(Math.cos(theta), Math.sin(theta))]\n    ];\n}\n\nconst h = [\n    [1 / Math.sqrt(2), 1 / Math.sqrt(2)],\n    [1 / Math.sqrt(2), -1 / Math.sqrt(2)]\n];\n\nfunction rz(theta) {\n    return [\n        [mathjs__WEBPACK_IMPORTED_MODULE_0__.complex(Math.cos(theta / 2), -Math.sin(theta / 2)), 0],\n        [0, mathjs__WEBPACK_IMPORTED_MODULE_0__.complex(Math.cos(theta / 2), Math.sin(theta / 2))]\n    ];\n}\n\nconst y = [\n    [0, mathjs__WEBPACK_IMPORTED_MODULE_0__.complex(0, -1)],\n    [mathjs__WEBPACK_IMPORTED_MODULE_0__.complex(0, 1), 0]\n];\n\nfunction rx(theta) {\n    return [\n        [Math.cos(theta / 2), mathjs__WEBPACK_IMPORTED_MODULE_0__.complex(0, -Math.sin(theta / 2))],\n        [mathjs__WEBPACK_IMPORTED_MODULE_0__.complex(0, -Math.sin(theta / 2)), Math.cos(theta / 2)]\n    ];\n}\n\nfunction ry(theta) {\n    return [\n        [Math.cos(theta / 2), -Math.sin(theta / 2)],\n        [Math.sin(theta / 2), Math.cos(theta / 2)]\n    ];\n}\n\n\n\n\n//# sourceURL=webpack://humejs/./src/lib/simulator/gates.js?");

/***/ }),

/***/ "./src/lib/utils/common.js":
/*!*********************************!*\
  !*** ./src/lib/utils/common.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   all_close: () => (/* binding */ all_close),\n/* harmony export */   choices: () => (/* binding */ choices),\n/* harmony export */   circuit_to_string: () => (/* binding */ circuit_to_string),\n/* harmony export */   cis: () => (/* binding */ cis),\n/* harmony export */   complex_to_rgb: () => (/* binding */ complex_to_rgb),\n/* harmony export */   draw_circuit: () => (/* binding */ draw_circuit),\n/* harmony export */   grid_state_to_html: () => (/* binding */ grid_state_to_html),\n/* harmony export */   is_close: () => (/* binding */ is_close),\n/* harmony export */   is_close_float: () => (/* binding */ is_close_float),\n/* harmony export */   print_state: () => (/* binding */ print_state),\n/* harmony export */   squaredMagnitude: () => (/* binding */ squaredMagnitude),\n/* harmony export */   state_table_to_html: () => (/* binding */ state_table_to_html)\n/* harmony export */ });\n/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mathjs */ \"./node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js\");\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"./node_modules/d3/src/index.js\");\n/* harmony import */ var _microsoft_quantum_viz_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @microsoft/quantum-viz.js */ \"./node_modules/@microsoft/quantum-viz.js/dist/qviz.min.js\");\n\n\n\n\nfunction is_close_float(a, b, rtol = 1e-5, atol = 1e-8) {\n    return Math.abs(a - b) < atol + rtol * Math.abs(b);\n}\n\nfunction is_close(a, b) {\n    if (typeof a === 'number') {\n        a = mathjs__WEBPACK_IMPORTED_MODULE_2__.complex(a, 0);\n    }\n\n    if (typeof b === 'number') {\n        b = mathjs__WEBPACK_IMPORTED_MODULE_2__.complex(b, 0);\n    }\n\n    return is_close_float(mathjs__WEBPACK_IMPORTED_MODULE_2__.re(a), mathjs__WEBPACK_IMPORTED_MODULE_2__.re(b)) && is_close_float(mathjs__WEBPACK_IMPORTED_MODULE_2__.im(a), mathjs__WEBPACK_IMPORTED_MODULE_2__.im(b));\n}\n\nfunction all_close(state1, state2) {\n    for (let i = 0; i < state1.length; i++) {\n        if (!is_close(state1[i], state2[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction cis(theta) {\n    return mathjs__WEBPACK_IMPORTED_MODULE_2__.complex(mathjs__WEBPACK_IMPORTED_MODULE_2__.cos(theta), mathjs__WEBPACK_IMPORTED_MODULE_2__.sin(theta));\n}\n\nlet colormapCache = null;\nasync function loadColormap() {\n    if (!colormapCache) {\n        const response = await fetch('./colormap.json');\n        colormapCache = await response.json();\n    }\n    return colormapCache;\n}\n\nasync function complex_to_rgb(c, ints = false) {\n    const colormap = await loadColormap();  \n    const a = mathjs__WEBPACK_IMPORTED_MODULE_2__.re(c);\n    const b = mathjs__WEBPACK_IMPORTED_MODULE_2__.im(c);\n\n    const magnitude = Math.sqrt(a * a + b * b);\n    let hue = Math.atan2(b, a) / Math.PI * 180;\n\n    if (hue < 0) {\n        hue += 360;\n    }\n\n    const hueIndex = Math.round(hue);\n    const boundedIndex = Math.min(hueIndex, colormap.length - 1);\n\n    const rgb = colormap[boundedIndex];\n\n    if (ints) {\n        return rgb;  \n    } else {\n        return [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255];\n    }\n}\n\nasync function state_table_to_html(state, id, decimals = 4, symbol = '█') {\n    const n = Math.log2(state.length);\n    const roundState = state.map(c => mathjs__WEBPACK_IMPORTED_MODULE_2__.complex(\n        parseFloat(mathjs__WEBPACK_IMPORTED_MODULE_2__.re(c).toFixed(decimals)),\n        parseFloat(mathjs__WEBPACK_IMPORTED_MODULE_2__.im(c).toFixed(decimals))\n    ));\n\n    const maxProbability = Math.max(...roundState.map(c => mathjs__WEBPACK_IMPORTED_MODULE_2__.pow(mathjs__WEBPACK_IMPORTED_MODULE_2__.abs(c), 2)));\n\n    const tableData = await Promise.all(roundState.map(async (c, k) => {\n        const direction = Math.round(Math.atan2(mathjs__WEBPACK_IMPORTED_MODULE_2__.im(c), mathjs__WEBPACK_IMPORTED_MODULE_2__.re(c)) * 180 / Math.PI * 100) / 100;\n        const amplitude = `${(mathjs__WEBPACK_IMPORTED_MODULE_2__.re(c) >= 0 ? ' ' : '-')}${Math.abs(mathjs__WEBPACK_IMPORTED_MODULE_2__.re(c)).toFixed(decimals)} ${\n            mathjs__WEBPACK_IMPORTED_MODULE_2__.im(c) >= 0 ? '+ ' : '- '}i${Math.abs(mathjs__WEBPACK_IMPORTED_MODULE_2__.im(c)).toFixed(decimals)}`;\n\n        const magnitude = mathjs__WEBPACK_IMPORTED_MODULE_2__.abs(c).toFixed(decimals);\n        const directionStr = magnitude > 0\n            ? `${(direction >= 0 ? ' ' : '-')}${Math.floor(Math.abs(direction))}.${(Math.abs(direction) % 1).toFixed(2).substring(2)}°`\n            : '';\n\n        const rgb = await complex_to_rgb(c, true);\n        const probability = mathjs__WEBPACK_IMPORTED_MODULE_2__.pow(mathjs__WEBPACK_IMPORTED_MODULE_2__.abs(c), 2).toFixed(decimals);\n\n        let amplitudeBar = '' ;\n        if (probability > 0) {\n            const normalizedBarLength = Math.round((probability)*20) + 1;\n            console.log(normalizedBarLength);\n            amplitudeBar = `<span style=\"color: rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]}); width: 200px; display: inline-block; overflow: hidden; text-align: left; font-size: 10px;\">${symbol.repeat(Math.max(1, normalizedBarLength))}</span>`;\n        }\n\n        return {\n            outcome: k,\n            binary: k.toString(2).padStart(n, '0'),\n            amplitude: amplitude,\n            magnitude: magnitude,\n            direction: directionStr,\n            amplitudeBar: amplitudeBar,\n            probability: probability,\n        };\n    }));\n\n    let htmlTable = `\n        <style>\n            table {\n                max-width: 100%;\n                border-collapse: collapse;\n                margin: 25px 0;\n                font-size: 0.9em;\n                border-radius: 10px;\n                overflow: hidden;\n                box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);\n            }\n            thead tr {\n                background-color: #3F72AF;\n                color: #ffffff;\n                text-align: left;\n                font-weight: bold;\n            }\n            th, td {\n                padding: 12px 15px;\n                text-align: left; /* Left aligned */\n            }\n            tbody tr {\n                border-bottom: 1px solid #DBE2EF;\n            }\n            tbody tr:nth-of-type(even) {\n                background-color: #F9F7F7;\n            }\n            tbody tr:last-of-type {\n                border-bottom: 2px solid #3F72AF;\n            }\n            tbody tr:hover {\n                background-color: #DBE2EF;\n            }\n        </style>\n\n        <table>\n            <thead>\n                <tr>\n                    <th>Outcome</th>\n                    <th>Binary</th>\n                    <th>Amplitude</th>\n                    <th>Magnitude</th>\n                    <th>Direction</th>\n                    <th>Amplitude Bar</th>\n                    <th>Probability</th>\n                </tr>\n            </thead>\n            <tbody>\n    `;\n\n    tableData.forEach(row => {\n        htmlTable += `\n            <tr>\n                <td>${row.outcome}</td>\n                <td>${row.binary}</td>\n                <td>${row.amplitude}</td>\n                <td>${row.magnitude}</td>\n                <td>${row.direction}</td>\n                <td>${row.amplitudeBar}</td>\n                <td>${row.probability}</td>\n            </tr>\n        `;\n    });\n\n    htmlTable += `\n            </tbody>\n        </table>\n    `;\n\n    document.getElementById(id).innerHTML = htmlTable;\n}\n\n\nasync function grid_state_to_html(state, m = 1, neg = false, showProbs = false, symbol = '\\u2588') {\n    const n = Math.log2(state.length) - m;\n    const cols = 2 ** m;\n    const rows = Math.floor(state.length / cols);\n\n    let htmlTable = `\n        <style>\n            table {\n                max-width: 100%;\n                border-collapse: collapse;\n                margin: 25px 0;\n                font-size: 0.9em;\n                border-radius: 10px;\n                box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);\n                text-align: center;\n            }\n            thead tr {\n                background-color: #3F72AF;\n                color: #ffffff;\n                font-weight: bold;\n            }\n            th, td {\n                padding: 12px 15px;\n                white-space: nowrap; /* Ensure text doesn't wrap */\n                text-overflow: ellipsis; /* Add ellipsis if text is too long */\n            }\n            tbody tr {\n                border-bottom: 1px solid #DBE2EF;\n            }\n            tbody tr:nth-of-type(even) {\n                background-color: #F9F7F7;\n            }\n            tbody tr:last-of-type {\n                border-bottom: 2px solid #3F72AF;\n            }\n            tbody tr:hover {\n                background-color: #DBE2EF;\n            }\n        </style>\n    `;\n\n    htmlTable += '<table><thead><tr><th></th>';\n\n    for (let l = 0; l < cols; l++) {\n        htmlTable += `<th>${l} = ${l.toString(2).padStart(m, '0')}</th>`;\n    }\n    htmlTable += '</tr></thead><tbody>';\n\n    const rangeFunc = neg\n        ? (x) => [...Array(x / 2).keys()].reverse().concat([...Array(x / 2).keys()].map(i => i + x / 2).reverse())\n        : (x) => [...Array(x).keys()].reverse();\n\n    for (let k of rangeFunc(rows)) {\n        const rowLabel = neg\n            ? `${(k < rows / 2 ? k : k - rows)} = ${k.toString(2).padStart(n, '0')}`\n            : `${k} = ${k.toString(2).padStart(n, '0')}`;\n\n        let row = `<tr><td>${rowLabel}</td>`;\n\n        for (let l = 0; l < cols; l++) {\n            const index = k * cols + l;\n            const re = state[index].re !== undefined ? state[index].re : state[index];\n            const im = state[index].im !== undefined ? state[index].im : 0;\n            const magnitude = Math.sqrt(re * re + im * im);\n            const complexValue = mathjs__WEBPACK_IMPORTED_MODULE_2__.complex(re, im);\n            const color = await complex_to_rgb(complexValue, true);\n            const magnitudeForDisplay = Math.floor(magnitude * 10);\n            const probability = showProbs && magnitude > 0.01 ? (magnitude ** 2).toFixed(2) : '';\n\n            row += `<td><font style=\"color: rgb(${color[0]}, ${color[1]}, ${color[2]});\">${symbol.repeat(magnitudeForDisplay)}</font>&nbsp;${probability}</td>`;\n        }\n\n        htmlTable += row + '</tr>';\n    }\n\n    htmlTable += '</tbody></table>';\n\n    return htmlTable;\n}\n\n\n\nfunction circuit_to_string(qc) {\n    const qs = Array.from({ length: qc.regs.reduce((a, b) => a + b, 0) }, (_, i) => ({ id: i }));\n\n    const ops = qc.transformations.map(tr => ({\n        gate: tr.arg === undefined ? tr.name.toUpperCase() : `${tr.name.toUpperCase()}(${Math.round(tr.arg * 100) / 100})`,\n        isControlled: tr.controls.length > 0,\n        controls: tr.controls.map(c => ({ qId: c })),\n        targets: [{ qId: tr.target }]\n    }));\n\n    const circ = { qubits: qs, operations: ops };\n\n    return JSON.stringify(circ).replace(/\"true\"/g, 'true').replace(/\"false\"/g, 'false');\n}\n\nfunction draw_circuit(circuit_string, circuit_div) {\n    circuit_string = JSON.parse(circuit_string);\n    if (circuit_div != null) {\n        _microsoft_quantum_viz_js__WEBPACK_IMPORTED_MODULE_1__.draw(circuit_string, circuit_div, _microsoft_quantum_viz_js__WEBPACK_IMPORTED_MODULE_1__.STYLES['Default'])\n    }\n}\n\nfunction format_value(value, decimals) {\n    const valueString = value.toString();\n    const currentDecimals = valueString.includes('.') ? valueString.split('.')[1].length : 0;\n\n    const roundedDecimals = Math.min(currentDecimals, decimals);\n    return value.toFixed(roundedDecimals);\n}\n\nfunction to_table(state, decimals = 5) {\n    const table = [];\n    for (let k = 0; k < state.length; k++) {\n        const row = []; \n        const value = state[k];\n        row.push(k);\n        row.push(value.toString()); \n        const direction = Math.atan2(value.im, value.re) / (2 * Math.PI) * 360;\n        row.push(format_value(direction, decimals)); \n        const magnitude = Math.sqrt(value.re ** 2 + value.im ** 2);\n        row.push(format_value(magnitude, decimals));\n        const probability = magnitude ** 2;\n        row.push(format_value(probability, decimals)); \n        table.push(row); \n    }\n    return table;\n}\n\nfunction print_state(state, decimals = 5) {\n    const table = to_table(state, decimals);\n    let out = \"\\n\";\n    table.forEach(row => {\n        out += (`[${row.join(', ')}]\\n`);\n    });\n    return out;\n}\n\nfunction squaredMagnitude(c) {\n    return c.real * c.real + c.imag * c.imag;\n}\n\nfunction choices(choicesArr, weights, k) {\n    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);\n    const results = [];\n\n    for (let i = 0; i < k; i++) {\n        let rand = Math.random() * totalWeight;\n        let cumulativeWeight = 0;\n\n        for (let j = 0; j < choicesArr.length; j++) {\n            cumulativeWeight += weights[j];\n            if (rand < cumulativeWeight) {\n                results.push(choicesArr[j]);\n                break;\n            }\n        }\n    }\n\n    return results;\n}\n\n\n\n//# sourceURL=webpack://humejs/./src/lib/utils/common.js?");

/***/ })

}]);