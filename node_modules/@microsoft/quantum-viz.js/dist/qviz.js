(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["qviz"] = factory();
	else
		root["qviz"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 812:
/***/ ((__unused_webpack_module, exports) => {


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConditionalRender = void 0;
/**
 * Conditions on when to render the given operation.
 */
var ConditionalRender;
(function (ConditionalRender) {
    /** Always rendered. */
    ConditionalRender[ConditionalRender["Always"] = 0] = "Always";
    /** Render classically-controlled operation when measurement is a zero. */
    ConditionalRender[ConditionalRender["OnZero"] = 1] = "OnZero";
    /** Render classically-controlled operation when measurement is a one. */
    ConditionalRender[ConditionalRender["OnOne"] = 2] = "OnOne";
    /** Render operation as a group of its nested operations. */
    ConditionalRender[ConditionalRender["AsGroup"] = 3] = "AsGroup";
})(ConditionalRender = exports.ConditionalRender || (exports.ConditionalRender = {}));


/***/ }),

/***/ 242:
/***/ ((__unused_webpack_module, exports) => {


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.regLineStart = exports.argsFontSize = exports.labelFontSize = exports.controlBtnRadius = exports.controlBtnOffset = exports.nestedGroupPadding = exports.groupBoxPadding = exports.classicalRegHeight = exports.registerHeight = exports.labelPadding = exports.gatePadding = exports.gateHeight = exports.minGateWidth = exports.startY = exports.startX = exports.leftPadding = exports.svgNS = void 0;
// SVG Namespace
exports.svgNS = 'http://www.w3.org/2000/svg';
// Display attributes
/** Left padding of SVG. */
exports.leftPadding = 20;
/** x coordinate for first operation on each register. */
exports.startX = 80;
/** y coordinate of first register. */
exports.startY = 40;
/** Minimum width of each gate. */
exports.minGateWidth = 40;
/** Height of each gate. */
exports.gateHeight = 40;
/** Padding on each side of gate. */
exports.gatePadding = 10;
/** Padding on each side of gate label. */
exports.labelPadding = 10;
/** Height between each qubit register. */
exports.registerHeight = exports.gateHeight + exports.gatePadding * 2;
/** Height between classical registers. */
exports.classicalRegHeight = exports.gateHeight;
/** Group box inner padding. */
exports.groupBoxPadding = exports.gatePadding;
/** Padding between nested groups. */
exports.nestedGroupPadding = 2;
/** Additional offset for control button. */
exports.controlBtnOffset = 40;
/** Control button radius. */
exports.controlBtnRadius = 15;
/** Default font size for gate labels. */
exports.labelFontSize = 14;
/** Default font size for gate arguments. */
exports.argsFontSize = 12;
/** Starting x coord for each register wire. */
exports.regLineStart = 40;


/***/ }),

/***/ 993:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dashedBox = exports.dashedLine = exports.arc = exports.text = exports.box = exports.controlDot = exports.circle = exports.line = exports.group = exports.createSvgElement = void 0;
var constants_1 = __webpack_require__(242);
// Helper functions for basic SVG components
/**
 * Create an SVG element.
 *
 * @param type The type of element to be created.
 * @param attributes The attributes that define the element.
 *
 * @returns SVG element.
 */
var createSvgElement = function (type, attributes) {
    if (attributes === void 0) { attributes = {}; }
    var el = document.createElementNS(constants_1.svgNS, type);
    Object.entries(attributes).forEach(function (_a) {
        var attrName = _a[0], attrVal = _a[1];
        return el.setAttribute(attrName, attrVal);
    });
    return el;
};
exports.createSvgElement = createSvgElement;
/**
 * Given an array of SVG elements, group them as an SVG group using the `<g>` tag.
 *
 * @param svgElems   Array of SVG elements.
 * @param attributes Key-value pairs of attributes and they values.
 *
 * @returns SVG element for grouped elements.
 */
var group = function (svgElems, attributes) {
    if (attributes === void 0) { attributes = {}; }
    var el = (0, exports.createSvgElement)('g', attributes);
    svgElems.forEach(function (child) { return el.appendChild(child); });
    return el;
};
exports.group = group;
/**
 * Generate an SVG line.
 *
 * @param x1        x coord of starting point of line.
 * @param y1        y coord of starting point of line.
 * @param x2        x coord of ending point of line.
 * @param y2        y coord fo ending point of line.
 * @param className Class name of element.
 *
 * @returns SVG element for line.
 */
var line = function (x1, y1, x2, y2, className) {
    var attrs = {
        x1: x1.toString(),
        x2: x2.toString(),
        y1: y1.toString(),
        y2: y2.toString(),
    };
    if (className != null)
        attrs['class'] = className;
    return (0, exports.createSvgElement)('line', attrs);
};
exports.line = line;
/**
 * Generate an SVG circle.
 *
 * @param x      x coord of circle.
 * @param y      y coord of circle.
 * @param radius Radius of circle.
 *
 * @returns SVG element for circle.
 */
var circle = function (x, y, radius, className) {
    var attrs = {
        cx: x.toString(),
        cy: y.toString(),
        r: radius.toString(),
    };
    if (className != null)
        attrs['class'] = className;
    return (0, exports.createSvgElement)('circle', attrs);
};
exports.circle = circle;
/**
 * Generate the SVG representation of a control dot used for controlled operations.
 *
 * @param x      x coord of circle.
 * @param y      y coord of circle.
 * @param radius Radius of circle.
 *
 * @returns SVG element for control dot.
 */
var controlDot = function (x, y, radius) {
    if (radius === void 0) { radius = 5; }
    return (0, exports.circle)(x, y, radius, 'control-dot');
};
exports.controlDot = controlDot;
/**
 * Generate the SVG representation of a unitary box that represents an arbitrary unitary operation.
 *
 * @param x         x coord of box.
 * @param y         y coord of box.
 * @param width     Width of box.
 * @param height    Height of box.
 * @param className Class name of element.
 *
 * @returns SVG element for unitary box.
 */
var box = function (x, y, width, height, className) {
    if (className === void 0) { className = 'gate-unitary'; }
    return (0, exports.createSvgElement)('rect', {
        class: className,
        x: x.toString(),
        y: y.toString(),
        width: width.toString(),
        height: height.toString(),
    });
};
exports.box = box;
/**
 * Generate the SVG text element from a given text string.
 *
 * @param text String to render as SVG text.
 * @param x    Middle x coord of text.
 * @param y    Middle y coord of text.
 * @param fs   Font size of text.
 *
 * @returns SVG element for text.
 */
var text = function (text, x, y, fs) {
    if (fs === void 0) { fs = constants_1.labelFontSize; }
    var el = (0, exports.createSvgElement)('text', {
        'font-size': fs.toString(),
        x: x.toString(),
        y: y.toString(),
    });
    el.textContent = text;
    return el;
};
exports.text = text;
/**
 * Generate the SVG representation of the arc used in the measurement box.
 *
 * @param x  x coord of arc.
 * @param y  y coord of arc.
 * @param rx x radius of arc.
 * @param ry y radius of arc.
 *
 * @returns SVG element for arc.
 */
var arc = function (x, y, rx, ry) {
    return (0, exports.createSvgElement)('path', {
        class: 'arc-measure',
        d: "M ".concat(x + 2 * rx, " ").concat(y, " A ").concat(rx, " ").concat(ry, " 0 0 0 ").concat(x, " ").concat(y),
    });
};
exports.arc = arc;
/**
 * Generate a dashed SVG line.
 *
 * @param x1        x coord of starting point of line.
 * @param y1        y coord of starting point of line.
 * @param x2        x coord of ending point of line.
 * @param y2        y coord fo ending point of line.
 * @param className Class name of element.
 *
 * @returns SVG element for dashed line.
 */
var dashedLine = function (x1, y1, x2, y2, className) {
    var el = (0, exports.line)(x1, y1, x2, y2, className);
    el.setAttribute('stroke-dasharray', '8, 8');
    return el;
};
exports.dashedLine = dashedLine;
/**
 * Generate the SVG representation of the dashed box used for enclosing groups of operations controlled on a classical register.
 *
 * @param x         x coord of box.
 * @param y         y coord of box.
 * @param width     Width of box.
 * @param height    Height of box.
 * @param className Class name of element.
 *
 * @returns SVG element for dashed box.
 */
var dashedBox = function (x, y, width, height, className) {
    var el = (0, exports.box)(x, y, width, height, className);
    el.setAttribute('fill-opacity', '0');
    el.setAttribute('stroke-dasharray', '8, 8');
    return el;
};
exports.dashedBox = dashedBox;


/***/ }),

/***/ 805:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._classicalControlled = exports._groupedOperations = exports._controlledGate = exports._swap = exports._unitary = exports._measure = exports._zoomButton = exports._createGate = exports._formatGate = exports.formatGates = void 0;
var metadata_1 = __webpack_require__(316);
var constants_1 = __webpack_require__(242);
var formatUtils_1 = __webpack_require__(993);
/**
 * Given an array of operations (in metadata format), return the SVG representation.
 *
 * @param opsMetadata Array of Metadata representation of operations.
 * @param nestedDepth Depth of nested operations (used in classically controlled and grouped operations).
 *
 * @returns SVG representation of operations.
 */
var formatGates = function (opsMetadata, nestedDepth) {
    if (nestedDepth === void 0) { nestedDepth = 0; }
    var formattedGates = opsMetadata.map(function (metadata) { return _formatGate(metadata, nestedDepth); });
    return (0, formatUtils_1.group)(formattedGates);
};
exports.formatGates = formatGates;
/**
 * Takes in an operation's metadata and formats it into SVG.
 *
 * @param metadata Metadata object representation of gate.
 * @param nestedDepth Depth of nested operations (used in classically controlled and grouped operations).
 *
 * @returns SVG representation of gate.
 */
var _formatGate = function (metadata, nestedDepth) {
    if (nestedDepth === void 0) { nestedDepth = 0; }
    var type = metadata.type, x = metadata.x, controlsY = metadata.controlsY, targetsY = metadata.targetsY, label = metadata.label, displayArgs = metadata.displayArgs, width = metadata.width;
    switch (type) {
        case metadata_1.GateType.Measure:
            return _createGate([_measure(x, controlsY[0])], metadata, nestedDepth);
        case metadata_1.GateType.Unitary:
            return _createGate([_unitary(label, x, targetsY, width, displayArgs)], metadata, nestedDepth);
        case metadata_1.GateType.X:
            return _createGate([_x(metadata, nestedDepth)], metadata, nestedDepth);
        case metadata_1.GateType.Swap:
            return controlsY.length > 0
                ? _controlledGate(metadata, nestedDepth)
                : _createGate([_swap(metadata, nestedDepth)], metadata, nestedDepth);
        case metadata_1.GateType.Cnot:
        case metadata_1.GateType.ControlledUnitary:
            return _controlledGate(metadata, nestedDepth);
        case metadata_1.GateType.Group:
            return _groupedOperations(metadata, nestedDepth);
        case metadata_1.GateType.ClassicalControlled:
            return _classicalControlled(metadata);
        default:
            throw new Error("ERROR: unknown gate (".concat(label, ") of type ").concat(type, "."));
    }
};
exports._formatGate = _formatGate;
/**
 * Groups SVG elements into a gate SVG group.
 *
 * @param svgElems       Array of SVG elements.
 * @param dataAttributes Custom data attributes to be attached to SVG group.
 *
 * @returns SVG representation of a gate.
 */
var _createGate = function (svgElems, metadata, nestedDepth) {
    var dataAttributes = (metadata || {}).dataAttributes;
    var attributes = { class: 'gate' };
    Object.entries(dataAttributes || {}).forEach(function (_a) {
        var attr = _a[0], val = _a[1];
        return (attributes["data-".concat(attr)] = val);
    });
    var zoomBtn = _zoomButton(metadata, nestedDepth);
    if (zoomBtn != null)
        svgElems = svgElems.concat([zoomBtn]);
    return (0, formatUtils_1.group)(svgElems, attributes);
};
exports._createGate = _createGate;
/**
 * Returns the expand/collapse button for an operation if it can be zoomed-in or zoomed-out,
 * respectively. If neither are allowed, return `null`.
 *
 * @param metadata Operation metadata.
 * @param nestedDepth Depth of nested operation.
 *
 * @returns SVG element for expand/collapse button if needed, or null otherwise.
 */
var _zoomButton = function (metadata, nestedDepth) {
    if (metadata == undefined)
        return null;
    var _a = _gatePosition(metadata, nestedDepth), x1 = _a[0], y1 = _a[1];
    var dataAttributes = metadata.dataAttributes;
    dataAttributes = dataAttributes || {};
    var expanded = 'expanded' in dataAttributes;
    var x = x1 + 2;
    var y = y1 + 2;
    var circleBorder = (0, formatUtils_1.circle)(x, y, 10);
    if (expanded) {
        // Create collapse button if expanded
        var minusSign = (0, formatUtils_1.createSvgElement)('path', { d: "M".concat(x - 7, ",").concat(y, " h14") });
        var elements = [circleBorder, minusSign];
        return (0, formatUtils_1.group)(elements, { class: 'gate-control gate-collapse' });
    }
    else if (dataAttributes['zoom-in'] == 'true') {
        // Create expand button if operation can be zoomed in
        var plusSign = (0, formatUtils_1.createSvgElement)('path', { d: "M".concat(x, ",").concat(y - 7, " v14 M").concat(x - 7, ",").concat(y, " h14") });
        var elements = [circleBorder, plusSign];
        return (0, formatUtils_1.group)(elements, { class: 'gate-control gate-expand' });
    }
    return null;
};
exports._zoomButton = _zoomButton;
/**
 * Calculate position of gate.
 *
 * @param metadata Operation metadata.
 * @param nestedDepth Depth of nested operations.
 *
 * @returns Coordinates of gate: [x1, y1, x2, y2].
 */
var _gatePosition = function (metadata, nestedDepth) {
    var x = metadata.x, width = metadata.width, type = metadata.type, targetsY = metadata.targetsY;
    var ys = (targetsY === null || targetsY === void 0 ? void 0 : targetsY.flatMap(function (y) { return y; })) || [];
    var maxY = Math.max.apply(Math, ys);
    var minY = Math.min.apply(Math, ys);
    var x1, y1, x2, y2;
    switch (type) {
        case metadata_1.GateType.Group:
            var padding = constants_1.groupBoxPadding - nestedDepth * constants_1.nestedGroupPadding;
            x1 = x - 2 * padding;
            y1 = minY - constants_1.gateHeight / 2 - padding;
            x2 = width + 2 * padding;
            y2 = maxY + +constants_1.gateHeight / 2 + padding - (minY - constants_1.gateHeight / 2 - padding);
            return [x1, y1, x2, y2];
        default:
            x1 = x - width / 2;
            y1 = minY - constants_1.gateHeight / 2;
            x2 = x + width;
            y2 = maxY + constants_1.gateHeight / 2;
    }
    return [x1, y1, x2, y2];
};
/**
 * Creates a measurement gate at position (x, y).
 *
 * @param x  x coord of measurement gate.
 * @param y  y coord of measurement gate.
 *
 * @returns SVG representation of measurement gate.
 */
var _measure = function (x, y) {
    x -= constants_1.minGateWidth / 2;
    var width = constants_1.minGateWidth, height = constants_1.gateHeight;
    // Draw measurement box
    var mBox = (0, formatUtils_1.box)(x, y - height / 2, width, height, 'gate-measure');
    var mArc = (0, formatUtils_1.arc)(x + 5, y + 2, width / 2 - 5, height / 2 - 8);
    var meter = (0, formatUtils_1.line)(x + width / 2, y + 8, x + width - 8, y - height / 2 + 8);
    return (0, formatUtils_1.group)([mBox, mArc, meter]);
};
exports._measure = _measure;
/**
 * Creates the SVG for a unitary gate on an arbitrary number of qubits.
 *
 * @param label            Gate label.
 * @param x                x coord of gate.
 * @param y                Array of y coords of registers acted upon by gate.
 * @param width            Width of gate.
 * @param displayArgs           Arguments passed in to gate.
 * @param renderDashedLine If true, draw dashed lines between non-adjacent unitaries.
 *
 * @returns SVG representation of unitary gate.
 */
var _unitary = function (label, x, y, width, displayArgs, renderDashedLine) {
    if (renderDashedLine === void 0) { renderDashedLine = true; }
    if (y.length === 0)
        throw new Error("Failed to render unitary gate (".concat(label, "): has no y-values"));
    // Render each group as a separate unitary boxes
    var unitaryBoxes = y.map(function (group) {
        var maxY = group[group.length - 1], minY = group[0];
        var height = maxY - minY + constants_1.gateHeight;
        return _unitaryBox(label, x, minY, width, height, displayArgs);
    });
    // Draw dashed line between disconnected unitaries
    if (renderDashedLine && unitaryBoxes.length > 1) {
        var lastBox = y[y.length - 1];
        var firstBox = y[0];
        var maxY = lastBox[lastBox.length - 1], minY = firstBox[0];
        var vertLine = (0, formatUtils_1.dashedLine)(x, minY, x, maxY);
        return (0, formatUtils_1.group)(__spreadArray([vertLine], unitaryBoxes, true));
    }
    return (0, formatUtils_1.group)(unitaryBoxes);
};
exports._unitary = _unitary;
/**
 * Generates SVG representation of the boxed unitary gate symbol.
 *
 * @param label  Label for unitary operation.
 * @param x      x coord of gate.
 * @param y      y coord of gate.
 * @param width  Width of gate.
 * @param height Height of gate.
 * @param displayArgs Arguments passed in to gate.
 *
 * @returns SVG representation of unitary box.
 */
var _unitaryBox = function (label, x, y, width, height, displayArgs) {
    if (height === void 0) { height = constants_1.gateHeight; }
    y -= constants_1.gateHeight / 2;
    var uBox = (0, formatUtils_1.box)(x - width / 2, y, width, height);
    var labelY = y + height / 2 - (displayArgs == null ? 0 : 7);
    var labelText = (0, formatUtils_1.text)(label, x, labelY);
    var elems = [uBox, labelText];
    if (displayArgs != null) {
        var argStrY = y + height / 2 + 8;
        var argText = (0, formatUtils_1.text)(displayArgs, x, argStrY, constants_1.argsFontSize);
        elems.push(argText);
    }
    return (0, formatUtils_1.group)(elems);
};
/**
 * Creates the SVG for a SWAP gate on y coords given by targetsY.
 *
 * @param x          Centre x coord of SWAP gate.
 * @param targetsY   y coords of target registers.
 *
 * @returns SVG representation of SWAP gate.
 */
var _swap = function (metadata, nestedDepth) {
    var x = metadata.x, targetsY = metadata.targetsY;
    // Get SVGs of crosses
    var _a = _gatePosition(metadata, nestedDepth), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];
    var ys = (targetsY === null || targetsY === void 0 ? void 0 : targetsY.flatMap(function (y) { return y; })) || [];
    var bg = (0, formatUtils_1.box)(x1, y1, x2, y2, 'gate-swap');
    var crosses = ys.map(function (y) { return _cross(x, y); });
    var vertLine = (0, formatUtils_1.line)(x, ys[0], x, ys[1]);
    return (0, formatUtils_1.group)(__spreadArray(__spreadArray([bg], crosses, true), [vertLine], false));
};
exports._swap = _swap;
/**
 * Creates the SVG for an X gate
 *
 * @returns SVG representation of X gate.
 */
var _x = function (metadata, _) {
    var x = metadata.x, targetsY = metadata.targetsY;
    var ys = targetsY.flatMap(function (y) { return y; });
    return _oplus(x, ys[0]);
};
/**
 * Generates cross for display in SWAP gate.
 *
 * @param x x coord of gate.
 * @param y y coord of gate.
 *
 * @returns SVG representation for cross.
 */
var _cross = function (x, y) {
    var radius = 8;
    var line1 = (0, formatUtils_1.line)(x - radius, y - radius, x + radius, y + radius);
    var line2 = (0, formatUtils_1.line)(x - radius, y + radius, x + radius, y - radius);
    return (0, formatUtils_1.group)([line1, line2]);
};
/**
 * Produces the SVG representation of a controlled gate on multiple qubits.
 *
 * @param metadata Metadata of controlled gate.
 *
 * @returns SVG representation of controlled gate.
 */
var _controlledGate = function (metadata, nestedDepth) {
    var targetGateSvgs = [];
    var type = metadata.type, x = metadata.x, controlsY = metadata.controlsY, label = metadata.label, displayArgs = metadata.displayArgs, width = metadata.width;
    var targetsY = metadata.targetsY;
    // Get SVG for target gates
    switch (type) {
        case metadata_1.GateType.Cnot:
            targetsY.forEach(function (y) { return targetGateSvgs.push(_oplus(x, y)); });
            break;
        case metadata_1.GateType.Swap:
            targetsY.forEach(function (y) { return targetGateSvgs.push(_cross(x, y)); });
            break;
        case metadata_1.GateType.ControlledUnitary:
            var groupedTargetsY = targetsY;
            targetGateSvgs.push(_unitary(label, x, groupedTargetsY, width, displayArgs, false));
            targetsY = targetsY.flat();
            break;
        default:
            throw new Error("ERROR: Unrecognized gate: ".concat(label, " of type ").concat(type));
    }
    // Get SVGs for control dots
    var controlledDotsSvg = controlsY.map(function (y) { return (0, formatUtils_1.controlDot)(x, y); });
    // Create control lines
    var maxY = Math.max.apply(Math, __spreadArray(__spreadArray([], controlsY, false), targetsY, false));
    var minY = Math.min.apply(Math, __spreadArray(__spreadArray([], controlsY, false), targetsY, false));
    var vertLine = (0, formatUtils_1.line)(x, minY, x, maxY);
    var svg = _createGate(__spreadArray(__spreadArray([vertLine], controlledDotsSvg, true), targetGateSvgs, true), metadata, nestedDepth);
    return svg;
};
exports._controlledGate = _controlledGate;
/**
 * Generates $\oplus$ symbol for display in CNOT gate.
 *
 * @param x x coordinate of gate.
 * @param y y coordinate of gate.
 * @param r radius of circle.
 *
 * @returns SVG representation of $\oplus$ symbol.
 */
var _oplus = function (x, y, r) {
    if (r === void 0) { r = 15; }
    var circleBorder = (0, formatUtils_1.circle)(x, y, r);
    var vertLine = (0, formatUtils_1.line)(x, y - r, x, y + r);
    var horLine = (0, formatUtils_1.line)(x - r, y, x + r, y);
    return (0, formatUtils_1.group)([circleBorder, vertLine, horLine], { class: 'oplus' });
};
/**
 * Generates the SVG for a group of nested operations.
 *
 * @param metadata Metadata representation of gate.
 * @param nestedDepth Depth of nested operations (used in classically controlled and grouped operations).
 *
 * @returns SVG representation of gate.
 */
var _groupedOperations = function (metadata, nestedDepth) {
    var children = metadata.children;
    var _a = _gatePosition(metadata, nestedDepth), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];
    // Draw dashed box around children gates
    var box = (0, formatUtils_1.dashedBox)(x1, y1, x2, y2);
    var elems = [box];
    if (children != null)
        elems.push(formatGates(children, nestedDepth + 1));
    return _createGate(elems, metadata, nestedDepth);
};
exports._groupedOperations = _groupedOperations;
/**
 * Generates the SVG for a classically controlled group of operations.
 *
 * @param metadata Metadata representation of gate.
 * @param padding  Padding within dashed box.
 *
 * @returns SVG representation of gate.
 */
var _classicalControlled = function (metadata, padding) {
    if (padding === void 0) { padding = constants_1.groupBoxPadding; }
    var controlsY = metadata.controlsY, dataAttributes = metadata.dataAttributes;
    var targetsY = metadata.targetsY;
    var children = metadata.children;
    var x = metadata.x, width = metadata.width;
    var controlY = controlsY[0];
    var elems = [];
    if (children != null) {
        if (children.length !== 2)
            throw new Error("Invalid number of children found for classically-controlled gate: ".concat(children.length));
        // Get SVG for gates controlled on 0
        var childrenZero = formatGates(children[0]);
        childrenZero.setAttribute('class', 'gates-zero');
        elems.push(childrenZero);
        // Get SVG for gates controlled on 1
        var childrenOne = formatGates(children[1]);
        childrenOne.setAttribute('class', 'gates-one');
        elems.push(childrenOne);
    }
    // Draw control button and attached dashed line to dashed box
    var controlCircleX = x + constants_1.controlBtnRadius;
    var controlCircle = _controlCircle(controlCircleX, controlY);
    var lineY1 = controlY + constants_1.controlBtnRadius, lineY2 = controlY + constants_1.classicalRegHeight / 2;
    var vertLine = (0, formatUtils_1.dashedLine)(controlCircleX, lineY1, controlCircleX, lineY2, 'classical-line');
    x += constants_1.controlBtnOffset;
    var horLine = (0, formatUtils_1.dashedLine)(controlCircleX, lineY2, x, lineY2, 'classical-line');
    width = width - constants_1.controlBtnOffset + (padding - constants_1.groupBoxPadding) * 2;
    x += constants_1.groupBoxPadding - padding;
    var y = targetsY[0] - constants_1.gateHeight / 2 - padding;
    var height = targetsY[1] - targetsY[0] + constants_1.gateHeight + padding * 2;
    // Draw dashed box around children gates
    var box = (0, formatUtils_1.dashedBox)(x, y, width, height, 'classical-container');
    elems.push.apply(elems, [horLine, vertLine, controlCircle, box]);
    // Display controlled operation in initial "unknown" state
    var attributes = {
        class: "classically-controlled-group classically-controlled-unknown",
    };
    if (dataAttributes != null)
        Object.entries(dataAttributes).forEach(function (_a) {
            var attr = _a[0], val = _a[1];
            return (attributes["data-".concat(attr)] = val);
        });
    return (0, formatUtils_1.group)(elems, attributes);
};
exports._classicalControlled = _classicalControlled;
/**
 * Generates the SVG representation of the control circle on a classical register with interactivity support
 * for toggling between bit values (unknown, 1, and 0).
 *
 * @param x   x coord.
 * @param y   y coord.
 * @param r   Radius of circle.
 *
 * @returns SVG representation of control circle.
 */
var _controlCircle = function (x, y, r) {
    if (r === void 0) { r = constants_1.controlBtnRadius; }
    return (0, formatUtils_1.group)([(0, formatUtils_1.circle)(x, y, r), (0, formatUtils_1.text)('?', x, y, constants_1.labelFontSize)], { class: 'classically-controlled-btn' });
};


/***/ }),

/***/ 892:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._qubitInput = exports.formatInputs = void 0;
var register_1 = __webpack_require__(557);
var constants_1 = __webpack_require__(242);
var formatUtils_1 = __webpack_require__(993);
/**
 * `formatInputs` takes in an array of Qubits and outputs the SVG string of formatted
 * qubit wires and a mapping from register IDs to register metadata (for rendering).
 *
 * @param qubits List of declared qubits.
 *
 * @returns returns the SVG string of formatted qubit wires, a mapping from registers
 *          to y coord and total SVG height.
 */
var formatInputs = function (qubits) {
    var qubitWires = [];
    var registers = {};
    var currY = constants_1.startY;
    qubits.forEach(function (_a) {
        var id = _a.id, numChildren = _a.numChildren;
        // Add qubit wire to list of qubit wires
        qubitWires.push(_qubitInput(currY));
        // Create qubit register
        registers[id] = { type: register_1.RegisterType.Qubit, y: currY };
        // If there are no attached classical registers, increment y by fixed register height
        if (numChildren == null || numChildren === 0) {
            currY += constants_1.registerHeight;
            return;
        }
        // Increment current height by classical register height for attached classical registers
        currY += constants_1.classicalRegHeight;
        // Add classical wires
        registers[id].children = Array.from(Array(numChildren), function () {
            var clsReg = { type: register_1.RegisterType.Classical, y: currY };
            currY += constants_1.classicalRegHeight;
            return clsReg;
        });
    });
    return {
        qubitWires: (0, formatUtils_1.group)(qubitWires),
        registers: registers,
        svgHeight: currY,
    };
};
exports.formatInputs = formatInputs;
/**
 * Generate the SVG text component for the input qubit register.
 *
 * @param y y coord of input wire to render in SVG.
 *
 * @returns SVG text component for the input register.
 */
var _qubitInput = function (y) {
    var el = (0, formatUtils_1.text)('|0âŸ©', constants_1.leftPadding, y, 16);
    el.setAttribute('text-anchor', 'start');
    el.setAttribute('dominant-baseline', 'middle');
    return el;
};
exports._qubitInput = _qubitInput;


/***/ }),

/***/ 670:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._qubitRegister = exports._classicalRegister = exports.formatRegisters = void 0;
var constants_1 = __webpack_require__(242);
var metadata_1 = __webpack_require__(316);
var formatUtils_1 = __webpack_require__(993);
/**
 * Generate the SVG representation of the qubit register wires in `registers` and the classical wires
 * stemming from each measurement gate.
 *
 * @param registers    Map from register IDs to register metadata.
 * @param measureGates Array of measurement gates metadata.
 * @param endX         End x coord.
 *
 * @returns SVG representation of register wires.
 */
var formatRegisters = function (registers, measureGates, endX) {
    var formattedRegs = [];
    // Render qubit wires
    for (var qId in registers) {
        formattedRegs.push(_qubitRegister(Number(qId), endX, registers[qId].y));
    }
    // Render classical wires
    measureGates.forEach(function (_a) {
        var type = _a.type, x = _a.x, targetsY = _a.targetsY, controlsY = _a.controlsY;
        if (type !== metadata_1.GateType.Measure)
            return;
        var gateY = controlsY[0];
        targetsY.forEach(function (y) {
            formattedRegs.push(_classicalRegister(x, gateY, endX, y));
        });
    });
    return (0, formatUtils_1.group)(formattedRegs);
};
exports.formatRegisters = formatRegisters;
/**
 * Generates the SVG representation of a classical register.
 *
 * @param startX Start x coord.
 * @param gateY  y coord of measurement gate.
 * @param endX   End x coord.
 * @param wireY  y coord of wire.
 *
 * @returns SVG representation of the given classical register.
 */
var _classicalRegister = function (startX, gateY, endX, wireY) {
    var wirePadding = 1;
    // Draw vertical lines
    var vLine1 = (0, formatUtils_1.line)(startX + wirePadding, gateY, startX + wirePadding, wireY - wirePadding, 'register-classical');
    var vLine2 = (0, formatUtils_1.line)(startX - wirePadding, gateY, startX - wirePadding, wireY + wirePadding, 'register-classical');
    // Draw horizontal lines
    var hLine1 = (0, formatUtils_1.line)(startX + wirePadding, wireY - wirePadding, endX, wireY - wirePadding, 'register-classical');
    var hLine2 = (0, formatUtils_1.line)(startX - wirePadding, wireY + wirePadding, endX, wireY + wirePadding, 'register-classical');
    return (0, formatUtils_1.group)([vLine1, vLine2, hLine1, hLine2]);
};
exports._classicalRegister = _classicalRegister;
/**
 * Generates the SVG representation of a qubit register.
 *
 * @param qId         Qubit register index.
 * @param endX        End x coord.
 * @param y           y coord of wire.
 * @param labelOffset y offset for wire label.
 *
 * @returns SVG representation of the given qubit register.
 */
var _qubitRegister = function (qId, endX, y, labelOffset) {
    if (labelOffset === void 0) { labelOffset = 16; }
    var wire = (0, formatUtils_1.line)(constants_1.regLineStart, y, endX, y);
    var label = (0, formatUtils_1.text)("q".concat(qId), constants_1.regLineStart, y - labelOffset);
    label.setAttribute('dominant-baseline', 'hanging');
    label.setAttribute('text-anchor', 'start');
    label.setAttribute('font-size', '75%');
    return (0, formatUtils_1.group)([wire, label]);
};
exports._qubitRegister = _qubitRegister;


/***/ }),

/***/ 316:
/***/ ((__unused_webpack_module, exports) => {


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GateType = void 0;
/**
 * Enum for the various gate operations handled.
 */
var GateType;
(function (GateType) {
    /** Measurement gate. */
    GateType[GateType["Measure"] = 0] = "Measure";
    /** CNOT gate. */
    GateType[GateType["Cnot"] = 1] = "Cnot";
    /** SWAP gate. */
    GateType[GateType["Swap"] = 2] = "Swap";
    /** X gate. */
    GateType[GateType["X"] = 3] = "X";
    /** Single/multi qubit unitary gate. */
    GateType[GateType["Unitary"] = 4] = "Unitary";
    /** Single/multi controlled unitary gate. */
    GateType[GateType["ControlledUnitary"] = 5] = "ControlledUnitary";
    /** Nested group of classically-controlled gates. */
    GateType[GateType["ClassicalControlled"] = 6] = "ClassicalControlled";
    /** Group of nested gates */
    GateType[GateType["Group"] = 7] = "Group";
    /** Invalid gate. */
    GateType[GateType["Invalid"] = 8] = "Invalid";
})(GateType = exports.GateType || (exports.GateType = {}));


/***/ }),

/***/ 323:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._offsetChildrenX = exports._fillMetadataX = exports._splitTargetsY = exports._getRegY = exports._opToMetadata = exports._getClassicalRegStart = exports._alignOps = exports._groupOperations = exports.processOperations = void 0;
var constants_1 = __webpack_require__(242);
var circuit_1 = __webpack_require__(812);
var metadata_1 = __webpack_require__(316);
var register_1 = __webpack_require__(557);
var utils_1 = __webpack_require__(679);
/**
 * Takes in a list of operations and maps them to `metadata` objects which
 * contains information for formatting the corresponding SVG.
 *
 * @param operations Array of operations.
 * @param registers  Mapping from qubit IDs to register metadata.
 *
 * @returns An object containing `metadataList` (Array of Metadata objects) and
 *          `svgWidth` which is the width of the entire SVG.
 */
var processOperations = function (operations, registers) {
    if (operations.length === 0)
        return { metadataList: [], svgWidth: constants_1.startX };
    // Group operations based on registers
    var groupedOps = _groupOperations(operations, registers);
    // Align operations on multiple registers
    var alignedOps = _alignOps(groupedOps);
    // Maintain widths of each column to account for variable-sized gates
    var numColumns = Math.max.apply(Math, __spreadArray([0], alignedOps.map(function (ops) { return ops.length; }), false));
    var columnsWidths = new Array(numColumns).fill(constants_1.minGateWidth);
    // Get classical registers and their starting column index
    var classicalRegs = _getClassicalRegStart(operations, alignedOps);
    // Keep track of which ops are already seen to avoid duplicate rendering
    var visited = {};
    // Map operation index to gate metadata for formatting later
    var opsMetadata = alignedOps.map(function (regOps) {
        return regOps.map(function (opIdx, col) {
            var op = null;
            if (opIdx != null && !visited.hasOwnProperty(opIdx)) {
                op = operations[opIdx];
                visited[opIdx] = true;
            }
            var metadata = _opToMetadata(op, registers);
            if (op != null && [metadata_1.GateType.Unitary, metadata_1.GateType.ControlledUnitary].includes(metadata.type)) {
                // If gate is a unitary type, split targetsY into groups if there
                // is a classical register between them for rendering
                // Get y coordinates of classical registers in the same column as this operation
                var classicalRegY = classicalRegs
                    .filter(function (_a) {
                    var regCol = _a[0], _ = _a[1];
                    return regCol <= col;
                })
                    .map(function (_a) {
                    var _ = _a[0], reg = _a[1];
                    if (reg.cId == null)
                        throw new Error('Could not find cId for classical register.');
                    var children = registers[reg.qId].children;
                    if (children == null)
                        throw new Error("Failed to find classical registers for qubit ID ".concat(reg.qId, "."));
                    return children[reg.cId].y;
                });
                metadata.targetsY = _splitTargetsY(op.targets, classicalRegY, registers);
            }
            // Expand column size, if needed
            if (metadata.width > columnsWidths[col]) {
                columnsWidths[col] = metadata.width;
            }
            return metadata;
        });
    });
    // Fill in x coord of each gate
    var endX = _fillMetadataX(opsMetadata, columnsWidths);
    // Flatten operations and filter out invalid gates
    var metadataList = opsMetadata.flat().filter(function (_a) {
        var type = _a.type;
        return type != metadata_1.GateType.Invalid;
    });
    return { metadataList: metadataList, svgWidth: endX };
};
exports.processOperations = processOperations;
/**
 * Group gates provided by operations into their respective registers.
 *
 * @param operations Array of operations.
 * @param numRegs    Total number of registers.
 *
 * @returns 2D array of indices where `groupedOps[i][j]` is the index of the operations
 *          at register `i` and column `j` (not yet aligned/padded).
 */
var _groupOperations = function (operations, registers) {
    // NOTE: We get the max ID instead of just number of keys because there can be a qubit ID that
    // isn't acted upon and thus does not show up as a key in registers.
    var numRegs = Math.max.apply(Math, __spreadArray([-1], Object.keys(registers).map(Number), false)) + 1;
    var groupedOps = Array.from(Array(numRegs), function () { return new Array(0); });
    operations.forEach(function (_a, instrIdx) {
        var targets = _a.targets, controls = _a.controls;
        var ctrls = controls || [];
        var qRegs = __spreadArray(__spreadArray([], ctrls, true), targets, true).filter(function (_a) {
            var type = _a.type;
            return (type || register_1.RegisterType.Qubit) === register_1.RegisterType.Qubit;
        });
        var qRegIdxList = qRegs.map(function (_a) {
            var qId = _a.qId;
            return qId;
        });
        var clsControls = ctrls.filter(function (_a) {
            var type = _a.type;
            return (type || register_1.RegisterType.Qubit) === register_1.RegisterType.Classical;
        });
        var isClassicallyControlled = clsControls.length > 0;
        if (!isClassicallyControlled && qRegs.length === 0)
            return;
        // If operation is classically-controlled, pad all qubit registers. Otherwise, only pad
        // the contiguous range of registers that it covers.
        var minRegIdx = isClassicallyControlled ? 0 : Math.min.apply(Math, qRegIdxList);
        var maxRegIdx = isClassicallyControlled ? numRegs - 1 : Math.max.apply(Math, qRegIdxList);
        // Add operation also to registers that are in-between target registers
        // so that other gates won't render in the middle.
        for (var i = minRegIdx; i <= maxRegIdx; i++) {
            groupedOps[i].push(instrIdx);
        }
    });
    return groupedOps;
};
exports._groupOperations = _groupOperations;
/**
 * Aligns operations by padding registers with `null`s to make sure that multiqubit
 * gates are in the same column.
 * e.g. ---[x]---[x]--
 *      ----------|---
 *
 * @param ops 2D array of operations. Each row represents a register
 *            and the operations acting on it (in-order).
 *
 * @returns 2D array of aligned operations padded with `null`s.
 */
var _alignOps = function (ops) {
    var maxNumOps = Math.max.apply(Math, __spreadArray([0], ops.map(function (regOps) { return regOps.length; }), false));
    var col = 0;
    // Deep copy ops to be returned as paddedOps
    var paddedOps = JSON.parse(JSON.stringify(ops));
    while (col < maxNumOps) {
        var _loop_1 = function (regIdx) {
            var reg = paddedOps[regIdx];
            if (reg.length <= col)
                return "continue";
            // Should never be null (nulls are only padded to previous columns)
            var opIdx = reg[col];
            // Get position of gate
            var targetsPos = paddedOps.map(function (regOps) { return regOps.indexOf(opIdx); });
            var gatePos = Math.max.apply(Math, __spreadArray([-1], targetsPos, false));
            // If current column is not desired gate position, pad with null
            if (col < gatePos) {
                paddedOps[regIdx].splice(col, 0, null);
                maxNumOps = Math.max(maxNumOps, paddedOps[regIdx].length);
            }
        };
        for (var regIdx = 0; regIdx < paddedOps.length; regIdx++) {
            _loop_1(regIdx);
        }
        col++;
    }
    return paddedOps;
};
exports._alignOps = _alignOps;
/**
 * Retrieves the starting index of each classical register.
 *
 * @param ops     Array of operations.
 * @param idxList 2D array of aligned operation indices.
 *
 * @returns Array of classical register and their starting column indices in the form [[column, register]].
 */
var _getClassicalRegStart = function (ops, idxList) {
    var clsRegs = [];
    idxList.forEach(function (reg) {
        var _loop_2 = function (col) {
            var opIdx = reg[col];
            if (opIdx != null && ops[opIdx].isMeasurement) {
                var targetClsRegs = ops[opIdx].targets.filter(function (reg) { return reg.type === register_1.RegisterType.Classical; });
                targetClsRegs.forEach(function (reg) { return clsRegs.push([col, reg]); });
            }
        };
        for (var col = 0; col < reg.length; col++) {
            _loop_2(col);
        }
    });
    return clsRegs;
};
exports._getClassicalRegStart = _getClassicalRegStart;
/**
 * Maps operation to metadata (e.g. gate type, position, dimensions, text)
 * required to render the image.
 *
 * @param op        Operation to be mapped into metadata format.
 * @param registers Array of registers.
 *
 * @returns Metadata representation of given operation.
 */
var _opToMetadata = function (op, registers) {
    var metadata = {
        type: metadata_1.GateType.Invalid,
        x: 0,
        controlsY: [],
        targetsY: [],
        label: '',
        width: -1,
    };
    if (op == null)
        return metadata;
    var gate = op.gate, dataAttributes = op.dataAttributes, displayArgs = op.displayArgs, isMeasurement = op.isMeasurement, isConditional = op.isConditional, isControlled = op.isControlled, isAdjoint = op.isAdjoint, controls = op.controls, targets = op.targets, children = op.children, conditionalRender = op.conditionalRender;
    // Set y coords
    metadata.controlsY = (controls === null || controls === void 0 ? void 0 : controls.map(function (reg) { return _getRegY(reg, registers); })) || [];
    metadata.targetsY = targets.map(function (reg) { return _getRegY(reg, registers); });
    if (isConditional) {
        // Classically-controlled operations
        if (children == null || children.length == 0)
            throw new Error('No children operations found for classically-controlled operation.');
        // Gates to display when classical bit is 0.
        var onZeroOps = children.filter(function (op) { return op.conditionalRender !== circuit_1.ConditionalRender.OnOne; });
        var childrenInstrs = processOperations(onZeroOps, registers);
        var zeroGates = childrenInstrs.metadataList;
        var zeroChildWidth = childrenInstrs.svgWidth;
        // Gates to display when classical bit is 1.
        var onOneOps = children.filter(function (op) { return op.conditionalRender !== circuit_1.ConditionalRender.OnZero; });
        childrenInstrs = processOperations(onOneOps, registers);
        var oneGates = childrenInstrs.metadataList;
        var oneChildWidth = childrenInstrs.svgWidth;
        // Subtract startX (left-side) and 2*gatePadding (right-side) from nested child gates width
        var width = Math.max(zeroChildWidth, oneChildWidth) - constants_1.startX - constants_1.gatePadding * 2;
        metadata.type = metadata_1.GateType.ClassicalControlled;
        metadata.children = [zeroGates, oneGates];
        // Add additional width from control button and inner box padding for dashed box
        metadata.width = width + constants_1.controlBtnOffset + constants_1.groupBoxPadding * 2;
        // Set targets to first and last quantum registers so we can render the surrounding box
        // around all quantum registers.
        var qubitsY = Object.values(registers).map(function (_a) {
            var y = _a.y;
            return y;
        });
        if (qubitsY.length > 0)
            metadata.targetsY = [Math.min.apply(Math, qubitsY), Math.max.apply(Math, qubitsY)];
    }
    else if (conditionalRender == circuit_1.ConditionalRender.AsGroup && ((children === null || children === void 0 ? void 0 : children.length) || 0) > 0) {
        var childrenInstrs = processOperations(children, registers);
        metadata.type = metadata_1.GateType.Group;
        metadata.children = childrenInstrs.metadataList;
        // _zoomButton function in gateFormatter.ts relies on
        // 'expanded' attribute to render zoom button
        metadata.dataAttributes = { expanded: 'true' };
        // Subtract startX (left-side) and add inner box padding (minus nested gate padding) for dashed box
        metadata.width = childrenInstrs.svgWidth - constants_1.startX + (constants_1.groupBoxPadding - constants_1.gatePadding) * 2;
    }
    else if (isMeasurement) {
        metadata.type = metadata_1.GateType.Measure;
    }
    else if (gate === 'SWAP') {
        metadata.type = metadata_1.GateType.Swap;
    }
    else if (isControlled) {
        metadata.type = gate === 'X' ? metadata_1.GateType.Cnot : metadata_1.GateType.ControlledUnitary;
        metadata.label = gate;
    }
    else if (gate === 'X') {
        metadata.type = metadata_1.GateType.X;
        metadata.label = gate;
    }
    else {
        // Any other gate treated as a simple unitary gate
        metadata.type = metadata_1.GateType.Unitary;
        metadata.label = gate;
    }
    // If adjoint, add ' to the end of gate label
    if (isAdjoint && metadata.label.length > 0)
        metadata.label += "'";
    // If gate has extra arguments, display them
    if (displayArgs != null)
        metadata.displayArgs = displayArgs;
    // Set gate width
    metadata.width = (0, utils_1.getGateWidth)(metadata);
    // Extend existing data attributes with user-provided data attributes
    if (dataAttributes != null)
        metadata.dataAttributes = __assign(__assign({}, metadata.dataAttributes), dataAttributes);
    return metadata;
};
exports._opToMetadata = _opToMetadata;
/**
 * Compute the y coord of a given register.
 *
 * @param reg       Register to compute y coord of.
 * @param registers Map of qubit IDs to RegisterMetadata.
 *
 * @returns The y coord of give register.
 */
var _getRegY = function (reg, registers) {
    var type = reg.type, qId = reg.qId, cId = reg.cId;
    if (!registers.hasOwnProperty(qId))
        throw new Error("ERROR: Qubit register with ID ".concat(qId, " not found."));
    var _a = registers[qId], y = _a.y, children = _a.children;
    switch (type) {
        case undefined:
        case register_1.RegisterType.Qubit:
            return y;
        case register_1.RegisterType.Classical:
            if (children == null)
                throw new Error("ERROR: No classical registers found for qubit ID ".concat(qId, "."));
            if (cId == null)
                throw new Error("ERROR: No ID defined for classical register associated with qubit ID ".concat(qId, "."));
            if (children.length <= cId)
                throw new Error("ERROR: Classical register ID ".concat(cId, " invalid for qubit ID ").concat(qId, " with ").concat(children.length, " classical register(s)."));
            return children[cId].y;
        default:
            throw new Error("ERROR: Unknown register type ".concat(type, "."));
    }
};
exports._getRegY = _getRegY;
/**
 * Splits `targets` if non-adjacent or intersected by classical registers.
 *
 * @param targets       Target qubit registers.
 * @param classicalRegY y coords of classical registers overlapping current column.
 * @param registers     Mapping from register qubit IDs to register metadata.
 *
 * @returns Groups of target qubit y coords.
 */
var _splitTargetsY = function (targets, classicalRegY, registers) {
    if (targets.length === 0)
        return [];
    // Get qIds sorted by ascending y value
    var orderedQIds = Object.keys(registers).map(Number);
    orderedQIds.sort(function (a, b) { return registers[a].y - registers[b].y; });
    var qIdPosition = {};
    orderedQIds.forEach(function (qId, i) { return (qIdPosition[qId] = i); });
    // Sort targets and classicalRegY by ascending y value
    targets = targets.slice();
    targets.sort(function (a, b) {
        var posDiff = qIdPosition[a.qId] - qIdPosition[b.qId];
        if (posDiff === 0 && a.cId != null && b.cId != null)
            return a.cId - b.cId;
        else
            return posDiff;
    });
    classicalRegY = classicalRegY.slice();
    classicalRegY.sort(function (a, b) { return a - b; });
    var prevPos = 0;
    var prevY = 0;
    return targets.reduce(function (groups, target) {
        var y = _getRegY(target, registers);
        var pos = qIdPosition[target.qId];
        // Split into new group if one of the following holds:
        //      1. First target register
        //      2. Non-adjacent qubit registers
        //      3. There is a classical register between current and previous register
        if (groups.length === 0 || pos > prevPos + 1 || (classicalRegY[0] > prevY && classicalRegY[0] < y))
            groups.push([y]);
        else
            groups[groups.length - 1].push(y);
        prevPos = pos;
        prevY = y;
        // Remove classical registers that are higher than current y
        while (classicalRegY.length > 0 && classicalRegY[0] <= y)
            classicalRegY.shift();
        return groups;
    }, []);
};
exports._splitTargetsY = _splitTargetsY;
/**
 * Updates the x coord of each metadata in the given 2D array of metadata and returns rightmost x coord.
 *
 * @param opsMetadata  2D array of metadata.
 * @param columnWidths Array of column widths.
 *
 * @returns Rightmost x coord.
 */
var _fillMetadataX = function (opsMetadata, columnWidths) {
    var currX = constants_1.startX;
    var colStartX = columnWidths.map(function (width) {
        var x = currX;
        currX += width + constants_1.gatePadding * 2;
        return x;
    });
    var endX = currX;
    opsMetadata.forEach(function (regOps) {
        return regOps.forEach(function (metadata, col) {
            var x = colStartX[col];
            switch (metadata.type) {
                case metadata_1.GateType.ClassicalControlled:
                case metadata_1.GateType.Group:
                    // Subtract startX offset from nested gates and add offset and padding
                    var offset = x - constants_1.startX + constants_1.groupBoxPadding;
                    if (metadata.type === metadata_1.GateType.ClassicalControlled)
                        offset += constants_1.controlBtnOffset;
                    // Offset each x coord in children gates
                    _offsetChildrenX(metadata.children, offset);
                    // We don't use the centre x coord because we only care about the rightmost x for
                    // rendering the box around the group of nested gates
                    metadata.x = x;
                    break;
                default:
                    metadata.x = x + columnWidths[col] / 2;
                    break;
            }
        });
    });
    return endX;
};
exports._fillMetadataX = _fillMetadataX;
/**
 * Offset x coords of nested children operations.
 *
 * @param children 2D array of children metadata.
 * @param offset   x coord offset.
 */
var _offsetChildrenX = function (children, offset) {
    if (children == null)
        return;
    children.flat().forEach(function (child) {
        child.x += offset;
        _offsetChildrenX(child.children, offset);
    });
};
exports._offsetChildrenX = _offsetChildrenX;


/***/ }),

/***/ 557:
/***/ ((__unused_webpack_module, exports) => {


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RegisterType = void 0;
/**
 * Type of register.
 */
var RegisterType;
(function (RegisterType) {
    RegisterType[RegisterType["Qubit"] = 0] = "Qubit";
    RegisterType[RegisterType["Classical"] = 1] = "Classical";
})(RegisterType = exports.RegisterType || (exports.RegisterType = {}));


/***/ }),

/***/ 201:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sqore = void 0;
var inputFormatter_1 = __webpack_require__(892);
var gateFormatter_1 = __webpack_require__(805);
var registerFormatter_1 = __webpack_require__(670);
var process_1 = __webpack_require__(323);
var circuit_1 = __webpack_require__(812);
var metadata_1 = __webpack_require__(316);
var styles_1 = __webpack_require__(67);
var utils_1 = __webpack_require__(679);
var constants_1 = __webpack_require__(242);
/**
 * Entrypoint class for rendering circuit visualizations.
 */
var Sqore = /** @class */ (function () {
    /**
     * Initializes Sqore object with custom styles.
     *
     * @param circuit Circuit to be visualized.
     * @param style Custom visualization style.
     */
    function Sqore(circuit, style) {
        if (style === void 0) { style = {}; }
        this.style = {};
        this.gateRegistry = {};
        this.circuit = circuit;
        this.style = this.getStyle(style);
    }
    /**
     * Render circuit into `container` at the specified layer depth.
     *
     * @param container HTML element for rendering visualization into.
     * @param renderDepth Initial layer depth at which to render gates.
     */
    Sqore.prototype.draw = function (container, renderDepth) {
        var _this = this;
        if (renderDepth === void 0) { renderDepth = 0; }
        // Inject into container
        if (container == null)
            throw new Error("Container not provided.");
        // Create copy of circuit to prevent mutation
        var circuit = JSON.parse(JSON.stringify(this.circuit));
        // Assign unique IDs to each operation
        circuit.operations.forEach(function (op, i) { return _this.fillGateRegistry(op, i.toString()); });
        // Render operations at starting at given depth
        circuit.operations = this.selectOpsAtDepth(circuit.operations, renderDepth);
        // If only one top-level operation, expand automatically:
        if (circuit.operations.length == 1 &&
            circuit.operations[0].dataAttributes != null &&
            circuit.operations[0].dataAttributes.hasOwnProperty('id')) {
            var id = circuit.operations[0].dataAttributes['id'];
            this.expandOperation(circuit.operations, id);
        }
        this.renderCircuit(container, circuit);
    };
    /**
     * Retrieve style for visualization.
     *
     * @param style Custom style or style name.
     *
     * @returns Custom style.
     */
    Sqore.prototype.getStyle = function (style) {
        if (style === void 0) { style = {}; }
        if (typeof style === 'string' || style instanceof String) {
            var styleName = style;
            if (!styles_1.STYLES.hasOwnProperty(styleName)) {
                console.error("No style ".concat(styleName, " found in STYLES."));
                return {};
            }
            style = styles_1.STYLES[styleName];
        }
        return style;
    };
    /**
     * Render circuit into `container`.
     *
     * @param container HTML element for rendering visualization into.
     * @param circuit Circuit object to be rendered.
     */
    Sqore.prototype.renderCircuit = function (container, circuit) {
        // Create visualization components
        var composedSqore = this.compose(circuit);
        var svg = this.generateSvg(composedSqore);
        container.innerHTML = '';
        container.appendChild(svg);
        this.addGateClickHandlers(container, circuit);
    };
    /**
     * Generates the components required for visualization.
     *
     * @param circuit Circuit to be visualized.
     *
     * @returns `ComposedSqore` object containing metadata for visualization.
     */
    Sqore.prototype.compose = function (circuit) {
        var add = function (acc, gate) {
            var _a;
            if (Array.isArray(gate)) {
                gate.forEach(function (g) { return add(acc, g); });
            }
            else {
                acc.push(gate);
                (_a = gate.children) === null || _a === void 0 ? void 0 : _a.forEach(function (g) { return add(acc, g); });
            }
        };
        var flatten = function (gates) {
            var result = [];
            add(result, gates);
            return result;
        };
        var qubits = circuit.qubits, operations = circuit.operations;
        var _a = (0, inputFormatter_1.formatInputs)(qubits), qubitWires = _a.qubitWires, registers = _a.registers, svgHeight = _a.svgHeight;
        var _b = (0, process_1.processOperations)(operations, registers), metadataList = _b.metadataList, svgWidth = _b.svgWidth;
        var formattedGates = (0, gateFormatter_1.formatGates)(metadataList);
        var measureGates = flatten(metadataList).filter(function (_a) {
            var type = _a.type;
            return type === metadata_1.GateType.Measure;
        });
        var formattedRegs = (0, registerFormatter_1.formatRegisters)(registers, measureGates, svgWidth);
        var composedSqore = {
            width: svgWidth,
            height: svgHeight,
            elements: [qubitWires, formattedRegs, formattedGates],
        };
        return composedSqore;
    };
    /**
     * Generates visualization of `composedSqore` as an SVG.
     *
     * @param composedSqore ComposedSqore to be visualized.
     *
     * @returns SVG representation of circuit visualization.
     */
    Sqore.prototype.generateSvg = function (composedSqore) {
        var width = composedSqore.width, height = composedSqore.height, elements = composedSqore.elements;
        var uuid = (0, utils_1.createUUID)();
        var svg = document.createElementNS(constants_1.svgNS, 'svg');
        svg.setAttribute('id', uuid);
        svg.setAttribute('class', 'qviz');
        svg.setAttribute('width', width.toString());
        svg.setAttribute('height', height.toString());
        svg.style.setProperty('max-width', 'fit-content');
        // Add styles
        var css = document.createElement('style');
        css.innerHTML = (0, styles_1.style)(this.style);
        svg.appendChild(css);
        // Add body elements
        elements.forEach(function (element) { return svg.appendChild(element); });
        return svg;
    };
    /**
     * Depth-first traversal to assign unique ID to `operation`.
     * The operation is assigned the id `id` and its `i`th child is recursively given
     * the id `${id}-${i}`.
     *
     * @param operation Operation to be assigned.
     * @param id: ID to assign to `operation`.
     *
     */
    Sqore.prototype.fillGateRegistry = function (operation, id) {
        var _this = this;
        var _a;
        if (operation.dataAttributes == null)
            operation.dataAttributes = {};
        operation.dataAttributes['id'] = id;
        // By default, operations cannot be zoomed-out
        operation.dataAttributes['zoom-out'] = 'false';
        this.gateRegistry[id] = operation;
        (_a = operation.children) === null || _a === void 0 ? void 0 : _a.forEach(function (childOp, i) {
            _this.fillGateRegistry(childOp, "".concat(id, "-").concat(i));
            if (childOp.dataAttributes == null)
                childOp.dataAttributes = {};
            // Children operations can be zoomed out
            childOp.dataAttributes['zoom-out'] = 'true';
        });
        // Composite operations can be zoomed in
        operation.dataAttributes['zoom-in'] = (operation.children != null).toString();
    };
    /**
     * Pick out operations that are at or below `renderDepth`.
     *
     * @param operations List of circuit operations.
     * @param renderDepth Initial layer depth at which to render gates.
     *
     * @returns List of operations at or below specifed depth.
     */
    Sqore.prototype.selectOpsAtDepth = function (operations, renderDepth) {
        var _this = this;
        if (renderDepth < 0)
            throw new Error("Invalid renderDepth of ".concat(renderDepth, ". Needs to be >= 0."));
        if (renderDepth === 0)
            return operations;
        return operations
            .map(function (op) { return (op.children != null ? _this.selectOpsAtDepth(op.children, renderDepth - 1) : op); })
            .flat();
    };
    /**
     * Add interactive click handlers to circuit HTML elements.
     *
     * @param container HTML element containing visualized circuit.
     * @param circuit Circuit to be visualized.
     *
     */
    Sqore.prototype.addGateClickHandlers = function (container, circuit) {
        this.addClassicalControlHandlers(container);
        this.addZoomHandlers(container, circuit);
    };
    /**
     * Add interactive click handlers for classically-controlled operations.
     *
     * @param container HTML element containing visualized circuit.
     *
     */
    Sqore.prototype.addClassicalControlHandlers = function (container) {
        container.querySelectorAll('.classically-controlled-btn').forEach(function (btn) {
            // Zoom in on clicked gate
            btn.addEventListener('click', function (evt) {
                var _a;
                var textSvg = btn.querySelector('text');
                var group = btn.parentElement;
                if (textSvg == null || group == null)
                    return;
                var currValue = (_a = textSvg.firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue;
                var zeroGates = group === null || group === void 0 ? void 0 : group.querySelector('.gates-zero');
                var oneGates = group === null || group === void 0 ? void 0 : group.querySelector('.gates-one');
                switch (currValue) {
                    case '?':
                        textSvg.childNodes[0].nodeValue = '1';
                        group.classList.remove('classically-controlled-unknown');
                        group.classList.remove('classically-controlled-zero');
                        group.classList.add('classically-controlled-one');
                        zeroGates === null || zeroGates === void 0 ? void 0 : zeroGates.classList.add('hidden');
                        oneGates === null || oneGates === void 0 ? void 0 : oneGates.classList.remove('hidden');
                        break;
                    case '1':
                        textSvg.childNodes[0].nodeValue = '0';
                        group.classList.remove('classically-controlled-unknown');
                        group.classList.add('classically-controlled-zero');
                        group.classList.remove('classically-controlled-one');
                        zeroGates === null || zeroGates === void 0 ? void 0 : zeroGates.classList.remove('hidden');
                        oneGates === null || oneGates === void 0 ? void 0 : oneGates.classList.add('hidden');
                        break;
                    case '0':
                        textSvg.childNodes[0].nodeValue = '?';
                        group.classList.add('classically-controlled-unknown');
                        group.classList.remove('classically-controlled-zero');
                        group.classList.remove('classically-controlled-one');
                        zeroGates === null || zeroGates === void 0 ? void 0 : zeroGates.classList.remove('hidden');
                        oneGates === null || oneGates === void 0 ? void 0 : oneGates.classList.remove('hidden');
                        break;
                }
                evt.stopPropagation();
            });
        });
    };
    /**
     * Add interactive click handlers for zoom-in/out functionality.
     *
     * @param container HTML element containing visualized circuit.
     * @param circuit Circuit to be visualized.
     *
     */
    Sqore.prototype.addZoomHandlers = function (container, circuit) {
        var _this = this;
        container.querySelectorAll('.gate .gate-control').forEach(function (ctrl) {
            // Zoom in on clicked gate
            ctrl.addEventListener('click', function (ev) {
                var _a;
                var gateId = (_a = ctrl.parentElement) === null || _a === void 0 ? void 0 : _a.getAttribute('data-id');
                if (typeof gateId == 'string') {
                    if (ctrl.classList.contains('gate-collapse')) {
                        _this.collapseOperation(circuit.operations, gateId);
                    }
                    else if (ctrl.classList.contains('gate-expand')) {
                        _this.expandOperation(circuit.operations, gateId);
                    }
                    _this.renderCircuit(container, circuit);
                    ev.stopPropagation();
                }
            });
        });
    };
    /**
     * Expand selected operation for zoom-in interaction.
     *
     * @param operations List of circuit operations.
     * @param id ID of operation to expand.
     *
     */
    Sqore.prototype.expandOperation = function (operations, id) {
        var _this = this;
        operations.forEach(function (op) {
            if (op.conditionalRender === circuit_1.ConditionalRender.AsGroup)
                _this.expandOperation(op.children || [], id);
            if (op.dataAttributes == null)
                return op;
            var opId = op.dataAttributes['id'];
            if (opId === id && op.children != null) {
                op.conditionalRender = circuit_1.ConditionalRender.AsGroup;
                op.dataAttributes['expanded'] = 'true';
            }
        });
    };
    /**
     * Collapse selected operation for zoom-out interaction.
     *
     * @param operations List of circuit operations.
     * @param id ID of operation to collapse.
     *
     */
    Sqore.prototype.collapseOperation = function (operations, parentId) {
        var _this = this;
        operations.forEach(function (op) {
            if (op.conditionalRender === circuit_1.ConditionalRender.AsGroup)
                _this.collapseOperation(op.children || [], parentId);
            if (op.dataAttributes == null)
                return op;
            var opId = op.dataAttributes['id'];
            // Collapse parent gate and its children
            if (opId.startsWith(parentId)) {
                op.conditionalRender = circuit_1.ConditionalRender.Always;
                delete op.dataAttributes['expanded'];
            }
        });
    };
    return Sqore;
}());
exports.Sqore = Sqore;


/***/ }),

/***/ 67:
/***/ (function(__unused_webpack_module, exports) {


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.style = exports.STYLES = void 0;
var defaultStyle = {
    lineStroke: '#000000',
    lineWidth: 1,
    textColour: '#000000',
    unitary: '#D9F1FA',
    oplus: '#FFFFFF',
    measure: '#FFDE86',
    classicalUnknown: '#E5E5E5',
    classicalZero: '#C40000',
    classicalOne: '#4059BD',
    classicalZeroText: '#FFFFFF',
    classicalOneText: '#FFFFFF',
};
var blackAndWhiteStyle = {
    lineStroke: '#000000',
    lineWidth: 1,
    textColour: '#000000',
    unitary: '#FFFFFF',
    oplus: '#FFFFFF',
    measure: '#FFFFFF',
    classicalUnknown: '#FFFFFF',
    classicalZero: '#000000',
    classicalOne: '#000000',
    classicalZeroText: '#FFFFFF',
    classicalOneText: '#FFFFFF',
};
var invertedStyle = {
    lineStroke: '#FFFFFF',
    lineWidth: 1,
    textColour: '#FFFFFF',
    unitary: '#000000',
    oplus: '#000000',
    measure: '#000000',
    classicalUnknown: '#000000',
    classicalZero: '#FFFFFF',
    classicalOne: '#FFFFFF',
    classicalZeroText: '#000000',
    classicalOneText: '#000000',
};
/**
 * Set of default styles.
 */
exports.STYLES = {
    /** Default style with coloured gates. */
    Default: defaultStyle,
    /** Black and white style. */
    BlackAndWhite: blackAndWhiteStyle,
    /** Inverted black and white style (for black backgrounds). */
    Inverted: invertedStyle,
};
/**
 * CSS style script to be injected into visualization SVG.
 *
 * @param customStyle Custom style configuration.
 *
 * @returns String containing CSS style script.
 */
var style = function (customStyle) {
    if (customStyle === void 0) { customStyle = {}; }
    var styleConfig = __assign(__assign({}, defaultStyle), customStyle);
    return "".concat(_defaultGates(styleConfig), "\n    ").concat(_classicallyControlledGates(styleConfig), "\n    ").concat(_expandCollapse);
};
exports.style = style;
var _defaultGates = function (styleConfig) { return "\n    line,\n    circle,\n    rect {\n        stroke: ".concat(styleConfig.lineStroke, ";\n        stroke-width: ").concat(styleConfig.lineWidth, ";\n    }\n    text {\n        fill: ").concat(styleConfig.textColour, ";\n        dominant-baseline: middle;\n        text-anchor: middle;\n        font-family: Arial;\n    }\n    .control-dot {\n        fill: ").concat(styleConfig.lineStroke, ";\n    }\n    .oplus line, .oplus circle {\n        fill: ").concat(styleConfig.oplus, ";\n        stroke-width: 2;\n    }\n    .gate-unitary {\n        fill: ").concat(styleConfig.unitary, ";\n    }\n    .gate-measure {\n        fill: ").concat(styleConfig.measure, ";\n    }\n    rect.gate-swap {\n        fill: transparent;\n        stroke: transparent;\n    }\n    .arc-measure {\n        stroke: ").concat(styleConfig.lineStroke, ";\n        fill: none;\n        stroke-width: ").concat(styleConfig.lineWidth, ";\n    }\n    .register-classical {\n        stroke-width: ").concat((styleConfig.lineWidth || 0) / 2, ";\n    }"); };
var _classicallyControlledGates = function (styleConfig) {
    var gateOutline = "\n    .classically-controlled-one .classical-container,\n    .classically-controlled-one .classical-line {\n        stroke: ".concat(styleConfig.classicalOne, ";\n        stroke-width: ").concat((styleConfig.lineWidth || 0) + 0.3, ";\n        fill: ").concat(styleConfig.classicalOne, ";\n        fill-opacity: 0.1;\n    }\n    .classically-controlled-zero .classical-container,\n    .classically-controlled-zero .classical-line {\n        stroke: ").concat(styleConfig.classicalZero, ";\n        stroke-width: ").concat((styleConfig.lineWidth || 0) + 0.3, ";\n        fill: ").concat(styleConfig.classicalZero, ";\n        fill-opacity: 0.1;\n    }");
    var controlBtn = "\n    .classically-controlled-btn {\n        cursor: pointer;\n    }\n    .classically-controlled-unknown .classically-controlled-btn {\n        fill: ".concat(styleConfig.classicalUnknown, ";\n    }\n    .classically-controlled-one .classically-controlled-btn {\n        fill: ").concat(styleConfig.classicalOne, ";\n    }\n    .classically-controlled-zero .classically-controlled-btn {\n        fill: ").concat(styleConfig.classicalZero, ";\n    }");
    var controlBtnText = "\n    .classically-controlled-btn text {\n        dominant-baseline: middle;\n        text-anchor: middle;\n        stroke: none;\n        font-family: Arial;\n    }\n    .classically-controlled-unknown .classically-controlled-btn text {\n        fill: ".concat(styleConfig.textColour, ";\n    }\n    .classically-controlled-one .classically-controlled-btn text {\n        fill: ").concat(styleConfig.classicalOneText, ";\n    }\n    .classically-controlled-zero .classically-controlled-btn text {\n        fill: ").concat(styleConfig.classicalZeroText, ";\n    }");
    return "\n    .hidden {\n        display: none;\n    }\n    .classically-controlled-unknown {\n        opacity: 0.25;\n    }\n\n    ".concat(gateOutline, "\n    ").concat(controlBtn, "\n    ").concat(controlBtnText);
};
var _expandCollapse = "\n    .qviz .gate-collapse,\n    .qviz .gate-expand {\n        opacity: 0;\n        transition: opacity 1s;\n    }\n\n    .qviz:hover .gate-collapse,\n    .qviz:hover .gate-expand {\n        visibility: visible;\n        opacity: 0.2;\n        transition: visibility 1s;\n        transition: opacity 1s;\n    }\n\n    .gate-expand, .gate-collapse {\n        cursor: pointer;\n    }\n\n    .gate-collapse circle,\n    .gate-expand circle {\n        fill: white;\n        stroke-width: 2px;\n        stroke: black;\n    }\n    .gate-collapse path,\n    .gate-expand path {\n        stroke-width: 4px;\n        stroke: black;\n    }\n\n    .gate:hover > .gate-collapse,\n    .gate:hover > .gate-expand {\n        visibility: visible;\n        opacity: 1;\n        transition: opacity 1s;\n    }";


/***/ }),

/***/ 679:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._getStringWidth = exports.getGateWidth = exports.createUUID = void 0;
var metadata_1 = __webpack_require__(316);
var constants_1 = __webpack_require__(242);
/**
 * Generate a UUID using `Math.random`.
 * Note: this implementation came from https://stackoverflow.com/questions/105034/how-to-create-guid-uuid
 * and is not cryptographically secure but works for our use case.
 *
 * @returns UUID string.
 */
var createUUID = function () {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
};
exports.createUUID = createUUID;
/**
 * Calculate the width of a gate, given its metadata.
 *
 * @param metadata Metadata of a given gate.
 *
 * @returns Width of given gate (in pixels).
 */
var getGateWidth = function (_a) {
    var type = _a.type, label = _a.label, displayArgs = _a.displayArgs, width = _a.width;
    if (width > 0)
        return width;
    switch (type) {
        case metadata_1.GateType.Measure:
        case metadata_1.GateType.Cnot:
        case metadata_1.GateType.Swap:
            return constants_1.minGateWidth;
        default:
            var labelWidth = _getStringWidth(label);
            var argsWidth = displayArgs != null ? _getStringWidth(displayArgs, constants_1.argsFontSize) : 0;
            var textWidth = Math.max(labelWidth, argsWidth) + constants_1.labelPadding * 2;
            return Math.max(constants_1.minGateWidth, textWidth);
    }
};
exports.getGateWidth = getGateWidth;
/**
 * Get the width of a string with font-size `fontSize` and font-family Arial.
 *
 * @param text     Input string.
 * @param fontSize Font size of `text`.
 *
 * @returns Pixel width of given string.
 */
var _getStringWidth = function (text, fontSize) {
    if (fontSize === void 0) { fontSize = constants_1.labelFontSize; }
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    if (context == null)
        throw new Error('Null canvas');
    context.font = "".concat(fontSize, "px Arial");
    var metrics = context.measureText(text);
    return metrics.width;
};
exports._getStringWidth = _getStringWidth;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STYLES = exports.draw = void 0;
var sqore_1 = __webpack_require__(201);
/**
 * Render `circuit` into `container` at the specified layer depth.
 *
 * @param circuit Circuit to be visualized.
 * @param container HTML element for rendering visualization into.
 * @param style Custom visualization style.
 * @param renderDepth Initial layer depth at which to render gates.
 */
var draw = function (circuit, container, style, renderDepth) {
    if (style === void 0) { style = {}; }
    if (renderDepth === void 0) { renderDepth = 0; }
    var sqore = new sqore_1.Sqore(circuit, style);
    sqore.draw(container, renderDepth);
};
exports.draw = draw;
var styles_1 = __webpack_require__(67);
Object.defineProperty(exports, "STYLES", ({ enumerable: true, get: function () { return styles_1.STYLES; } }));

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=qviz.js.map