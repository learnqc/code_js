{"version":3,"file":"qviz.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;ACVa;AACb;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD,yBAAyB,KAAK;;;;;;;;AClBtE;AACb;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,oBAAoB,GAAG,qBAAqB,GAAG,wBAAwB,GAAG,wBAAwB,GAAG,0BAA0B,GAAG,uBAAuB,GAAG,0BAA0B,GAAG,sBAAsB,GAAG,oBAAoB,GAAG,mBAAmB,GAAG,kBAAkB,GAAG,oBAAoB,GAAG,cAAc,GAAG,cAAc,GAAG,mBAAmB,GAAG,aAAa;AACvY;AACA,aAAa;AACb;AACA;AACA,mBAAmB;AACnB;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,oBAAoB;AACpB;AACA,kBAAkB;AAClB;AACA,mBAAmB;AACnB;AACA,oBAAoB;AACpB;AACA,sBAAsB;AACtB;AACA,0BAA0B;AAC1B;AACA,uBAAuB;AACvB;AACA,0BAA0B;AAC1B;AACA,wBAAwB;AACxB;AACA,wBAAwB;AACxB;AACA,qBAAqB;AACrB;AACA,oBAAoB;AACpB;AACA,oBAAoB;;;;;;;;ACvCP;AACb;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,kBAAkB,GAAG,WAAW,GAAG,YAAY,GAAG,WAAW,GAAG,kBAAkB,GAAG,cAAc,GAAG,YAAY,GAAG,aAAa,GAAG,wBAAwB;AACjL,kBAAkB,mBAAO,CAAC,GAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,wCAAwC,+BAA+B;AACvE;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;AC/LJ;AACb;AACA;AACA;AACA,6EAA6E,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B,GAAG,0BAA0B,GAAG,uBAAuB,GAAG,aAAa,GAAG,gBAAgB,GAAG,gBAAgB,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,mBAAmB;AACjO,iBAAiB,mBAAO,CAAC,GAAa;AACtC,kBAAkB,mBAAO,CAAC,GAAc;AACxC,oBAAoB,mBAAO,CAAC,GAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,+DAA+D,4CAA4C;AAC3G;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,uBAAuB;AACvB,uCAAuC;AACvC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,6CAA6C;AACnH;AACA,oDAAoD,qCAAqC;AACzF;AACA;AACA;AACA,qEAAqE,oFAAoF;AACzJ;AACA,oDAAoD,mCAAmC;AACvF;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,WAAW;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,WAAW;AAC7G;AACA,wCAAwC,sBAAsB;AAC9D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2CAA2C;AACvF;AACA;AACA,4CAA4C,2CAA2C;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,6CAA6C;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,2IAA2I,qCAAqC;AAChL;;;;;;;;ACzZa;AACb;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,oBAAoB;AAC1C,iBAAiB,mBAAO,CAAC,GAAa;AACtC,kBAAkB,mBAAO,CAAC,GAAc;AACxC,oBAAoB,mBAAO,CAAC,GAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;AC7DN;AACb;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,0BAA0B,GAAG,uBAAuB;AAC7E,kBAAkB,mBAAO,CAAC,GAAc;AACxC,iBAAiB,mBAAO,CAAC,GAAa;AACtC,oBAAoB,mBAAO,CAAC,GAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;AC7ET;AACb;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC,gBAAgB,KAAK;;;;;;;;AC5B3C;AACb;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,sBAAsB,GAAG,sBAAsB,GAAG,gBAAgB,GAAG,qBAAqB,GAAG,6BAA6B,GAAG,iBAAiB,GAAG,wBAAwB,GAAG,yBAAyB;AAChO,kBAAkB,mBAAO,CAAC,GAAa;AACvC,gBAAgB,mBAAO,CAAC,GAAW;AACnC,iBAAiB,mBAAO,CAAC,GAAY;AACrC,iBAAiB,mBAAO,CAAC,GAAY;AACrC,cAAc,mBAAO,CAAC,GAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,6FAA6F,oBAAoB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,sBAAsB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,uBAAuB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,+BAA+B;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2BAA2B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,wDAAwD;AACvI,uDAAuD,kCAAkC;AACzF;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA,KAAK;AACL;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,kCAAkC;AAC9I,qDAAqD,kCAAkC;AACvF;AACA;AACA;AACA;AACA;AACA,wDAAwD,oEAAoE;AAC5H;AACA;AACA;AACA;AACA,uDAAuD,qEAAqE;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yCAAyC;AAChF;AACA,4CAA4C,gCAAgC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB;;;;;;;;ACzbX;AACb;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C,oBAAoB,KAAK;;;;;;;;ACZvD;AACb;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa;AACb,uBAAuB,mBAAO,CAAC,GAA6B;AAC5D,sBAAsB,mBAAO,CAAC,GAA4B;AAC1D,0BAA0B,mBAAO,CAAC,GAAgC;AAClE,gBAAgB,mBAAO,CAAC,GAAW;AACnC,gBAAgB,mBAAO,CAAC,GAAW;AACnC,iBAAiB,mBAAO,CAAC,GAAY;AACrC,eAAe,mBAAO,CAAC,EAAU;AACjC,cAAc,mBAAO,CAAC,GAAS;AAC/B,kBAAkB,mBAAO,CAAC,GAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,kDAAkD;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,qBAAqB;AACjE;AACA;AACA;AACA,oGAAoG,qBAAqB;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kCAAkC;AAChF;AACA;AACA;AACA;AACA;AACA,iBAAiB,GAAG,GAAG,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2FAA2F;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACD,aAAa;;;;;;;;AC3UA;AACb;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,GAAG,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,0CAA0C;AAC1C;AACA;AACA,aAAa;AACb,6CAA6C,4CAA4C,qDAAqD,2DAA2D,OAAO,YAAY,oDAAoD,oCAAoC,8BAA8B,6BAA6B,OAAO,oBAAoB,oDAAoD,OAAO,kCAAkC,+CAA+C,0BAA0B,OAAO,qBAAqB,iDAAiD,OAAO,qBAAqB,iDAAiD,OAAO,sBAAsB,4BAA4B,8BAA8B,OAAO,oBAAoB,sDAAsD,qBAAqB,2DAA2D,OAAO,2BAA2B,sEAAsE,OAAO;AACjjC;AACA,iIAAiI,uDAAuD,wEAAwE,sDAAsD,4BAA4B,OAAO,4GAA4G,yDAAyD,wEAAwE,uDAAuD,4BAA4B,OAAO;AAChqB,yDAAyD,0BAA0B,OAAO,mEAAmE,yDAAyD,OAAO,+DAA+D,sDAAsD,OAAO,gEAAgE,uDAAuD,OAAO;AACvd,kEAAkE,oCAAoC,8BAA8B,uBAAuB,6BAA6B,OAAO,wEAAwE,mDAAmD,OAAO,oEAAoE,0DAA0D,OAAO,qEAAqE,2DAA2D,OAAO;AAC7kB,2BAA2B,wBAAwB,OAAO,uCAAuC,wBAAwB,OAAO;AAChI;AACA,4EAA4E,qBAAqB,iCAAiC,OAAO,mEAAmE,8BAA8B,uBAAuB,oCAAoC,iCAAiC,OAAO,sCAAsC,0BAA0B,OAAO,yDAAyD,sBAAsB,4BAA4B,wBAAwB,OAAO,mDAAmD,4BAA4B,wBAAwB,OAAO,uEAAuE,8BAA8B,qBAAqB,iCAAiC,OAAO;;;;;;;;ACtFjyB;AACb;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,oBAAoB,GAAG,kBAAkB;AACnE,iBAAiB,mBAAO,CAAC,GAAY;AACrC,kBAAkB,mBAAO,CAAC,GAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;;;;;;;UC/DvB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;ACtBa;AACb;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,GAAG,YAAY;AAC7B,cAAc,mBAAO,CAAC,GAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,kCAAkC;AAClC;AACA;AACA;AACA,YAAY;AACZ,eAAe,mBAAO,CAAC,EAAU;AACjC,0CAAyC,EAAE,qCAAqC,2BAA2B,EAAC","sources":["webpack://qviz/webpack/universalModuleDefinition","webpack://qviz/./src/circuit.ts","webpack://qviz/./src/constants.ts","webpack://qviz/./src/formatters/formatUtils.ts","webpack://qviz/./src/formatters/gateFormatter.ts","webpack://qviz/./src/formatters/inputFormatter.ts","webpack://qviz/./src/formatters/registerFormatter.ts","webpack://qviz/./src/metadata.ts","webpack://qviz/./src/process.ts","webpack://qviz/./src/register.ts","webpack://qviz/./src/sqore.ts","webpack://qviz/./src/styles.ts","webpack://qviz/./src/utils.ts","webpack://qviz/webpack/bootstrap","webpack://qviz/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"qviz\"] = factory();\n\telse\n\t\troot[\"qviz\"] = factory();\n})(self, () => {\nreturn ","\"use strict\";\r\n// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT license.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ConditionalRender = void 0;\r\n/**\r\n * Conditions on when to render the given operation.\r\n */\r\nvar ConditionalRender;\r\n(function (ConditionalRender) {\r\n    /** Always rendered. */\r\n    ConditionalRender[ConditionalRender[\"Always\"] = 0] = \"Always\";\r\n    /** Render classically-controlled operation when measurement is a zero. */\r\n    ConditionalRender[ConditionalRender[\"OnZero\"] = 1] = \"OnZero\";\r\n    /** Render classically-controlled operation when measurement is a one. */\r\n    ConditionalRender[ConditionalRender[\"OnOne\"] = 2] = \"OnOne\";\r\n    /** Render operation as a group of its nested operations. */\r\n    ConditionalRender[ConditionalRender[\"AsGroup\"] = 3] = \"AsGroup\";\r\n})(ConditionalRender = exports.ConditionalRender || (exports.ConditionalRender = {}));\r\n","\"use strict\";\r\n// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT license.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.regLineStart = exports.argsFontSize = exports.labelFontSize = exports.controlBtnRadius = exports.controlBtnOffset = exports.nestedGroupPadding = exports.groupBoxPadding = exports.classicalRegHeight = exports.registerHeight = exports.labelPadding = exports.gatePadding = exports.gateHeight = exports.minGateWidth = exports.startY = exports.startX = exports.leftPadding = exports.svgNS = void 0;\r\n// SVG Namespace\r\nexports.svgNS = 'http://www.w3.org/2000/svg';\r\n// Display attributes\r\n/** Left padding of SVG. */\r\nexports.leftPadding = 20;\r\n/** x coordinate for first operation on each register. */\r\nexports.startX = 80;\r\n/** y coordinate of first register. */\r\nexports.startY = 40;\r\n/** Minimum width of each gate. */\r\nexports.minGateWidth = 40;\r\n/** Height of each gate. */\r\nexports.gateHeight = 40;\r\n/** Padding on each side of gate. */\r\nexports.gatePadding = 10;\r\n/** Padding on each side of gate label. */\r\nexports.labelPadding = 10;\r\n/** Height between each qubit register. */\r\nexports.registerHeight = exports.gateHeight + exports.gatePadding * 2;\r\n/** Height between classical registers. */\r\nexports.classicalRegHeight = exports.gateHeight;\r\n/** Group box inner padding. */\r\nexports.groupBoxPadding = exports.gatePadding;\r\n/** Padding between nested groups. */\r\nexports.nestedGroupPadding = 2;\r\n/** Additional offset for control button. */\r\nexports.controlBtnOffset = 40;\r\n/** Control button radius. */\r\nexports.controlBtnRadius = 15;\r\n/** Default font size for gate labels. */\r\nexports.labelFontSize = 14;\r\n/** Default font size for gate arguments. */\r\nexports.argsFontSize = 12;\r\n/** Starting x coord for each register wire. */\r\nexports.regLineStart = 40;\r\n","\"use strict\";\r\n// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT license.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.dashedBox = exports.dashedLine = exports.arc = exports.text = exports.box = exports.controlDot = exports.circle = exports.line = exports.group = exports.createSvgElement = void 0;\r\nvar constants_1 = require(\"../constants\");\r\n// Helper functions for basic SVG components\r\n/**\r\n * Create an SVG element.\r\n *\r\n * @param type The type of element to be created.\r\n * @param attributes The attributes that define the element.\r\n *\r\n * @returns SVG element.\r\n */\r\nvar createSvgElement = function (type, attributes) {\r\n    if (attributes === void 0) { attributes = {}; }\r\n    var el = document.createElementNS(constants_1.svgNS, type);\r\n    Object.entries(attributes).forEach(function (_a) {\r\n        var attrName = _a[0], attrVal = _a[1];\r\n        return el.setAttribute(attrName, attrVal);\r\n    });\r\n    return el;\r\n};\r\nexports.createSvgElement = createSvgElement;\r\n/**\r\n * Given an array of SVG elements, group them as an SVG group using the `<g>` tag.\r\n *\r\n * @param svgElems   Array of SVG elements.\r\n * @param attributes Key-value pairs of attributes and they values.\r\n *\r\n * @returns SVG element for grouped elements.\r\n */\r\nvar group = function (svgElems, attributes) {\r\n    if (attributes === void 0) { attributes = {}; }\r\n    var el = (0, exports.createSvgElement)('g', attributes);\r\n    svgElems.forEach(function (child) { return el.appendChild(child); });\r\n    return el;\r\n};\r\nexports.group = group;\r\n/**\r\n * Generate an SVG line.\r\n *\r\n * @param x1        x coord of starting point of line.\r\n * @param y1        y coord of starting point of line.\r\n * @param x2        x coord of ending point of line.\r\n * @param y2        y coord fo ending point of line.\r\n * @param className Class name of element.\r\n *\r\n * @returns SVG element for line.\r\n */\r\nvar line = function (x1, y1, x2, y2, className) {\r\n    var attrs = {\r\n        x1: x1.toString(),\r\n        x2: x2.toString(),\r\n        y1: y1.toString(),\r\n        y2: y2.toString(),\r\n    };\r\n    if (className != null)\r\n        attrs['class'] = className;\r\n    return (0, exports.createSvgElement)('line', attrs);\r\n};\r\nexports.line = line;\r\n/**\r\n * Generate an SVG circle.\r\n *\r\n * @param x      x coord of circle.\r\n * @param y      y coord of circle.\r\n * @param radius Radius of circle.\r\n *\r\n * @returns SVG element for circle.\r\n */\r\nvar circle = function (x, y, radius, className) {\r\n    var attrs = {\r\n        cx: x.toString(),\r\n        cy: y.toString(),\r\n        r: radius.toString(),\r\n    };\r\n    if (className != null)\r\n        attrs['class'] = className;\r\n    return (0, exports.createSvgElement)('circle', attrs);\r\n};\r\nexports.circle = circle;\r\n/**\r\n * Generate the SVG representation of a control dot used for controlled operations.\r\n *\r\n * @param x      x coord of circle.\r\n * @param y      y coord of circle.\r\n * @param radius Radius of circle.\r\n *\r\n * @returns SVG element for control dot.\r\n */\r\nvar controlDot = function (x, y, radius) {\r\n    if (radius === void 0) { radius = 5; }\r\n    return (0, exports.circle)(x, y, radius, 'control-dot');\r\n};\r\nexports.controlDot = controlDot;\r\n/**\r\n * Generate the SVG representation of a unitary box that represents an arbitrary unitary operation.\r\n *\r\n * @param x         x coord of box.\r\n * @param y         y coord of box.\r\n * @param width     Width of box.\r\n * @param height    Height of box.\r\n * @param className Class name of element.\r\n *\r\n * @returns SVG element for unitary box.\r\n */\r\nvar box = function (x, y, width, height, className) {\r\n    if (className === void 0) { className = 'gate-unitary'; }\r\n    return (0, exports.createSvgElement)('rect', {\r\n        class: className,\r\n        x: x.toString(),\r\n        y: y.toString(),\r\n        width: width.toString(),\r\n        height: height.toString(),\r\n    });\r\n};\r\nexports.box = box;\r\n/**\r\n * Generate the SVG text element from a given text string.\r\n *\r\n * @param text String to render as SVG text.\r\n * @param x    Middle x coord of text.\r\n * @param y    Middle y coord of text.\r\n * @param fs   Font size of text.\r\n *\r\n * @returns SVG element for text.\r\n */\r\nvar text = function (text, x, y, fs) {\r\n    if (fs === void 0) { fs = constants_1.labelFontSize; }\r\n    var el = (0, exports.createSvgElement)('text', {\r\n        'font-size': fs.toString(),\r\n        x: x.toString(),\r\n        y: y.toString(),\r\n    });\r\n    el.textContent = text;\r\n    return el;\r\n};\r\nexports.text = text;\r\n/**\r\n * Generate the SVG representation of the arc used in the measurement box.\r\n *\r\n * @param x  x coord of arc.\r\n * @param y  y coord of arc.\r\n * @param rx x radius of arc.\r\n * @param ry y radius of arc.\r\n *\r\n * @returns SVG element for arc.\r\n */\r\nvar arc = function (x, y, rx, ry) {\r\n    return (0, exports.createSvgElement)('path', {\r\n        class: 'arc-measure',\r\n        d: \"M \".concat(x + 2 * rx, \" \").concat(y, \" A \").concat(rx, \" \").concat(ry, \" 0 0 0 \").concat(x, \" \").concat(y),\r\n    });\r\n};\r\nexports.arc = arc;\r\n/**\r\n * Generate a dashed SVG line.\r\n *\r\n * @param x1        x coord of starting point of line.\r\n * @param y1        y coord of starting point of line.\r\n * @param x2        x coord of ending point of line.\r\n * @param y2        y coord fo ending point of line.\r\n * @param className Class name of element.\r\n *\r\n * @returns SVG element for dashed line.\r\n */\r\nvar dashedLine = function (x1, y1, x2, y2, className) {\r\n    var el = (0, exports.line)(x1, y1, x2, y2, className);\r\n    el.setAttribute('stroke-dasharray', '8, 8');\r\n    return el;\r\n};\r\nexports.dashedLine = dashedLine;\r\n/**\r\n * Generate the SVG representation of the dashed box used for enclosing groups of operations controlled on a classical register.\r\n *\r\n * @param x         x coord of box.\r\n * @param y         y coord of box.\r\n * @param width     Width of box.\r\n * @param height    Height of box.\r\n * @param className Class name of element.\r\n *\r\n * @returns SVG element for dashed box.\r\n */\r\nvar dashedBox = function (x, y, width, height, className) {\r\n    var el = (0, exports.box)(x, y, width, height, className);\r\n    el.setAttribute('fill-opacity', '0');\r\n    el.setAttribute('stroke-dasharray', '8, 8');\r\n    return el;\r\n};\r\nexports.dashedBox = dashedBox;\r\n","\"use strict\";\r\n// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT license.\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports._classicalControlled = exports._groupedOperations = exports._controlledGate = exports._swap = exports._unitary = exports._measure = exports._zoomButton = exports._createGate = exports._formatGate = exports.formatGates = void 0;\r\nvar metadata_1 = require(\"../metadata\");\r\nvar constants_1 = require(\"../constants\");\r\nvar formatUtils_1 = require(\"./formatUtils\");\r\n/**\r\n * Given an array of operations (in metadata format), return the SVG representation.\r\n *\r\n * @param opsMetadata Array of Metadata representation of operations.\r\n * @param nestedDepth Depth of nested operations (used in classically controlled and grouped operations).\r\n *\r\n * @returns SVG representation of operations.\r\n */\r\nvar formatGates = function (opsMetadata, nestedDepth) {\r\n    if (nestedDepth === void 0) { nestedDepth = 0; }\r\n    var formattedGates = opsMetadata.map(function (metadata) { return _formatGate(metadata, nestedDepth); });\r\n    return (0, formatUtils_1.group)(formattedGates);\r\n};\r\nexports.formatGates = formatGates;\r\n/**\r\n * Takes in an operation's metadata and formats it into SVG.\r\n *\r\n * @param metadata Metadata object representation of gate.\r\n * @param nestedDepth Depth of nested operations (used in classically controlled and grouped operations).\r\n *\r\n * @returns SVG representation of gate.\r\n */\r\nvar _formatGate = function (metadata, nestedDepth) {\r\n    if (nestedDepth === void 0) { nestedDepth = 0; }\r\n    var type = metadata.type, x = metadata.x, controlsY = metadata.controlsY, targetsY = metadata.targetsY, label = metadata.label, displayArgs = metadata.displayArgs, width = metadata.width;\r\n    switch (type) {\r\n        case metadata_1.GateType.Measure:\r\n            return _createGate([_measure(x, controlsY[0])], metadata, nestedDepth);\r\n        case metadata_1.GateType.Unitary:\r\n            return _createGate([_unitary(label, x, targetsY, width, displayArgs)], metadata, nestedDepth);\r\n        case metadata_1.GateType.X:\r\n            return _createGate([_x(metadata, nestedDepth)], metadata, nestedDepth);\r\n        case metadata_1.GateType.Swap:\r\n            return controlsY.length > 0\r\n                ? _controlledGate(metadata, nestedDepth)\r\n                : _createGate([_swap(metadata, nestedDepth)], metadata, nestedDepth);\r\n        case metadata_1.GateType.Cnot:\r\n        case metadata_1.GateType.ControlledUnitary:\r\n            return _controlledGate(metadata, nestedDepth);\r\n        case metadata_1.GateType.Group:\r\n            return _groupedOperations(metadata, nestedDepth);\r\n        case metadata_1.GateType.ClassicalControlled:\r\n            return _classicalControlled(metadata);\r\n        default:\r\n            throw new Error(\"ERROR: unknown gate (\".concat(label, \") of type \").concat(type, \".\"));\r\n    }\r\n};\r\nexports._formatGate = _formatGate;\r\n/**\r\n * Groups SVG elements into a gate SVG group.\r\n *\r\n * @param svgElems       Array of SVG elements.\r\n * @param dataAttributes Custom data attributes to be attached to SVG group.\r\n *\r\n * @returns SVG representation of a gate.\r\n */\r\nvar _createGate = function (svgElems, metadata, nestedDepth) {\r\n    var dataAttributes = (metadata || {}).dataAttributes;\r\n    var attributes = { class: 'gate' };\r\n    Object.entries(dataAttributes || {}).forEach(function (_a) {\r\n        var attr = _a[0], val = _a[1];\r\n        return (attributes[\"data-\".concat(attr)] = val);\r\n    });\r\n    var zoomBtn = _zoomButton(metadata, nestedDepth);\r\n    if (zoomBtn != null)\r\n        svgElems = svgElems.concat([zoomBtn]);\r\n    return (0, formatUtils_1.group)(svgElems, attributes);\r\n};\r\nexports._createGate = _createGate;\r\n/**\r\n * Returns the expand/collapse button for an operation if it can be zoomed-in or zoomed-out,\r\n * respectively. If neither are allowed, return `null`.\r\n *\r\n * @param metadata Operation metadata.\r\n * @param nestedDepth Depth of nested operation.\r\n *\r\n * @returns SVG element for expand/collapse button if needed, or null otherwise.\r\n */\r\nvar _zoomButton = function (metadata, nestedDepth) {\r\n    if (metadata == undefined)\r\n        return null;\r\n    var _a = _gatePosition(metadata, nestedDepth), x1 = _a[0], y1 = _a[1];\r\n    var dataAttributes = metadata.dataAttributes;\r\n    dataAttributes = dataAttributes || {};\r\n    var expanded = 'expanded' in dataAttributes;\r\n    var x = x1 + 2;\r\n    var y = y1 + 2;\r\n    var circleBorder = (0, formatUtils_1.circle)(x, y, 10);\r\n    if (expanded) {\r\n        // Create collapse button if expanded\r\n        var minusSign = (0, formatUtils_1.createSvgElement)('path', { d: \"M\".concat(x - 7, \",\").concat(y, \" h14\") });\r\n        var elements = [circleBorder, minusSign];\r\n        return (0, formatUtils_1.group)(elements, { class: 'gate-control gate-collapse' });\r\n    }\r\n    else if (dataAttributes['zoom-in'] == 'true') {\r\n        // Create expand button if operation can be zoomed in\r\n        var plusSign = (0, formatUtils_1.createSvgElement)('path', { d: \"M\".concat(x, \",\").concat(y - 7, \" v14 M\").concat(x - 7, \",\").concat(y, \" h14\") });\r\n        var elements = [circleBorder, plusSign];\r\n        return (0, formatUtils_1.group)(elements, { class: 'gate-control gate-expand' });\r\n    }\r\n    return null;\r\n};\r\nexports._zoomButton = _zoomButton;\r\n/**\r\n * Calculate position of gate.\r\n *\r\n * @param metadata Operation metadata.\r\n * @param nestedDepth Depth of nested operations.\r\n *\r\n * @returns Coordinates of gate: [x1, y1, x2, y2].\r\n */\r\nvar _gatePosition = function (metadata, nestedDepth) {\r\n    var x = metadata.x, width = metadata.width, type = metadata.type, targetsY = metadata.targetsY;\r\n    var ys = (targetsY === null || targetsY === void 0 ? void 0 : targetsY.flatMap(function (y) { return y; })) || [];\r\n    var maxY = Math.max.apply(Math, ys);\r\n    var minY = Math.min.apply(Math, ys);\r\n    var x1, y1, x2, y2;\r\n    switch (type) {\r\n        case metadata_1.GateType.Group:\r\n            var padding = constants_1.groupBoxPadding - nestedDepth * constants_1.nestedGroupPadding;\r\n            x1 = x - 2 * padding;\r\n            y1 = minY - constants_1.gateHeight / 2 - padding;\r\n            x2 = width + 2 * padding;\r\n            y2 = maxY + +constants_1.gateHeight / 2 + padding - (minY - constants_1.gateHeight / 2 - padding);\r\n            return [x1, y1, x2, y2];\r\n        default:\r\n            x1 = x - width / 2;\r\n            y1 = minY - constants_1.gateHeight / 2;\r\n            x2 = x + width;\r\n            y2 = maxY + constants_1.gateHeight / 2;\r\n    }\r\n    return [x1, y1, x2, y2];\r\n};\r\n/**\r\n * Creates a measurement gate at position (x, y).\r\n *\r\n * @param x  x coord of measurement gate.\r\n * @param y  y coord of measurement gate.\r\n *\r\n * @returns SVG representation of measurement gate.\r\n */\r\nvar _measure = function (x, y) {\r\n    x -= constants_1.minGateWidth / 2;\r\n    var width = constants_1.minGateWidth, height = constants_1.gateHeight;\r\n    // Draw measurement box\r\n    var mBox = (0, formatUtils_1.box)(x, y - height / 2, width, height, 'gate-measure');\r\n    var mArc = (0, formatUtils_1.arc)(x + 5, y + 2, width / 2 - 5, height / 2 - 8);\r\n    var meter = (0, formatUtils_1.line)(x + width / 2, y + 8, x + width - 8, y - height / 2 + 8);\r\n    return (0, formatUtils_1.group)([mBox, mArc, meter]);\r\n};\r\nexports._measure = _measure;\r\n/**\r\n * Creates the SVG for a unitary gate on an arbitrary number of qubits.\r\n *\r\n * @param label            Gate label.\r\n * @param x                x coord of gate.\r\n * @param y                Array of y coords of registers acted upon by gate.\r\n * @param width            Width of gate.\r\n * @param displayArgs           Arguments passed in to gate.\r\n * @param renderDashedLine If true, draw dashed lines between non-adjacent unitaries.\r\n *\r\n * @returns SVG representation of unitary gate.\r\n */\r\nvar _unitary = function (label, x, y, width, displayArgs, renderDashedLine) {\r\n    if (renderDashedLine === void 0) { renderDashedLine = true; }\r\n    if (y.length === 0)\r\n        throw new Error(\"Failed to render unitary gate (\".concat(label, \"): has no y-values\"));\r\n    // Render each group as a separate unitary boxes\r\n    var unitaryBoxes = y.map(function (group) {\r\n        var maxY = group[group.length - 1], minY = group[0];\r\n        var height = maxY - minY + constants_1.gateHeight;\r\n        return _unitaryBox(label, x, minY, width, height, displayArgs);\r\n    });\r\n    // Draw dashed line between disconnected unitaries\r\n    if (renderDashedLine && unitaryBoxes.length > 1) {\r\n        var lastBox = y[y.length - 1];\r\n        var firstBox = y[0];\r\n        var maxY = lastBox[lastBox.length - 1], minY = firstBox[0];\r\n        var vertLine = (0, formatUtils_1.dashedLine)(x, minY, x, maxY);\r\n        return (0, formatUtils_1.group)(__spreadArray([vertLine], unitaryBoxes, true));\r\n    }\r\n    return (0, formatUtils_1.group)(unitaryBoxes);\r\n};\r\nexports._unitary = _unitary;\r\n/**\r\n * Generates SVG representation of the boxed unitary gate symbol.\r\n *\r\n * @param label  Label for unitary operation.\r\n * @param x      x coord of gate.\r\n * @param y      y coord of gate.\r\n * @param width  Width of gate.\r\n * @param height Height of gate.\r\n * @param displayArgs Arguments passed in to gate.\r\n *\r\n * @returns SVG representation of unitary box.\r\n */\r\nvar _unitaryBox = function (label, x, y, width, height, displayArgs) {\r\n    if (height === void 0) { height = constants_1.gateHeight; }\r\n    y -= constants_1.gateHeight / 2;\r\n    var uBox = (0, formatUtils_1.box)(x - width / 2, y, width, height);\r\n    var labelY = y + height / 2 - (displayArgs == null ? 0 : 7);\r\n    var labelText = (0, formatUtils_1.text)(label, x, labelY);\r\n    var elems = [uBox, labelText];\r\n    if (displayArgs != null) {\r\n        var argStrY = y + height / 2 + 8;\r\n        var argText = (0, formatUtils_1.text)(displayArgs, x, argStrY, constants_1.argsFontSize);\r\n        elems.push(argText);\r\n    }\r\n    return (0, formatUtils_1.group)(elems);\r\n};\r\n/**\r\n * Creates the SVG for a SWAP gate on y coords given by targetsY.\r\n *\r\n * @param x          Centre x coord of SWAP gate.\r\n * @param targetsY   y coords of target registers.\r\n *\r\n * @returns SVG representation of SWAP gate.\r\n */\r\nvar _swap = function (metadata, nestedDepth) {\r\n    var x = metadata.x, targetsY = metadata.targetsY;\r\n    // Get SVGs of crosses\r\n    var _a = _gatePosition(metadata, nestedDepth), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];\r\n    var ys = (targetsY === null || targetsY === void 0 ? void 0 : targetsY.flatMap(function (y) { return y; })) || [];\r\n    var bg = (0, formatUtils_1.box)(x1, y1, x2, y2, 'gate-swap');\r\n    var crosses = ys.map(function (y) { return _cross(x, y); });\r\n    var vertLine = (0, formatUtils_1.line)(x, ys[0], x, ys[1]);\r\n    return (0, formatUtils_1.group)(__spreadArray(__spreadArray([bg], crosses, true), [vertLine], false));\r\n};\r\nexports._swap = _swap;\r\n/**\r\n * Creates the SVG for an X gate\r\n *\r\n * @returns SVG representation of X gate.\r\n */\r\nvar _x = function (metadata, _) {\r\n    var x = metadata.x, targetsY = metadata.targetsY;\r\n    var ys = targetsY.flatMap(function (y) { return y; });\r\n    return _oplus(x, ys[0]);\r\n};\r\n/**\r\n * Generates cross for display in SWAP gate.\r\n *\r\n * @param x x coord of gate.\r\n * @param y y coord of gate.\r\n *\r\n * @returns SVG representation for cross.\r\n */\r\nvar _cross = function (x, y) {\r\n    var radius = 8;\r\n    var line1 = (0, formatUtils_1.line)(x - radius, y - radius, x + radius, y + radius);\r\n    var line2 = (0, formatUtils_1.line)(x - radius, y + radius, x + radius, y - radius);\r\n    return (0, formatUtils_1.group)([line1, line2]);\r\n};\r\n/**\r\n * Produces the SVG representation of a controlled gate on multiple qubits.\r\n *\r\n * @param metadata Metadata of controlled gate.\r\n *\r\n * @returns SVG representation of controlled gate.\r\n */\r\nvar _controlledGate = function (metadata, nestedDepth) {\r\n    var targetGateSvgs = [];\r\n    var type = metadata.type, x = metadata.x, controlsY = metadata.controlsY, label = metadata.label, displayArgs = metadata.displayArgs, width = metadata.width;\r\n    var targetsY = metadata.targetsY;\r\n    // Get SVG for target gates\r\n    switch (type) {\r\n        case metadata_1.GateType.Cnot:\r\n            targetsY.forEach(function (y) { return targetGateSvgs.push(_oplus(x, y)); });\r\n            break;\r\n        case metadata_1.GateType.Swap:\r\n            targetsY.forEach(function (y) { return targetGateSvgs.push(_cross(x, y)); });\r\n            break;\r\n        case metadata_1.GateType.ControlledUnitary:\r\n            var groupedTargetsY = targetsY;\r\n            targetGateSvgs.push(_unitary(label, x, groupedTargetsY, width, displayArgs, false));\r\n            targetsY = targetsY.flat();\r\n            break;\r\n        default:\r\n            throw new Error(\"ERROR: Unrecognized gate: \".concat(label, \" of type \").concat(type));\r\n    }\r\n    // Get SVGs for control dots\r\n    var controlledDotsSvg = controlsY.map(function (y) { return (0, formatUtils_1.controlDot)(x, y); });\r\n    // Create control lines\r\n    var maxY = Math.max.apply(Math, __spreadArray(__spreadArray([], controlsY, false), targetsY, false));\r\n    var minY = Math.min.apply(Math, __spreadArray(__spreadArray([], controlsY, false), targetsY, false));\r\n    var vertLine = (0, formatUtils_1.line)(x, minY, x, maxY);\r\n    var svg = _createGate(__spreadArray(__spreadArray([vertLine], controlledDotsSvg, true), targetGateSvgs, true), metadata, nestedDepth);\r\n    return svg;\r\n};\r\nexports._controlledGate = _controlledGate;\r\n/**\r\n * Generates $\\oplus$ symbol for display in CNOT gate.\r\n *\r\n * @param x x coordinate of gate.\r\n * @param y y coordinate of gate.\r\n * @param r radius of circle.\r\n *\r\n * @returns SVG representation of $\\oplus$ symbol.\r\n */\r\nvar _oplus = function (x, y, r) {\r\n    if (r === void 0) { r = 15; }\r\n    var circleBorder = (0, formatUtils_1.circle)(x, y, r);\r\n    var vertLine = (0, formatUtils_1.line)(x, y - r, x, y + r);\r\n    var horLine = (0, formatUtils_1.line)(x - r, y, x + r, y);\r\n    return (0, formatUtils_1.group)([circleBorder, vertLine, horLine], { class: 'oplus' });\r\n};\r\n/**\r\n * Generates the SVG for a group of nested operations.\r\n *\r\n * @param metadata Metadata representation of gate.\r\n * @param nestedDepth Depth of nested operations (used in classically controlled and grouped operations).\r\n *\r\n * @returns SVG representation of gate.\r\n */\r\nvar _groupedOperations = function (metadata, nestedDepth) {\r\n    var children = metadata.children;\r\n    var _a = _gatePosition(metadata, nestedDepth), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];\r\n    // Draw dashed box around children gates\r\n    var box = (0, formatUtils_1.dashedBox)(x1, y1, x2, y2);\r\n    var elems = [box];\r\n    if (children != null)\r\n        elems.push(formatGates(children, nestedDepth + 1));\r\n    return _createGate(elems, metadata, nestedDepth);\r\n};\r\nexports._groupedOperations = _groupedOperations;\r\n/**\r\n * Generates the SVG for a classically controlled group of operations.\r\n *\r\n * @param metadata Metadata representation of gate.\r\n * @param padding  Padding within dashed box.\r\n *\r\n * @returns SVG representation of gate.\r\n */\r\nvar _classicalControlled = function (metadata, padding) {\r\n    if (padding === void 0) { padding = constants_1.groupBoxPadding; }\r\n    var controlsY = metadata.controlsY, dataAttributes = metadata.dataAttributes;\r\n    var targetsY = metadata.targetsY;\r\n    var children = metadata.children;\r\n    var x = metadata.x, width = metadata.width;\r\n    var controlY = controlsY[0];\r\n    var elems = [];\r\n    if (children != null) {\r\n        if (children.length !== 2)\r\n            throw new Error(\"Invalid number of children found for classically-controlled gate: \".concat(children.length));\r\n        // Get SVG for gates controlled on 0\r\n        var childrenZero = formatGates(children[0]);\r\n        childrenZero.setAttribute('class', 'gates-zero');\r\n        elems.push(childrenZero);\r\n        // Get SVG for gates controlled on 1\r\n        var childrenOne = formatGates(children[1]);\r\n        childrenOne.setAttribute('class', 'gates-one');\r\n        elems.push(childrenOne);\r\n    }\r\n    // Draw control button and attached dashed line to dashed box\r\n    var controlCircleX = x + constants_1.controlBtnRadius;\r\n    var controlCircle = _controlCircle(controlCircleX, controlY);\r\n    var lineY1 = controlY + constants_1.controlBtnRadius, lineY2 = controlY + constants_1.classicalRegHeight / 2;\r\n    var vertLine = (0, formatUtils_1.dashedLine)(controlCircleX, lineY1, controlCircleX, lineY2, 'classical-line');\r\n    x += constants_1.controlBtnOffset;\r\n    var horLine = (0, formatUtils_1.dashedLine)(controlCircleX, lineY2, x, lineY2, 'classical-line');\r\n    width = width - constants_1.controlBtnOffset + (padding - constants_1.groupBoxPadding) * 2;\r\n    x += constants_1.groupBoxPadding - padding;\r\n    var y = targetsY[0] - constants_1.gateHeight / 2 - padding;\r\n    var height = targetsY[1] - targetsY[0] + constants_1.gateHeight + padding * 2;\r\n    // Draw dashed box around children gates\r\n    var box = (0, formatUtils_1.dashedBox)(x, y, width, height, 'classical-container');\r\n    elems.push.apply(elems, [horLine, vertLine, controlCircle, box]);\r\n    // Display controlled operation in initial \"unknown\" state\r\n    var attributes = {\r\n        class: \"classically-controlled-group classically-controlled-unknown\",\r\n    };\r\n    if (dataAttributes != null)\r\n        Object.entries(dataAttributes).forEach(function (_a) {\r\n            var attr = _a[0], val = _a[1];\r\n            return (attributes[\"data-\".concat(attr)] = val);\r\n        });\r\n    return (0, formatUtils_1.group)(elems, attributes);\r\n};\r\nexports._classicalControlled = _classicalControlled;\r\n/**\r\n * Generates the SVG representation of the control circle on a classical register with interactivity support\r\n * for toggling between bit values (unknown, 1, and 0).\r\n *\r\n * @param x   x coord.\r\n * @param y   y coord.\r\n * @param r   Radius of circle.\r\n *\r\n * @returns SVG representation of control circle.\r\n */\r\nvar _controlCircle = function (x, y, r) {\r\n    if (r === void 0) { r = constants_1.controlBtnRadius; }\r\n    return (0, formatUtils_1.group)([(0, formatUtils_1.circle)(x, y, r), (0, formatUtils_1.text)('?', x, y, constants_1.labelFontSize)], { class: 'classically-controlled-btn' });\r\n};\r\n","\"use strict\";\r\n// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT license.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports._qubitInput = exports.formatInputs = void 0;\r\nvar register_1 = require(\"../register\");\r\nvar constants_1 = require(\"../constants\");\r\nvar formatUtils_1 = require(\"./formatUtils\");\r\n/**\r\n * `formatInputs` takes in an array of Qubits and outputs the SVG string of formatted\r\n * qubit wires and a mapping from register IDs to register metadata (for rendering).\r\n *\r\n * @param qubits List of declared qubits.\r\n *\r\n * @returns returns the SVG string of formatted qubit wires, a mapping from registers\r\n *          to y coord and total SVG height.\r\n */\r\nvar formatInputs = function (qubits) {\r\n    var qubitWires = [];\r\n    var registers = {};\r\n    var currY = constants_1.startY;\r\n    qubits.forEach(function (_a) {\r\n        var id = _a.id, numChildren = _a.numChildren;\r\n        // Add qubit wire to list of qubit wires\r\n        qubitWires.push(_qubitInput(currY));\r\n        // Create qubit register\r\n        registers[id] = { type: register_1.RegisterType.Qubit, y: currY };\r\n        // If there are no attached classical registers, increment y by fixed register height\r\n        if (numChildren == null || numChildren === 0) {\r\n            currY += constants_1.registerHeight;\r\n            return;\r\n        }\r\n        // Increment current height by classical register height for attached classical registers\r\n        currY += constants_1.classicalRegHeight;\r\n        // Add classical wires\r\n        registers[id].children = Array.from(Array(numChildren), function () {\r\n            var clsReg = { type: register_1.RegisterType.Classical, y: currY };\r\n            currY += constants_1.classicalRegHeight;\r\n            return clsReg;\r\n        });\r\n    });\r\n    return {\r\n        qubitWires: (0, formatUtils_1.group)(qubitWires),\r\n        registers: registers,\r\n        svgHeight: currY,\r\n    };\r\n};\r\nexports.formatInputs = formatInputs;\r\n/**\r\n * Generate the SVG text component for the input qubit register.\r\n *\r\n * @param y y coord of input wire to render in SVG.\r\n *\r\n * @returns SVG text component for the input register.\r\n */\r\nvar _qubitInput = function (y) {\r\n    var el = (0, formatUtils_1.text)('|0⟩', constants_1.leftPadding, y, 16);\r\n    el.setAttribute('text-anchor', 'start');\r\n    el.setAttribute('dominant-baseline', 'middle');\r\n    return el;\r\n};\r\nexports._qubitInput = _qubitInput;\r\n","\"use strict\";\r\n// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT license.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports._qubitRegister = exports._classicalRegister = exports.formatRegisters = void 0;\r\nvar constants_1 = require(\"../constants\");\r\nvar metadata_1 = require(\"../metadata\");\r\nvar formatUtils_1 = require(\"./formatUtils\");\r\n/**\r\n * Generate the SVG representation of the qubit register wires in `registers` and the classical wires\r\n * stemming from each measurement gate.\r\n *\r\n * @param registers    Map from register IDs to register metadata.\r\n * @param measureGates Array of measurement gates metadata.\r\n * @param endX         End x coord.\r\n *\r\n * @returns SVG representation of register wires.\r\n */\r\nvar formatRegisters = function (registers, measureGates, endX) {\r\n    var formattedRegs = [];\r\n    // Render qubit wires\r\n    for (var qId in registers) {\r\n        formattedRegs.push(_qubitRegister(Number(qId), endX, registers[qId].y));\r\n    }\r\n    // Render classical wires\r\n    measureGates.forEach(function (_a) {\r\n        var type = _a.type, x = _a.x, targetsY = _a.targetsY, controlsY = _a.controlsY;\r\n        if (type !== metadata_1.GateType.Measure)\r\n            return;\r\n        var gateY = controlsY[0];\r\n        targetsY.forEach(function (y) {\r\n            formattedRegs.push(_classicalRegister(x, gateY, endX, y));\r\n        });\r\n    });\r\n    return (0, formatUtils_1.group)(formattedRegs);\r\n};\r\nexports.formatRegisters = formatRegisters;\r\n/**\r\n * Generates the SVG representation of a classical register.\r\n *\r\n * @param startX Start x coord.\r\n * @param gateY  y coord of measurement gate.\r\n * @param endX   End x coord.\r\n * @param wireY  y coord of wire.\r\n *\r\n * @returns SVG representation of the given classical register.\r\n */\r\nvar _classicalRegister = function (startX, gateY, endX, wireY) {\r\n    var wirePadding = 1;\r\n    // Draw vertical lines\r\n    var vLine1 = (0, formatUtils_1.line)(startX + wirePadding, gateY, startX + wirePadding, wireY - wirePadding, 'register-classical');\r\n    var vLine2 = (0, formatUtils_1.line)(startX - wirePadding, gateY, startX - wirePadding, wireY + wirePadding, 'register-classical');\r\n    // Draw horizontal lines\r\n    var hLine1 = (0, formatUtils_1.line)(startX + wirePadding, wireY - wirePadding, endX, wireY - wirePadding, 'register-classical');\r\n    var hLine2 = (0, formatUtils_1.line)(startX - wirePadding, wireY + wirePadding, endX, wireY + wirePadding, 'register-classical');\r\n    return (0, formatUtils_1.group)([vLine1, vLine2, hLine1, hLine2]);\r\n};\r\nexports._classicalRegister = _classicalRegister;\r\n/**\r\n * Generates the SVG representation of a qubit register.\r\n *\r\n * @param qId         Qubit register index.\r\n * @param endX        End x coord.\r\n * @param y           y coord of wire.\r\n * @param labelOffset y offset for wire label.\r\n *\r\n * @returns SVG representation of the given qubit register.\r\n */\r\nvar _qubitRegister = function (qId, endX, y, labelOffset) {\r\n    if (labelOffset === void 0) { labelOffset = 16; }\r\n    var wire = (0, formatUtils_1.line)(constants_1.regLineStart, y, endX, y);\r\n    var label = (0, formatUtils_1.text)(\"q\".concat(qId), constants_1.regLineStart, y - labelOffset);\r\n    label.setAttribute('dominant-baseline', 'hanging');\r\n    label.setAttribute('text-anchor', 'start');\r\n    label.setAttribute('font-size', '75%');\r\n    return (0, formatUtils_1.group)([wire, label]);\r\n};\r\nexports._qubitRegister = _qubitRegister;\r\n","\"use strict\";\r\n// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT license.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GateType = void 0;\r\n/**\r\n * Enum for the various gate operations handled.\r\n */\r\nvar GateType;\r\n(function (GateType) {\r\n    /** Measurement gate. */\r\n    GateType[GateType[\"Measure\"] = 0] = \"Measure\";\r\n    /** CNOT gate. */\r\n    GateType[GateType[\"Cnot\"] = 1] = \"Cnot\";\r\n    /** SWAP gate. */\r\n    GateType[GateType[\"Swap\"] = 2] = \"Swap\";\r\n    /** X gate. */\r\n    GateType[GateType[\"X\"] = 3] = \"X\";\r\n    /** Single/multi qubit unitary gate. */\r\n    GateType[GateType[\"Unitary\"] = 4] = \"Unitary\";\r\n    /** Single/multi controlled unitary gate. */\r\n    GateType[GateType[\"ControlledUnitary\"] = 5] = \"ControlledUnitary\";\r\n    /** Nested group of classically-controlled gates. */\r\n    GateType[GateType[\"ClassicalControlled\"] = 6] = \"ClassicalControlled\";\r\n    /** Group of nested gates */\r\n    GateType[GateType[\"Group\"] = 7] = \"Group\";\r\n    /** Invalid gate. */\r\n    GateType[GateType[\"Invalid\"] = 8] = \"Invalid\";\r\n})(GateType = exports.GateType || (exports.GateType = {}));\r\n","\"use strict\";\r\n// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT license.\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports._offsetChildrenX = exports._fillMetadataX = exports._splitTargetsY = exports._getRegY = exports._opToMetadata = exports._getClassicalRegStart = exports._alignOps = exports._groupOperations = exports.processOperations = void 0;\r\nvar constants_1 = require(\"./constants\");\r\nvar circuit_1 = require(\"./circuit\");\r\nvar metadata_1 = require(\"./metadata\");\r\nvar register_1 = require(\"./register\");\r\nvar utils_1 = require(\"./utils\");\r\n/**\r\n * Takes in a list of operations and maps them to `metadata` objects which\r\n * contains information for formatting the corresponding SVG.\r\n *\r\n * @param operations Array of operations.\r\n * @param registers  Mapping from qubit IDs to register metadata.\r\n *\r\n * @returns An object containing `metadataList` (Array of Metadata objects) and\r\n *          `svgWidth` which is the width of the entire SVG.\r\n */\r\nvar processOperations = function (operations, registers) {\r\n    if (operations.length === 0)\r\n        return { metadataList: [], svgWidth: constants_1.startX };\r\n    // Group operations based on registers\r\n    var groupedOps = _groupOperations(operations, registers);\r\n    // Align operations on multiple registers\r\n    var alignedOps = _alignOps(groupedOps);\r\n    // Maintain widths of each column to account for variable-sized gates\r\n    var numColumns = Math.max.apply(Math, __spreadArray([0], alignedOps.map(function (ops) { return ops.length; }), false));\r\n    var columnsWidths = new Array(numColumns).fill(constants_1.minGateWidth);\r\n    // Get classical registers and their starting column index\r\n    var classicalRegs = _getClassicalRegStart(operations, alignedOps);\r\n    // Keep track of which ops are already seen to avoid duplicate rendering\r\n    var visited = {};\r\n    // Map operation index to gate metadata for formatting later\r\n    var opsMetadata = alignedOps.map(function (regOps) {\r\n        return regOps.map(function (opIdx, col) {\r\n            var op = null;\r\n            if (opIdx != null && !visited.hasOwnProperty(opIdx)) {\r\n                op = operations[opIdx];\r\n                visited[opIdx] = true;\r\n            }\r\n            var metadata = _opToMetadata(op, registers);\r\n            if (op != null && [metadata_1.GateType.Unitary, metadata_1.GateType.ControlledUnitary].includes(metadata.type)) {\r\n                // If gate is a unitary type, split targetsY into groups if there\r\n                // is a classical register between them for rendering\r\n                // Get y coordinates of classical registers in the same column as this operation\r\n                var classicalRegY = classicalRegs\r\n                    .filter(function (_a) {\r\n                    var regCol = _a[0], _ = _a[1];\r\n                    return regCol <= col;\r\n                })\r\n                    .map(function (_a) {\r\n                    var _ = _a[0], reg = _a[1];\r\n                    if (reg.cId == null)\r\n                        throw new Error('Could not find cId for classical register.');\r\n                    var children = registers[reg.qId].children;\r\n                    if (children == null)\r\n                        throw new Error(\"Failed to find classical registers for qubit ID \".concat(reg.qId, \".\"));\r\n                    return children[reg.cId].y;\r\n                });\r\n                metadata.targetsY = _splitTargetsY(op.targets, classicalRegY, registers);\r\n            }\r\n            // Expand column size, if needed\r\n            if (metadata.width > columnsWidths[col]) {\r\n                columnsWidths[col] = metadata.width;\r\n            }\r\n            return metadata;\r\n        });\r\n    });\r\n    // Fill in x coord of each gate\r\n    var endX = _fillMetadataX(opsMetadata, columnsWidths);\r\n    // Flatten operations and filter out invalid gates\r\n    var metadataList = opsMetadata.flat().filter(function (_a) {\r\n        var type = _a.type;\r\n        return type != metadata_1.GateType.Invalid;\r\n    });\r\n    return { metadataList: metadataList, svgWidth: endX };\r\n};\r\nexports.processOperations = processOperations;\r\n/**\r\n * Group gates provided by operations into their respective registers.\r\n *\r\n * @param operations Array of operations.\r\n * @param numRegs    Total number of registers.\r\n *\r\n * @returns 2D array of indices where `groupedOps[i][j]` is the index of the operations\r\n *          at register `i` and column `j` (not yet aligned/padded).\r\n */\r\nvar _groupOperations = function (operations, registers) {\r\n    // NOTE: We get the max ID instead of just number of keys because there can be a qubit ID that\r\n    // isn't acted upon and thus does not show up as a key in registers.\r\n    var numRegs = Math.max.apply(Math, __spreadArray([-1], Object.keys(registers).map(Number), false)) + 1;\r\n    var groupedOps = Array.from(Array(numRegs), function () { return new Array(0); });\r\n    operations.forEach(function (_a, instrIdx) {\r\n        var targets = _a.targets, controls = _a.controls;\r\n        var ctrls = controls || [];\r\n        var qRegs = __spreadArray(__spreadArray([], ctrls, true), targets, true).filter(function (_a) {\r\n            var type = _a.type;\r\n            return (type || register_1.RegisterType.Qubit) === register_1.RegisterType.Qubit;\r\n        });\r\n        var qRegIdxList = qRegs.map(function (_a) {\r\n            var qId = _a.qId;\r\n            return qId;\r\n        });\r\n        var clsControls = ctrls.filter(function (_a) {\r\n            var type = _a.type;\r\n            return (type || register_1.RegisterType.Qubit) === register_1.RegisterType.Classical;\r\n        });\r\n        var isClassicallyControlled = clsControls.length > 0;\r\n        if (!isClassicallyControlled && qRegs.length === 0)\r\n            return;\r\n        // If operation is classically-controlled, pad all qubit registers. Otherwise, only pad\r\n        // the contiguous range of registers that it covers.\r\n        var minRegIdx = isClassicallyControlled ? 0 : Math.min.apply(Math, qRegIdxList);\r\n        var maxRegIdx = isClassicallyControlled ? numRegs - 1 : Math.max.apply(Math, qRegIdxList);\r\n        // Add operation also to registers that are in-between target registers\r\n        // so that other gates won't render in the middle.\r\n        for (var i = minRegIdx; i <= maxRegIdx; i++) {\r\n            groupedOps[i].push(instrIdx);\r\n        }\r\n    });\r\n    return groupedOps;\r\n};\r\nexports._groupOperations = _groupOperations;\r\n/**\r\n * Aligns operations by padding registers with `null`s to make sure that multiqubit\r\n * gates are in the same column.\r\n * e.g. ---[x]---[x]--\r\n *      ----------|---\r\n *\r\n * @param ops 2D array of operations. Each row represents a register\r\n *            and the operations acting on it (in-order).\r\n *\r\n * @returns 2D array of aligned operations padded with `null`s.\r\n */\r\nvar _alignOps = function (ops) {\r\n    var maxNumOps = Math.max.apply(Math, __spreadArray([0], ops.map(function (regOps) { return regOps.length; }), false));\r\n    var col = 0;\r\n    // Deep copy ops to be returned as paddedOps\r\n    var paddedOps = JSON.parse(JSON.stringify(ops));\r\n    while (col < maxNumOps) {\r\n        var _loop_1 = function (regIdx) {\r\n            var reg = paddedOps[regIdx];\r\n            if (reg.length <= col)\r\n                return \"continue\";\r\n            // Should never be null (nulls are only padded to previous columns)\r\n            var opIdx = reg[col];\r\n            // Get position of gate\r\n            var targetsPos = paddedOps.map(function (regOps) { return regOps.indexOf(opIdx); });\r\n            var gatePos = Math.max.apply(Math, __spreadArray([-1], targetsPos, false));\r\n            // If current column is not desired gate position, pad with null\r\n            if (col < gatePos) {\r\n                paddedOps[regIdx].splice(col, 0, null);\r\n                maxNumOps = Math.max(maxNumOps, paddedOps[regIdx].length);\r\n            }\r\n        };\r\n        for (var regIdx = 0; regIdx < paddedOps.length; regIdx++) {\r\n            _loop_1(regIdx);\r\n        }\r\n        col++;\r\n    }\r\n    return paddedOps;\r\n};\r\nexports._alignOps = _alignOps;\r\n/**\r\n * Retrieves the starting index of each classical register.\r\n *\r\n * @param ops     Array of operations.\r\n * @param idxList 2D array of aligned operation indices.\r\n *\r\n * @returns Array of classical register and their starting column indices in the form [[column, register]].\r\n */\r\nvar _getClassicalRegStart = function (ops, idxList) {\r\n    var clsRegs = [];\r\n    idxList.forEach(function (reg) {\r\n        var _loop_2 = function (col) {\r\n            var opIdx = reg[col];\r\n            if (opIdx != null && ops[opIdx].isMeasurement) {\r\n                var targetClsRegs = ops[opIdx].targets.filter(function (reg) { return reg.type === register_1.RegisterType.Classical; });\r\n                targetClsRegs.forEach(function (reg) { return clsRegs.push([col, reg]); });\r\n            }\r\n        };\r\n        for (var col = 0; col < reg.length; col++) {\r\n            _loop_2(col);\r\n        }\r\n    });\r\n    return clsRegs;\r\n};\r\nexports._getClassicalRegStart = _getClassicalRegStart;\r\n/**\r\n * Maps operation to metadata (e.g. gate type, position, dimensions, text)\r\n * required to render the image.\r\n *\r\n * @param op        Operation to be mapped into metadata format.\r\n * @param registers Array of registers.\r\n *\r\n * @returns Metadata representation of given operation.\r\n */\r\nvar _opToMetadata = function (op, registers) {\r\n    var metadata = {\r\n        type: metadata_1.GateType.Invalid,\r\n        x: 0,\r\n        controlsY: [],\r\n        targetsY: [],\r\n        label: '',\r\n        width: -1,\r\n    };\r\n    if (op == null)\r\n        return metadata;\r\n    var gate = op.gate, dataAttributes = op.dataAttributes, displayArgs = op.displayArgs, isMeasurement = op.isMeasurement, isConditional = op.isConditional, isControlled = op.isControlled, isAdjoint = op.isAdjoint, controls = op.controls, targets = op.targets, children = op.children, conditionalRender = op.conditionalRender;\r\n    // Set y coords\r\n    metadata.controlsY = (controls === null || controls === void 0 ? void 0 : controls.map(function (reg) { return _getRegY(reg, registers); })) || [];\r\n    metadata.targetsY = targets.map(function (reg) { return _getRegY(reg, registers); });\r\n    if (isConditional) {\r\n        // Classically-controlled operations\r\n        if (children == null || children.length == 0)\r\n            throw new Error('No children operations found for classically-controlled operation.');\r\n        // Gates to display when classical bit is 0.\r\n        var onZeroOps = children.filter(function (op) { return op.conditionalRender !== circuit_1.ConditionalRender.OnOne; });\r\n        var childrenInstrs = processOperations(onZeroOps, registers);\r\n        var zeroGates = childrenInstrs.metadataList;\r\n        var zeroChildWidth = childrenInstrs.svgWidth;\r\n        // Gates to display when classical bit is 1.\r\n        var onOneOps = children.filter(function (op) { return op.conditionalRender !== circuit_1.ConditionalRender.OnZero; });\r\n        childrenInstrs = processOperations(onOneOps, registers);\r\n        var oneGates = childrenInstrs.metadataList;\r\n        var oneChildWidth = childrenInstrs.svgWidth;\r\n        // Subtract startX (left-side) and 2*gatePadding (right-side) from nested child gates width\r\n        var width = Math.max(zeroChildWidth, oneChildWidth) - constants_1.startX - constants_1.gatePadding * 2;\r\n        metadata.type = metadata_1.GateType.ClassicalControlled;\r\n        metadata.children = [zeroGates, oneGates];\r\n        // Add additional width from control button and inner box padding for dashed box\r\n        metadata.width = width + constants_1.controlBtnOffset + constants_1.groupBoxPadding * 2;\r\n        // Set targets to first and last quantum registers so we can render the surrounding box\r\n        // around all quantum registers.\r\n        var qubitsY = Object.values(registers).map(function (_a) {\r\n            var y = _a.y;\r\n            return y;\r\n        });\r\n        if (qubitsY.length > 0)\r\n            metadata.targetsY = [Math.min.apply(Math, qubitsY), Math.max.apply(Math, qubitsY)];\r\n    }\r\n    else if (conditionalRender == circuit_1.ConditionalRender.AsGroup && ((children === null || children === void 0 ? void 0 : children.length) || 0) > 0) {\r\n        var childrenInstrs = processOperations(children, registers);\r\n        metadata.type = metadata_1.GateType.Group;\r\n        metadata.children = childrenInstrs.metadataList;\r\n        // _zoomButton function in gateFormatter.ts relies on\r\n        // 'expanded' attribute to render zoom button\r\n        metadata.dataAttributes = { expanded: 'true' };\r\n        // Subtract startX (left-side) and add inner box padding (minus nested gate padding) for dashed box\r\n        metadata.width = childrenInstrs.svgWidth - constants_1.startX + (constants_1.groupBoxPadding - constants_1.gatePadding) * 2;\r\n    }\r\n    else if (isMeasurement) {\r\n        metadata.type = metadata_1.GateType.Measure;\r\n    }\r\n    else if (gate === 'SWAP') {\r\n        metadata.type = metadata_1.GateType.Swap;\r\n    }\r\n    else if (isControlled) {\r\n        metadata.type = gate === 'X' ? metadata_1.GateType.Cnot : metadata_1.GateType.ControlledUnitary;\r\n        metadata.label = gate;\r\n    }\r\n    else if (gate === 'X') {\r\n        metadata.type = metadata_1.GateType.X;\r\n        metadata.label = gate;\r\n    }\r\n    else {\r\n        // Any other gate treated as a simple unitary gate\r\n        metadata.type = metadata_1.GateType.Unitary;\r\n        metadata.label = gate;\r\n    }\r\n    // If adjoint, add ' to the end of gate label\r\n    if (isAdjoint && metadata.label.length > 0)\r\n        metadata.label += \"'\";\r\n    // If gate has extra arguments, display them\r\n    if (displayArgs != null)\r\n        metadata.displayArgs = displayArgs;\r\n    // Set gate width\r\n    metadata.width = (0, utils_1.getGateWidth)(metadata);\r\n    // Extend existing data attributes with user-provided data attributes\r\n    if (dataAttributes != null)\r\n        metadata.dataAttributes = __assign(__assign({}, metadata.dataAttributes), dataAttributes);\r\n    return metadata;\r\n};\r\nexports._opToMetadata = _opToMetadata;\r\n/**\r\n * Compute the y coord of a given register.\r\n *\r\n * @param reg       Register to compute y coord of.\r\n * @param registers Map of qubit IDs to RegisterMetadata.\r\n *\r\n * @returns The y coord of give register.\r\n */\r\nvar _getRegY = function (reg, registers) {\r\n    var type = reg.type, qId = reg.qId, cId = reg.cId;\r\n    if (!registers.hasOwnProperty(qId))\r\n        throw new Error(\"ERROR: Qubit register with ID \".concat(qId, \" not found.\"));\r\n    var _a = registers[qId], y = _a.y, children = _a.children;\r\n    switch (type) {\r\n        case undefined:\r\n        case register_1.RegisterType.Qubit:\r\n            return y;\r\n        case register_1.RegisterType.Classical:\r\n            if (children == null)\r\n                throw new Error(\"ERROR: No classical registers found for qubit ID \".concat(qId, \".\"));\r\n            if (cId == null)\r\n                throw new Error(\"ERROR: No ID defined for classical register associated with qubit ID \".concat(qId, \".\"));\r\n            if (children.length <= cId)\r\n                throw new Error(\"ERROR: Classical register ID \".concat(cId, \" invalid for qubit ID \").concat(qId, \" with \").concat(children.length, \" classical register(s).\"));\r\n            return children[cId].y;\r\n        default:\r\n            throw new Error(\"ERROR: Unknown register type \".concat(type, \".\"));\r\n    }\r\n};\r\nexports._getRegY = _getRegY;\r\n/**\r\n * Splits `targets` if non-adjacent or intersected by classical registers.\r\n *\r\n * @param targets       Target qubit registers.\r\n * @param classicalRegY y coords of classical registers overlapping current column.\r\n * @param registers     Mapping from register qubit IDs to register metadata.\r\n *\r\n * @returns Groups of target qubit y coords.\r\n */\r\nvar _splitTargetsY = function (targets, classicalRegY, registers) {\r\n    if (targets.length === 0)\r\n        return [];\r\n    // Get qIds sorted by ascending y value\r\n    var orderedQIds = Object.keys(registers).map(Number);\r\n    orderedQIds.sort(function (a, b) { return registers[a].y - registers[b].y; });\r\n    var qIdPosition = {};\r\n    orderedQIds.forEach(function (qId, i) { return (qIdPosition[qId] = i); });\r\n    // Sort targets and classicalRegY by ascending y value\r\n    targets = targets.slice();\r\n    targets.sort(function (a, b) {\r\n        var posDiff = qIdPosition[a.qId] - qIdPosition[b.qId];\r\n        if (posDiff === 0 && a.cId != null && b.cId != null)\r\n            return a.cId - b.cId;\r\n        else\r\n            return posDiff;\r\n    });\r\n    classicalRegY = classicalRegY.slice();\r\n    classicalRegY.sort(function (a, b) { return a - b; });\r\n    var prevPos = 0;\r\n    var prevY = 0;\r\n    return targets.reduce(function (groups, target) {\r\n        var y = _getRegY(target, registers);\r\n        var pos = qIdPosition[target.qId];\r\n        // Split into new group if one of the following holds:\r\n        //      1. First target register\r\n        //      2. Non-adjacent qubit registers\r\n        //      3. There is a classical register between current and previous register\r\n        if (groups.length === 0 || pos > prevPos + 1 || (classicalRegY[0] > prevY && classicalRegY[0] < y))\r\n            groups.push([y]);\r\n        else\r\n            groups[groups.length - 1].push(y);\r\n        prevPos = pos;\r\n        prevY = y;\r\n        // Remove classical registers that are higher than current y\r\n        while (classicalRegY.length > 0 && classicalRegY[0] <= y)\r\n            classicalRegY.shift();\r\n        return groups;\r\n    }, []);\r\n};\r\nexports._splitTargetsY = _splitTargetsY;\r\n/**\r\n * Updates the x coord of each metadata in the given 2D array of metadata and returns rightmost x coord.\r\n *\r\n * @param opsMetadata  2D array of metadata.\r\n * @param columnWidths Array of column widths.\r\n *\r\n * @returns Rightmost x coord.\r\n */\r\nvar _fillMetadataX = function (opsMetadata, columnWidths) {\r\n    var currX = constants_1.startX;\r\n    var colStartX = columnWidths.map(function (width) {\r\n        var x = currX;\r\n        currX += width + constants_1.gatePadding * 2;\r\n        return x;\r\n    });\r\n    var endX = currX;\r\n    opsMetadata.forEach(function (regOps) {\r\n        return regOps.forEach(function (metadata, col) {\r\n            var x = colStartX[col];\r\n            switch (metadata.type) {\r\n                case metadata_1.GateType.ClassicalControlled:\r\n                case metadata_1.GateType.Group:\r\n                    // Subtract startX offset from nested gates and add offset and padding\r\n                    var offset = x - constants_1.startX + constants_1.groupBoxPadding;\r\n                    if (metadata.type === metadata_1.GateType.ClassicalControlled)\r\n                        offset += constants_1.controlBtnOffset;\r\n                    // Offset each x coord in children gates\r\n                    _offsetChildrenX(metadata.children, offset);\r\n                    // We don't use the centre x coord because we only care about the rightmost x for\r\n                    // rendering the box around the group of nested gates\r\n                    metadata.x = x;\r\n                    break;\r\n                default:\r\n                    metadata.x = x + columnWidths[col] / 2;\r\n                    break;\r\n            }\r\n        });\r\n    });\r\n    return endX;\r\n};\r\nexports._fillMetadataX = _fillMetadataX;\r\n/**\r\n * Offset x coords of nested children operations.\r\n *\r\n * @param children 2D array of children metadata.\r\n * @param offset   x coord offset.\r\n */\r\nvar _offsetChildrenX = function (children, offset) {\r\n    if (children == null)\r\n        return;\r\n    children.flat().forEach(function (child) {\r\n        child.x += offset;\r\n        _offsetChildrenX(child.children, offset);\r\n    });\r\n};\r\nexports._offsetChildrenX = _offsetChildrenX;\r\n","\"use strict\";\r\n// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT license.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RegisterType = void 0;\r\n/**\r\n * Type of register.\r\n */\r\nvar RegisterType;\r\n(function (RegisterType) {\r\n    RegisterType[RegisterType[\"Qubit\"] = 0] = \"Qubit\";\r\n    RegisterType[RegisterType[\"Classical\"] = 1] = \"Classical\";\r\n})(RegisterType = exports.RegisterType || (exports.RegisterType = {}));\r\n","\"use strict\";\r\n// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT license.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Sqore = void 0;\r\nvar inputFormatter_1 = require(\"./formatters/inputFormatter\");\r\nvar gateFormatter_1 = require(\"./formatters/gateFormatter\");\r\nvar registerFormatter_1 = require(\"./formatters/registerFormatter\");\r\nvar process_1 = require(\"./process\");\r\nvar circuit_1 = require(\"./circuit\");\r\nvar metadata_1 = require(\"./metadata\");\r\nvar styles_1 = require(\"./styles\");\r\nvar utils_1 = require(\"./utils\");\r\nvar constants_1 = require(\"./constants\");\r\n/**\r\n * Entrypoint class for rendering circuit visualizations.\r\n */\r\nvar Sqore = /** @class */ (function () {\r\n    /**\r\n     * Initializes Sqore object with custom styles.\r\n     *\r\n     * @param circuit Circuit to be visualized.\r\n     * @param style Custom visualization style.\r\n     */\r\n    function Sqore(circuit, style) {\r\n        if (style === void 0) { style = {}; }\r\n        this.style = {};\r\n        this.gateRegistry = {};\r\n        this.circuit = circuit;\r\n        this.style = this.getStyle(style);\r\n    }\r\n    /**\r\n     * Render circuit into `container` at the specified layer depth.\r\n     *\r\n     * @param container HTML element for rendering visualization into.\r\n     * @param renderDepth Initial layer depth at which to render gates.\r\n     */\r\n    Sqore.prototype.draw = function (container, renderDepth) {\r\n        var _this = this;\r\n        if (renderDepth === void 0) { renderDepth = 0; }\r\n        // Inject into container\r\n        if (container == null)\r\n            throw new Error(\"Container not provided.\");\r\n        // Create copy of circuit to prevent mutation\r\n        var circuit = JSON.parse(JSON.stringify(this.circuit));\r\n        // Assign unique IDs to each operation\r\n        circuit.operations.forEach(function (op, i) { return _this.fillGateRegistry(op, i.toString()); });\r\n        // Render operations at starting at given depth\r\n        circuit.operations = this.selectOpsAtDepth(circuit.operations, renderDepth);\r\n        // If only one top-level operation, expand automatically:\r\n        if (circuit.operations.length == 1 &&\r\n            circuit.operations[0].dataAttributes != null &&\r\n            circuit.operations[0].dataAttributes.hasOwnProperty('id')) {\r\n            var id = circuit.operations[0].dataAttributes['id'];\r\n            this.expandOperation(circuit.operations, id);\r\n        }\r\n        this.renderCircuit(container, circuit);\r\n    };\r\n    /**\r\n     * Retrieve style for visualization.\r\n     *\r\n     * @param style Custom style or style name.\r\n     *\r\n     * @returns Custom style.\r\n     */\r\n    Sqore.prototype.getStyle = function (style) {\r\n        if (style === void 0) { style = {}; }\r\n        if (typeof style === 'string' || style instanceof String) {\r\n            var styleName = style;\r\n            if (!styles_1.STYLES.hasOwnProperty(styleName)) {\r\n                console.error(\"No style \".concat(styleName, \" found in STYLES.\"));\r\n                return {};\r\n            }\r\n            style = styles_1.STYLES[styleName];\r\n        }\r\n        return style;\r\n    };\r\n    /**\r\n     * Render circuit into `container`.\r\n     *\r\n     * @param container HTML element for rendering visualization into.\r\n     * @param circuit Circuit object to be rendered.\r\n     */\r\n    Sqore.prototype.renderCircuit = function (container, circuit) {\r\n        // Create visualization components\r\n        var composedSqore = this.compose(circuit);\r\n        var svg = this.generateSvg(composedSqore);\r\n        container.innerHTML = '';\r\n        container.appendChild(svg);\r\n        this.addGateClickHandlers(container, circuit);\r\n    };\r\n    /**\r\n     * Generates the components required for visualization.\r\n     *\r\n     * @param circuit Circuit to be visualized.\r\n     *\r\n     * @returns `ComposedSqore` object containing metadata for visualization.\r\n     */\r\n    Sqore.prototype.compose = function (circuit) {\r\n        var add = function (acc, gate) {\r\n            var _a;\r\n            if (Array.isArray(gate)) {\r\n                gate.forEach(function (g) { return add(acc, g); });\r\n            }\r\n            else {\r\n                acc.push(gate);\r\n                (_a = gate.children) === null || _a === void 0 ? void 0 : _a.forEach(function (g) { return add(acc, g); });\r\n            }\r\n        };\r\n        var flatten = function (gates) {\r\n            var result = [];\r\n            add(result, gates);\r\n            return result;\r\n        };\r\n        var qubits = circuit.qubits, operations = circuit.operations;\r\n        var _a = (0, inputFormatter_1.formatInputs)(qubits), qubitWires = _a.qubitWires, registers = _a.registers, svgHeight = _a.svgHeight;\r\n        var _b = (0, process_1.processOperations)(operations, registers), metadataList = _b.metadataList, svgWidth = _b.svgWidth;\r\n        var formattedGates = (0, gateFormatter_1.formatGates)(metadataList);\r\n        var measureGates = flatten(metadataList).filter(function (_a) {\r\n            var type = _a.type;\r\n            return type === metadata_1.GateType.Measure;\r\n        });\r\n        var formattedRegs = (0, registerFormatter_1.formatRegisters)(registers, measureGates, svgWidth);\r\n        var composedSqore = {\r\n            width: svgWidth,\r\n            height: svgHeight,\r\n            elements: [qubitWires, formattedRegs, formattedGates],\r\n        };\r\n        return composedSqore;\r\n    };\r\n    /**\r\n     * Generates visualization of `composedSqore` as an SVG.\r\n     *\r\n     * @param composedSqore ComposedSqore to be visualized.\r\n     *\r\n     * @returns SVG representation of circuit visualization.\r\n     */\r\n    Sqore.prototype.generateSvg = function (composedSqore) {\r\n        var width = composedSqore.width, height = composedSqore.height, elements = composedSqore.elements;\r\n        var uuid = (0, utils_1.createUUID)();\r\n        var svg = document.createElementNS(constants_1.svgNS, 'svg');\r\n        svg.setAttribute('id', uuid);\r\n        svg.setAttribute('class', 'qviz');\r\n        svg.setAttribute('width', width.toString());\r\n        svg.setAttribute('height', height.toString());\r\n        svg.style.setProperty('max-width', 'fit-content');\r\n        // Add styles\r\n        var css = document.createElement('style');\r\n        css.innerHTML = (0, styles_1.style)(this.style);\r\n        svg.appendChild(css);\r\n        // Add body elements\r\n        elements.forEach(function (element) { return svg.appendChild(element); });\r\n        return svg;\r\n    };\r\n    /**\r\n     * Depth-first traversal to assign unique ID to `operation`.\r\n     * The operation is assigned the id `id` and its `i`th child is recursively given\r\n     * the id `${id}-${i}`.\r\n     *\r\n     * @param operation Operation to be assigned.\r\n     * @param id: ID to assign to `operation`.\r\n     *\r\n     */\r\n    Sqore.prototype.fillGateRegistry = function (operation, id) {\r\n        var _this = this;\r\n        var _a;\r\n        if (operation.dataAttributes == null)\r\n            operation.dataAttributes = {};\r\n        operation.dataAttributes['id'] = id;\r\n        // By default, operations cannot be zoomed-out\r\n        operation.dataAttributes['zoom-out'] = 'false';\r\n        this.gateRegistry[id] = operation;\r\n        (_a = operation.children) === null || _a === void 0 ? void 0 : _a.forEach(function (childOp, i) {\r\n            _this.fillGateRegistry(childOp, \"\".concat(id, \"-\").concat(i));\r\n            if (childOp.dataAttributes == null)\r\n                childOp.dataAttributes = {};\r\n            // Children operations can be zoomed out\r\n            childOp.dataAttributes['zoom-out'] = 'true';\r\n        });\r\n        // Composite operations can be zoomed in\r\n        operation.dataAttributes['zoom-in'] = (operation.children != null).toString();\r\n    };\r\n    /**\r\n     * Pick out operations that are at or below `renderDepth`.\r\n     *\r\n     * @param operations List of circuit operations.\r\n     * @param renderDepth Initial layer depth at which to render gates.\r\n     *\r\n     * @returns List of operations at or below specifed depth.\r\n     */\r\n    Sqore.prototype.selectOpsAtDepth = function (operations, renderDepth) {\r\n        var _this = this;\r\n        if (renderDepth < 0)\r\n            throw new Error(\"Invalid renderDepth of \".concat(renderDepth, \". Needs to be >= 0.\"));\r\n        if (renderDepth === 0)\r\n            return operations;\r\n        return operations\r\n            .map(function (op) { return (op.children != null ? _this.selectOpsAtDepth(op.children, renderDepth - 1) : op); })\r\n            .flat();\r\n    };\r\n    /**\r\n     * Add interactive click handlers to circuit HTML elements.\r\n     *\r\n     * @param container HTML element containing visualized circuit.\r\n     * @param circuit Circuit to be visualized.\r\n     *\r\n     */\r\n    Sqore.prototype.addGateClickHandlers = function (container, circuit) {\r\n        this.addClassicalControlHandlers(container);\r\n        this.addZoomHandlers(container, circuit);\r\n    };\r\n    /**\r\n     * Add interactive click handlers for classically-controlled operations.\r\n     *\r\n     * @param container HTML element containing visualized circuit.\r\n     *\r\n     */\r\n    Sqore.prototype.addClassicalControlHandlers = function (container) {\r\n        container.querySelectorAll('.classically-controlled-btn').forEach(function (btn) {\r\n            // Zoom in on clicked gate\r\n            btn.addEventListener('click', function (evt) {\r\n                var _a;\r\n                var textSvg = btn.querySelector('text');\r\n                var group = btn.parentElement;\r\n                if (textSvg == null || group == null)\r\n                    return;\r\n                var currValue = (_a = textSvg.firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue;\r\n                var zeroGates = group === null || group === void 0 ? void 0 : group.querySelector('.gates-zero');\r\n                var oneGates = group === null || group === void 0 ? void 0 : group.querySelector('.gates-one');\r\n                switch (currValue) {\r\n                    case '?':\r\n                        textSvg.childNodes[0].nodeValue = '1';\r\n                        group.classList.remove('classically-controlled-unknown');\r\n                        group.classList.remove('classically-controlled-zero');\r\n                        group.classList.add('classically-controlled-one');\r\n                        zeroGates === null || zeroGates === void 0 ? void 0 : zeroGates.classList.add('hidden');\r\n                        oneGates === null || oneGates === void 0 ? void 0 : oneGates.classList.remove('hidden');\r\n                        break;\r\n                    case '1':\r\n                        textSvg.childNodes[0].nodeValue = '0';\r\n                        group.classList.remove('classically-controlled-unknown');\r\n                        group.classList.add('classically-controlled-zero');\r\n                        group.classList.remove('classically-controlled-one');\r\n                        zeroGates === null || zeroGates === void 0 ? void 0 : zeroGates.classList.remove('hidden');\r\n                        oneGates === null || oneGates === void 0 ? void 0 : oneGates.classList.add('hidden');\r\n                        break;\r\n                    case '0':\r\n                        textSvg.childNodes[0].nodeValue = '?';\r\n                        group.classList.add('classically-controlled-unknown');\r\n                        group.classList.remove('classically-controlled-zero');\r\n                        group.classList.remove('classically-controlled-one');\r\n                        zeroGates === null || zeroGates === void 0 ? void 0 : zeroGates.classList.remove('hidden');\r\n                        oneGates === null || oneGates === void 0 ? void 0 : oneGates.classList.remove('hidden');\r\n                        break;\r\n                }\r\n                evt.stopPropagation();\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Add interactive click handlers for zoom-in/out functionality.\r\n     *\r\n     * @param container HTML element containing visualized circuit.\r\n     * @param circuit Circuit to be visualized.\r\n     *\r\n     */\r\n    Sqore.prototype.addZoomHandlers = function (container, circuit) {\r\n        var _this = this;\r\n        container.querySelectorAll('.gate .gate-control').forEach(function (ctrl) {\r\n            // Zoom in on clicked gate\r\n            ctrl.addEventListener('click', function (ev) {\r\n                var _a;\r\n                var gateId = (_a = ctrl.parentElement) === null || _a === void 0 ? void 0 : _a.getAttribute('data-id');\r\n                if (typeof gateId == 'string') {\r\n                    if (ctrl.classList.contains('gate-collapse')) {\r\n                        _this.collapseOperation(circuit.operations, gateId);\r\n                    }\r\n                    else if (ctrl.classList.contains('gate-expand')) {\r\n                        _this.expandOperation(circuit.operations, gateId);\r\n                    }\r\n                    _this.renderCircuit(container, circuit);\r\n                    ev.stopPropagation();\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Expand selected operation for zoom-in interaction.\r\n     *\r\n     * @param operations List of circuit operations.\r\n     * @param id ID of operation to expand.\r\n     *\r\n     */\r\n    Sqore.prototype.expandOperation = function (operations, id) {\r\n        var _this = this;\r\n        operations.forEach(function (op) {\r\n            if (op.conditionalRender === circuit_1.ConditionalRender.AsGroup)\r\n                _this.expandOperation(op.children || [], id);\r\n            if (op.dataAttributes == null)\r\n                return op;\r\n            var opId = op.dataAttributes['id'];\r\n            if (opId === id && op.children != null) {\r\n                op.conditionalRender = circuit_1.ConditionalRender.AsGroup;\r\n                op.dataAttributes['expanded'] = 'true';\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Collapse selected operation for zoom-out interaction.\r\n     *\r\n     * @param operations List of circuit operations.\r\n     * @param id ID of operation to collapse.\r\n     *\r\n     */\r\n    Sqore.prototype.collapseOperation = function (operations, parentId) {\r\n        var _this = this;\r\n        operations.forEach(function (op) {\r\n            if (op.conditionalRender === circuit_1.ConditionalRender.AsGroup)\r\n                _this.collapseOperation(op.children || [], parentId);\r\n            if (op.dataAttributes == null)\r\n                return op;\r\n            var opId = op.dataAttributes['id'];\r\n            // Collapse parent gate and its children\r\n            if (opId.startsWith(parentId)) {\r\n                op.conditionalRender = circuit_1.ConditionalRender.Always;\r\n                delete op.dataAttributes['expanded'];\r\n            }\r\n        });\r\n    };\r\n    return Sqore;\r\n}());\r\nexports.Sqore = Sqore;\r\n","\"use strict\";\r\n// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT license.\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.style = exports.STYLES = void 0;\r\nvar defaultStyle = {\r\n    lineStroke: '#000000',\r\n    lineWidth: 1,\r\n    textColour: '#000000',\r\n    unitary: '#D9F1FA',\r\n    oplus: '#FFFFFF',\r\n    measure: '#FFDE86',\r\n    classicalUnknown: '#E5E5E5',\r\n    classicalZero: '#C40000',\r\n    classicalOne: '#4059BD',\r\n    classicalZeroText: '#FFFFFF',\r\n    classicalOneText: '#FFFFFF',\r\n};\r\nvar blackAndWhiteStyle = {\r\n    lineStroke: '#000000',\r\n    lineWidth: 1,\r\n    textColour: '#000000',\r\n    unitary: '#FFFFFF',\r\n    oplus: '#FFFFFF',\r\n    measure: '#FFFFFF',\r\n    classicalUnknown: '#FFFFFF',\r\n    classicalZero: '#000000',\r\n    classicalOne: '#000000',\r\n    classicalZeroText: '#FFFFFF',\r\n    classicalOneText: '#FFFFFF',\r\n};\r\nvar invertedStyle = {\r\n    lineStroke: '#FFFFFF',\r\n    lineWidth: 1,\r\n    textColour: '#FFFFFF',\r\n    unitary: '#000000',\r\n    oplus: '#000000',\r\n    measure: '#000000',\r\n    classicalUnknown: '#000000',\r\n    classicalZero: '#FFFFFF',\r\n    classicalOne: '#FFFFFF',\r\n    classicalZeroText: '#000000',\r\n    classicalOneText: '#000000',\r\n};\r\n/**\r\n * Set of default styles.\r\n */\r\nexports.STYLES = {\r\n    /** Default style with coloured gates. */\r\n    Default: defaultStyle,\r\n    /** Black and white style. */\r\n    BlackAndWhite: blackAndWhiteStyle,\r\n    /** Inverted black and white style (for black backgrounds). */\r\n    Inverted: invertedStyle,\r\n};\r\n/**\r\n * CSS style script to be injected into visualization SVG.\r\n *\r\n * @param customStyle Custom style configuration.\r\n *\r\n * @returns String containing CSS style script.\r\n */\r\nvar style = function (customStyle) {\r\n    if (customStyle === void 0) { customStyle = {}; }\r\n    var styleConfig = __assign(__assign({}, defaultStyle), customStyle);\r\n    return \"\".concat(_defaultGates(styleConfig), \"\\n    \").concat(_classicallyControlledGates(styleConfig), \"\\n    \").concat(_expandCollapse);\r\n};\r\nexports.style = style;\r\nvar _defaultGates = function (styleConfig) { return \"\\n    line,\\n    circle,\\n    rect {\\n        stroke: \".concat(styleConfig.lineStroke, \";\\n        stroke-width: \").concat(styleConfig.lineWidth, \";\\n    }\\n    text {\\n        fill: \").concat(styleConfig.textColour, \";\\n        dominant-baseline: middle;\\n        text-anchor: middle;\\n        font-family: Arial;\\n    }\\n    .control-dot {\\n        fill: \").concat(styleConfig.lineStroke, \";\\n    }\\n    .oplus line, .oplus circle {\\n        fill: \").concat(styleConfig.oplus, \";\\n        stroke-width: 2;\\n    }\\n    .gate-unitary {\\n        fill: \").concat(styleConfig.unitary, \";\\n    }\\n    .gate-measure {\\n        fill: \").concat(styleConfig.measure, \";\\n    }\\n    rect.gate-swap {\\n        fill: transparent;\\n        stroke: transparent;\\n    }\\n    .arc-measure {\\n        stroke: \").concat(styleConfig.lineStroke, \";\\n        fill: none;\\n        stroke-width: \").concat(styleConfig.lineWidth, \";\\n    }\\n    .register-classical {\\n        stroke-width: \").concat((styleConfig.lineWidth || 0) / 2, \";\\n    }\"); };\r\nvar _classicallyControlledGates = function (styleConfig) {\r\n    var gateOutline = \"\\n    .classically-controlled-one .classical-container,\\n    .classically-controlled-one .classical-line {\\n        stroke: \".concat(styleConfig.classicalOne, \";\\n        stroke-width: \").concat((styleConfig.lineWidth || 0) + 0.3, \";\\n        fill: \").concat(styleConfig.classicalOne, \";\\n        fill-opacity: 0.1;\\n    }\\n    .classically-controlled-zero .classical-container,\\n    .classically-controlled-zero .classical-line {\\n        stroke: \").concat(styleConfig.classicalZero, \";\\n        stroke-width: \").concat((styleConfig.lineWidth || 0) + 0.3, \";\\n        fill: \").concat(styleConfig.classicalZero, \";\\n        fill-opacity: 0.1;\\n    }\");\r\n    var controlBtn = \"\\n    .classically-controlled-btn {\\n        cursor: pointer;\\n    }\\n    .classically-controlled-unknown .classically-controlled-btn {\\n        fill: \".concat(styleConfig.classicalUnknown, \";\\n    }\\n    .classically-controlled-one .classically-controlled-btn {\\n        fill: \").concat(styleConfig.classicalOne, \";\\n    }\\n    .classically-controlled-zero .classically-controlled-btn {\\n        fill: \").concat(styleConfig.classicalZero, \";\\n    }\");\r\n    var controlBtnText = \"\\n    .classically-controlled-btn text {\\n        dominant-baseline: middle;\\n        text-anchor: middle;\\n        stroke: none;\\n        font-family: Arial;\\n    }\\n    .classically-controlled-unknown .classically-controlled-btn text {\\n        fill: \".concat(styleConfig.textColour, \";\\n    }\\n    .classically-controlled-one .classically-controlled-btn text {\\n        fill: \").concat(styleConfig.classicalOneText, \";\\n    }\\n    .classically-controlled-zero .classically-controlled-btn text {\\n        fill: \").concat(styleConfig.classicalZeroText, \";\\n    }\");\r\n    return \"\\n    .hidden {\\n        display: none;\\n    }\\n    .classically-controlled-unknown {\\n        opacity: 0.25;\\n    }\\n\\n    \".concat(gateOutline, \"\\n    \").concat(controlBtn, \"\\n    \").concat(controlBtnText);\r\n};\r\nvar _expandCollapse = \"\\n    .qviz .gate-collapse,\\n    .qviz .gate-expand {\\n        opacity: 0;\\n        transition: opacity 1s;\\n    }\\n\\n    .qviz:hover .gate-collapse,\\n    .qviz:hover .gate-expand {\\n        visibility: visible;\\n        opacity: 0.2;\\n        transition: visibility 1s;\\n        transition: opacity 1s;\\n    }\\n\\n    .gate-expand, .gate-collapse {\\n        cursor: pointer;\\n    }\\n\\n    .gate-collapse circle,\\n    .gate-expand circle {\\n        fill: white;\\n        stroke-width: 2px;\\n        stroke: black;\\n    }\\n    .gate-collapse path,\\n    .gate-expand path {\\n        stroke-width: 4px;\\n        stroke: black;\\n    }\\n\\n    .gate:hover > .gate-collapse,\\n    .gate:hover > .gate-expand {\\n        visibility: visible;\\n        opacity: 1;\\n        transition: opacity 1s;\\n    }\";\r\n","\"use strict\";\r\n// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT license.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports._getStringWidth = exports.getGateWidth = exports.createUUID = void 0;\r\nvar metadata_1 = require(\"./metadata\");\r\nvar constants_1 = require(\"./constants\");\r\n/**\r\n * Generate a UUID using `Math.random`.\r\n * Note: this implementation came from https://stackoverflow.com/questions/105034/how-to-create-guid-uuid\r\n * and is not cryptographically secure but works for our use case.\r\n *\r\n * @returns UUID string.\r\n */\r\nvar createUUID = function () {\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n        var r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\r\n        return v.toString(16);\r\n    });\r\n};\r\nexports.createUUID = createUUID;\r\n/**\r\n * Calculate the width of a gate, given its metadata.\r\n *\r\n * @param metadata Metadata of a given gate.\r\n *\r\n * @returns Width of given gate (in pixels).\r\n */\r\nvar getGateWidth = function (_a) {\r\n    var type = _a.type, label = _a.label, displayArgs = _a.displayArgs, width = _a.width;\r\n    if (width > 0)\r\n        return width;\r\n    switch (type) {\r\n        case metadata_1.GateType.Measure:\r\n        case metadata_1.GateType.Cnot:\r\n        case metadata_1.GateType.Swap:\r\n            return constants_1.minGateWidth;\r\n        default:\r\n            var labelWidth = _getStringWidth(label);\r\n            var argsWidth = displayArgs != null ? _getStringWidth(displayArgs, constants_1.argsFontSize) : 0;\r\n            var textWidth = Math.max(labelWidth, argsWidth) + constants_1.labelPadding * 2;\r\n            return Math.max(constants_1.minGateWidth, textWidth);\r\n    }\r\n};\r\nexports.getGateWidth = getGateWidth;\r\n/**\r\n * Get the width of a string with font-size `fontSize` and font-family Arial.\r\n *\r\n * @param text     Input string.\r\n * @param fontSize Font size of `text`.\r\n *\r\n * @returns Pixel width of given string.\r\n */\r\nvar _getStringWidth = function (text, fontSize) {\r\n    if (fontSize === void 0) { fontSize = constants_1.labelFontSize; }\r\n    var canvas = document.createElement('canvas');\r\n    var context = canvas.getContext('2d');\r\n    if (context == null)\r\n        throw new Error('Null canvas');\r\n    context.font = \"\".concat(fontSize, \"px Arial\");\r\n    var metrics = context.measureText(text);\r\n    return metrics.width;\r\n};\r\nexports._getStringWidth = _getStringWidth;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\r\n// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT license.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.STYLES = exports.draw = void 0;\r\nvar sqore_1 = require(\"./sqore\");\r\n/**\r\n * Render `circuit` into `container` at the specified layer depth.\r\n *\r\n * @param circuit Circuit to be visualized.\r\n * @param container HTML element for rendering visualization into.\r\n * @param style Custom visualization style.\r\n * @param renderDepth Initial layer depth at which to render gates.\r\n */\r\nvar draw = function (circuit, container, style, renderDepth) {\r\n    if (style === void 0) { style = {}; }\r\n    if (renderDepth === void 0) { renderDepth = 0; }\r\n    var sqore = new sqore_1.Sqore(circuit, style);\r\n    sqore.draw(container, renderDepth);\r\n};\r\nexports.draw = draw;\r\nvar styles_1 = require(\"./styles\");\r\nObject.defineProperty(exports, \"STYLES\", { enumerable: true, get: function () { return styles_1.STYLES; } });\r\n"],"names":[],"sourceRoot":""}