"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.exportedForTesting = exports._lastIndex = exports._equivParentArray = exports._equivGateElem = exports._equivOperation = exports.extensionDraggable = void 0;
var cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
var isEqual_1 = __importDefault(require("lodash/isEqual"));
var formatUtils_1 = require("./formatters/formatUtils");
/**
 * Add editable elements and events.
 *
 * @param Container     HTML element for rendering visualization into.
 * @param sqore         Sqore object
 * @param useRefresh    Function to trigger circuit re-rendering
 */
var extensionDraggable = function (container, sqore, useRefresh) {
    var svg = container.querySelector('svg[id]');
    var context = {
        container: container,
        svg: svg,
        operations: sqore.circuit.operations,
        wireData: _wireData(container),
        renderFn: useRefresh,
        paddingY: 20,
        selectedId: null,
        selectedWire: null,
    };
    _addStyles(container, _wireData(container));
    _addDataWires(container);
    svg.appendChild(_dropzoneLayer(context));
    _addEvents(context);
};
exports.extensionDraggable = extensionDraggable;
/**
 * Add data-wire to all host elements
 */
var _addDataWires = function (container) {
    var elems = _hostElems(container);
    elems.forEach(function (elem) {
        var cY = _center(elem).cY;
        // i.e. cY = 40, wireData returns [40, 100, 140, 180]
        // dataWire will return 0, which is the index of 40 in wireData
        var dataWire = _wireData(container).findIndex(function (y) { return y === cY; });
        if (dataWire !== -1) {
            elem.setAttribute('data-wire', "" + dataWire);
        }
        else {
            var _a = elem.getBBox(), y_1 = _a.y, height_1 = _a.height;
            var wireData = _wireData(container);
            var groupDataWire = wireData.findIndex(function (wireY) { return wireY > y_1 && wireY < y_1 + height_1; });
            elem.setAttribute('data-wire', "" + groupDataWire);
        }
    });
};
/**
 * Create a list of wires that element is spanning on
 * i.e. Gate 'Foo' spans on wire 0 (y=40), 1 (y=100), and 2 (y=140)
 *      Function returns [40, 100, 140]
 */
var _wireYs = function (elem, wireData) {
    var _a = elem.getBBox(), y = _a.y, height = _a.height;
    return wireData.filter(function (wireY) { return wireY > y && wireY < y + height; });
};
/**
 * Get list of host elements that dropzones can be attached to
 */
var _hostElems = function (container) {
    var svgElem = container.querySelector('svg[id]');
    return svgElem != null
        ? Array.from(svgElem.querySelectorAll('[class^="gate-"]:not(.gate-control, .gate-swap), .control-dot, .oplus, .cross'))
        : [];
};
/**
 * Add custom styles specific to this module
 */
var _addStyles = function (container, wireData) {
    var elems = _hostElems(container);
    elems.forEach(function (elem) {
        if (_wireYs(elem, wireData).length < 2)
            elem.style.cursor = 'grab';
    });
};
/**
 * Generate an array of wire prefixes from wire data
 */
var _wirePrefixes = function (wireData) {
    return wireData.map(function (wireY, index) { return ({ index: index, wireY: wireY, prefixX: 40 }); });
};
/**
 * Find center point of element
 */
var _center = function (elem) {
    var _a = elem.getBBox(), x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    return { cX: x + width / 2, cY: y + height / 2 };
};
/**
 * Create dropzone layer with all dropzones popullated
 */
var _dropzoneLayer = function (context) {
    var dropzoneLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    dropzoneLayer.classList.add('dropzone-layer');
    var container = context.container, svg = context.svg, wireData = context.wireData, operations = context.operations, paddingY = context.paddingY;
    var elems = _hostElems(container);
    var wirePrefixes = _wirePrefixes(wireData);
    // Sort host elements by its x property
    var sortedElems = Array.from(elems).sort(function (first, second) {
        var x1 = first.getBBox().x;
        var x2 = second.getBBox().x;
        return x1 - x2;
    });
    // Add dropzones for each host elements
    sortedElems.map(function (elem) {
        var _a = _center(elem), cX = _a.cX, cY = _a.cY;
        var wirePrefix = wirePrefixes.find(function (item) { return item.wireY === cY; });
        // Check to prevent group gates creating dropzones between wires
        if (wirePrefix) {
            var prefixX = wirePrefix.prefixX;
            var elemDropzone = formatUtils_1.box(prefixX, cY - paddingY, cX - prefixX, paddingY * 2, 'dropzone');
            elemDropzone.setAttribute('data-dropzone-id', _equivDataId(elem) || '');
            elemDropzone.setAttribute('data-dropzone-wire', "" + wirePrefix.index);
            wirePrefix.prefixX = cX;
            dropzoneLayer.appendChild(elemDropzone);
        }
        else {
            // Let group gates creating dropzones for each wire
            var x_1 = elem.getBBox().x;
            var wireYs = _wireYs(elem, wireData);
            wireYs.map(function (wireY) {
                var wirePrefix = wirePrefixes.find(function (item) { return item.wireY === wireY; });
                if (wirePrefix) {
                    var prefixX = wirePrefix.prefixX;
                    var elemDropzone = formatUtils_1.box(prefixX, wireY - paddingY, x_1 - prefixX, paddingY * 2, 'dropzone');
                    elemDropzone.setAttribute('data-dropzone-id', _equivDataId(elem) || '');
                    elemDropzone.setAttribute('data-dropzone-wire', "" + wirePrefix.index);
                    wirePrefix.prefixX = x_1;
                    dropzoneLayer.appendChild(elemDropzone);
                }
            });
        }
    });
    // Add remaining dropzones to fit max-width of the circuit
    wirePrefixes.map(function (_a) {
        var wireY = _a.wireY, prefixX = _a.prefixX;
        var maxWidth = Number(svg.getAttribute('width'));
        var elemDropzone = formatUtils_1.box(prefixX, wireY - paddingY, maxWidth - prefixX, paddingY * 2, 'dropzone');
        elemDropzone.setAttribute('data-dropzone-id', "" + operations.length);
        var index = wireData.findIndex(function (item) { return item === wireY; });
        elemDropzone.setAttribute('data-dropzone-wire', "" + index);
        dropzoneLayer.appendChild(elemDropzone);
    });
    return dropzoneLayer;
};
/**
 * Generate an array of y values based on circuit wires
 */
var _wireData = function (container) {
    // elems include qubit wires and lines of measure gates
    var elems = container.querySelectorAll('svg[id] > g:nth-child(3) > g');
    // filter out <g> elements having more than 2 elements because
    // qubit wires contain only 2 elements: <line> and <text>
    // lines of measure gates contain 4 <line> elements
    var wireElems = Array.from(elems).filter(function (elem) { return elem.childElementCount < 3; });
    var wireData = wireElems.map(function (wireElem) {
        var lineElem = wireElem.children[0];
        return Number(lineElem.getAttribute('y1'));
    });
    return wireData;
};
/**
 * Find equivalent gate element of host element
 */
var _equivGateElem = function (elem) {
    return elem.closest('[data-id]');
};
exports._equivGateElem = _equivGateElem;
/**
 * Find data-id of host element
 */
var _equivDataId = function (elem) {
    var gateElem = _equivGateElem(elem);
    return gateElem != null ? gateElem.getAttribute('data-id') : null;
};
/**
 * Add events specifically for dropzoneLayer
 */
var _addDropzoneLayerEvents = function (container, dropzoneLayer) {
    container.addEventListener('mouseup', function () { return (dropzoneLayer.style.display = 'none'); });
};
/**
 * Add events for document
 */
var _addDocumentEvents = function (context) {
    var container = context.container;
    document.addEventListener('keydown', function (ev) {
        if (ev.ctrlKey && context.selectedId) {
            container.classList.remove('moving');
            container.classList.add('copying');
        }
    });
    document.addEventListener('keyup', function () {
        if (context.selectedId) {
            container.classList.remove('copying');
            container.classList.add('moving');
        }
    });
    document.addEventListener('mouseup', function () {
        container.classList.remove('moving', 'copying');
    });
};
/**
 * Disable contextmenu default behaviors
 */
var _addContextMenuEvent = function (container) {
    container.addEventListener('contextmenu', function (ev) {
        ev.preventDefault();
    });
};
/**
 * Add all events
 */
var _addEvents = function (context) {
    var container = context.container, operations = context.operations, renderFn = context.renderFn;
    var dropzoneLayer = container.querySelector('.dropzone-layer');
    _addContextMenuEvent(container);
    _addDropzoneLayerEvents(container, dropzoneLayer);
    _addDocumentEvents(context);
    // Host element events
    var elems = _hostElems(container);
    elems.forEach(function (elem) {
        elem.addEventListener('mousedown', function () {
            context.selectedWire = elem.getAttribute('data-wire');
            container.classList.add('moving');
        });
        var gateElem = _equivGateElem(elem);
        gateElem === null || gateElem === void 0 ? void 0 : gateElem.addEventListener('mousedown', function (ev) {
            ev.stopPropagation();
            context.selectedId = _equivDataId(elem);
            dropzoneLayer.style.display = 'block';
        });
    });
    // Dropzone element events
    var dropzoneElems = dropzoneLayer.querySelectorAll('.dropzone');
    dropzoneElems.forEach(function (dropzoneElem) {
        dropzoneElem.addEventListener('mouseup', function (ev) {
            var originalOperations = cloneDeep_1.default(operations);
            var targetId = dropzoneElem.getAttribute('data-dropzone-id');
            var targetWire = dropzoneElem.getAttribute('data-dropzone-wire');
            if (targetId == null || //
                targetWire == null ||
                context.selectedId == null ||
                context.selectedWire == null)
                return;
            var newSourceOperation = ev.ctrlKey
                ? _copyX(context.selectedId, targetId, operations)
                : _moveX(context.selectedId, targetId, operations);
            if (newSourceOperation != null) {
                _moveY(context.selectedWire, targetWire, newSourceOperation, context.wireData.length);
                var parentOperation = _equivParentOperation(context.selectedId, operations);
                if (parentOperation != null) {
                    parentOperation.targets = _targets(parentOperation);
                }
            }
            if (isEqual_1.default(originalOperations, operations) === false)
                renderFn();
        });
    });
};
var _equivParentOperation = function (dataId, operations) {
    if (!dataId)
        return null;
    var indexes = _indexes(dataId);
    indexes.pop();
    var lastIndex = indexes.pop();
    if (lastIndex == null)
        return null;
    var parentOperation = operations;
    for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {
        var index = indexes_1[_i];
        parentOperation = parentOperation[index].children || parentOperation;
    }
    return parentOperation[lastIndex];
};
/**
 * Find equivalent parent array of an operation
 */
var _equivParentArray = function (dataId, operations) {
    if (!dataId)
        return null;
    var indexes = _indexes(dataId);
    indexes.pop();
    var parentArray = operations;
    for (var _i = 0, indexes_2 = indexes; _i < indexes_2.length; _i++) {
        var index = indexes_2[_i];
        parentArray = parentArray[index].children || parentArray;
    }
    return parentArray;
};
exports._equivParentArray = _equivParentArray;
/**
 * Find an equivalent operation of an element based on its data-id
 */
var _equivOperation = function (dataId, operations) {
    if (!dataId)
        return null;
    var index = _lastIndex(dataId);
    var operationParent = _equivParentArray(dataId, operations);
    if (operationParent == null || //
        index == null)
        return null;
    return operationParent[index];
};
exports._equivOperation = _equivOperation;
/**
 * Move an operation horizontally
 */
var _moveX = function (sourceId, targetId, operations) {
    if (sourceId === targetId)
        return _equivOperation(sourceId, operations);
    var sourceOperation = _equivOperation(sourceId, operations);
    var sourceOperationParent = _equivParentArray(sourceId, operations);
    var targetOperationParent = _equivParentArray(targetId, operations);
    var targetLastIndex = _lastIndex(targetId);
    if (targetOperationParent == null || //
        targetLastIndex == null ||
        sourceOperation == null ||
        sourceOperationParent == null)
        return null;
    // Insert sourceOperation to target last index
    var newSourceOperation = JSON.parse(JSON.stringify(sourceOperation));
    targetOperationParent.splice(targetLastIndex, 0, newSourceOperation);
    // Delete sourceOperation
    sourceOperation.gate = 'removed';
    var indexToRemove = sourceOperationParent.findIndex(function (operation) { return operation.gate === 'removed'; });
    sourceOperationParent.splice(indexToRemove, 1);
    return newSourceOperation;
};
/**
 * Copy an operation horizontally
 */
var _copyX = function (sourceId, targetId, operations) {
    var sourceOperation = _equivOperation(sourceId, operations);
    var sourceOperationParent = _equivParentArray(sourceId, operations);
    var targetOperationParent = _equivParentArray(targetId, operations);
    var targetLastIndex = _lastIndex(targetId);
    if (targetOperationParent == null || //
        targetLastIndex == null ||
        sourceOperation == null ||
        sourceOperationParent == null)
        return null;
    // Insert sourceOperation to target last index
    var newSourceOperation = JSON.parse(JSON.stringify(sourceOperation));
    targetOperationParent.splice(targetLastIndex, 0, newSourceOperation);
    return newSourceOperation;
};
/**
 * Move an operation vertically by changing its controls and targets
 */
var _moveY = function (sourceWire, targetWire, operation, totalWires) {
    if (operation.gate !== 'measure') {
        var offset = parseInt(targetWire) - parseInt(sourceWire);
        _offsetRecursively(operation, offset, totalWires);
    }
    return operation;
};
/**
 * Recursively change object controls and targets
 */
var _offsetRecursively = function (operation, wireOffset, totalWires) {
    // Offset all targets by offsetY value
    if (operation.targets != null) {
        operation.targets.forEach(function (target) {
            target.qId = _circularMod(target.qId, wireOffset, totalWires);
            if (target.cId)
                target.cId = _circularMod(target.cId, wireOffset, totalWires);
        });
    }
    // Offset all controls by offsetY value
    if (operation.controls != null) {
        operation.controls.forEach(function (control) {
            control.qId = _circularMod(control.qId, wireOffset, totalWires);
            if (control.cId)
                control.cId = _circularMod(control.qId, wireOffset, totalWires);
        });
    }
    // Offset recursively through all children
    if (operation.children != null) {
        operation.children.forEach(function (child) { return _offsetRecursively(child, wireOffset, totalWires); });
    }
    return operation;
};
/**
 * Find targets of an operation by recursively walkthrough all of its children controls and targets
 * i.e. Gate Foo contains gate H and gate RX.
 *      qIds of Gate H is 1
 *      qIds of Gate RX is 1, 2
 *      This should return [{qId: 1}, {qId: 2}]
 */
var _targets = function (operation) {
    var _recurse = function (operation) {
        registers.push.apply(registers, operation.targets);
        if (operation.controls) {
            registers.push.apply(registers, operation.controls);
            // If there is more children, keep adding more to registers
            if (operation.children) {
                for (var _i = 0, _a = operation.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    _recurse(child);
                }
            }
        }
    };
    var registers = [];
    if (operation.children == null)
        return [];
    // Recursively walkthrough all children to populate registers
    for (var _i = 0, _a = operation.children; _i < _a.length; _i++) {
        var child = _a[_i];
        _recurse(child);
    }
    // Extract qIds from array of object
    // i.e. [{qId: 0}, {qId: 1}, {qId: 1}] -> [0, 1, 1]
    var qIds = registers.map(function (register) { return register.qId; });
    var uniqueQIds = Array.from(new Set(qIds));
    // Transform array of numbers into array of qId object
    // i.e. [0, 1] -> [{qId: 0}, {qId: 1}]
    return uniqueQIds.map(function (qId) { return ({
        qId: qId,
    }); });
};
/**
 * This modulo function always returns positive value based on total
 * i.e: value=0, offset=-1, total=4 returns 3 instead of -1
 */
var _circularMod = function (value, offset, total) {
    return (((value + offset) % total) + total) % total;
};
/**
 * Split data-id into an array of indexes
 */
var _indexes = function (dataId) {
    return dataId !== '' //
        ? dataId.split('-').map(function (segment) { return parseInt(segment); })
        : [];
};
/**
 * Get the last index of data-id
 * i.e: data-id = "0-1-2", _lastIndex will return 2
 */
var _lastIndex = function (dataId) {
    return _indexes(dataId).pop();
};
exports._lastIndex = _lastIndex;
/**
 * Object exported for unit testing
 */
var exportedForTesting = {
    _wireYs: _wireYs,
    _hostElems: _hostElems,
    _wirePrefixes: _wirePrefixes,
    _center: _center,
    _wireData: _wireData,
    _equivGateElem: _equivGateElem,
    _equivOperation: _equivOperation,
    _equivParentOperation: _equivParentOperation,
    _equivParentArray: _equivParentArray,
    _moveX: _moveX,
    _copyX: _copyX,
    _moveY: _moveY,
    _offsetRecursively: _offsetRecursively,
    _targets: _targets,
    _circularMod: _circularMod,
    _indexes: _indexes,
    _lastIndex: _lastIndex,
};
exports.exportedForTesting = exportedForTesting;
