"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports._classicalControlled = exports._groupedOperations = exports._controlledGate = exports._swap = exports._unitary = exports._measure = exports._zoomButton = exports._createGate = exports._formatGate = exports.formatGates = void 0;
var metadata_1 = require("../metadata");
var constants_1 = require("../constants");
var formatUtils_1 = require("./formatUtils");
/**
 * Given an array of operations (in metadata format), return the SVG representation.
 *
 * @param opsMetadata Array of Metadata representation of operations.
 * @param nestedDepth Depth of nested operations (used in classically controlled and grouped operations).
 *
 * @returns SVG representation of operations.
 */
var formatGates = function (opsMetadata, nestedDepth) {
    if (nestedDepth === void 0) { nestedDepth = 0; }
    var formattedGates = opsMetadata.map(function (metadata) { return _formatGate(metadata, nestedDepth); });
    return (0, formatUtils_1.group)(formattedGates);
};
exports.formatGates = formatGates;
/**
 * Takes in an operation's metadata and formats it into SVG.
 *
 * @param metadata Metadata object representation of gate.
 * @param nestedDepth Depth of nested operations (used in classically controlled and grouped operations).
 *
 * @returns SVG representation of gate.
 */
var _formatGate = function (metadata, nestedDepth) {
    if (nestedDepth === void 0) { nestedDepth = 0; }
    var type = metadata.type, x = metadata.x, controlsY = metadata.controlsY, targetsY = metadata.targetsY, label = metadata.label, displayArgs = metadata.displayArgs, width = metadata.width;
    switch (type) {
        case metadata_1.GateType.Measure:
            return _createGate([_measure(x, controlsY[0])], metadata, nestedDepth);
        case metadata_1.GateType.Unitary:
            return _createGate([_unitary(label, x, targetsY, width, displayArgs)], metadata, nestedDepth);
        case metadata_1.GateType.X:
            return _createGate([_x(metadata, nestedDepth)], metadata, nestedDepth);
        case metadata_1.GateType.Swap:
            return controlsY.length > 0
                ? _controlledGate(metadata, nestedDepth)
                : _createGate([_swap(metadata, nestedDepth)], metadata, nestedDepth);
        case metadata_1.GateType.Cnot:
        case metadata_1.GateType.ControlledUnitary:
            return _controlledGate(metadata, nestedDepth);
        case metadata_1.GateType.Group:
            return _groupedOperations(metadata, nestedDepth);
        case metadata_1.GateType.ClassicalControlled:
            return _classicalControlled(metadata);
        default:
            throw new Error("ERROR: unknown gate (".concat(label, ") of type ").concat(type, "."));
    }
};
exports._formatGate = _formatGate;
/**
 * Groups SVG elements into a gate SVG group.
 *
 * @param svgElems       Array of SVG elements.
 * @param dataAttributes Custom data attributes to be attached to SVG group.
 *
 * @returns SVG representation of a gate.
 */
var _createGate = function (svgElems, metadata, nestedDepth) {
    var dataAttributes = (metadata || {}).dataAttributes;
    var attributes = { class: 'gate' };
    Object.entries(dataAttributes || {}).forEach(function (_a) {
        var attr = _a[0], val = _a[1];
        return (attributes["data-".concat(attr)] = val);
    });
    var zoomBtn = _zoomButton(metadata, nestedDepth);
    if (zoomBtn != null)
        svgElems = svgElems.concat([zoomBtn]);
    return (0, formatUtils_1.group)(svgElems, attributes);
};
exports._createGate = _createGate;
/**
 * Returns the expand/collapse button for an operation if it can be zoomed-in or zoomed-out,
 * respectively. If neither are allowed, return `null`.
 *
 * @param metadata Operation metadata.
 * @param nestedDepth Depth of nested operation.
 *
 * @returns SVG element for expand/collapse button if needed, or null otherwise.
 */
var _zoomButton = function (metadata, nestedDepth) {
    if (metadata == undefined)
        return null;
    var _a = _gatePosition(metadata, nestedDepth), x1 = _a[0], y1 = _a[1];
    var dataAttributes = metadata.dataAttributes;
    dataAttributes = dataAttributes || {};
    var expanded = 'expanded' in dataAttributes;
    var x = x1 + 2;
    var y = y1 + 2;
    var circleBorder = (0, formatUtils_1.circle)(x, y, 10);
    if (expanded) {
        // Create collapse button if expanded
        var minusSign = (0, formatUtils_1.createSvgElement)('path', { d: "M".concat(x - 7, ",").concat(y, " h14") });
        var elements = [circleBorder, minusSign];
        return (0, formatUtils_1.group)(elements, { class: 'gate-control gate-collapse' });
    }
    else if (dataAttributes['zoom-in'] == 'true') {
        // Create expand button if operation can be zoomed in
        var plusSign = (0, formatUtils_1.createSvgElement)('path', { d: "M".concat(x, ",").concat(y - 7, " v14 M").concat(x - 7, ",").concat(y, " h14") });
        var elements = [circleBorder, plusSign];
        return (0, formatUtils_1.group)(elements, { class: 'gate-control gate-expand' });
    }
    return null;
};
exports._zoomButton = _zoomButton;
/**
 * Calculate position of gate.
 *
 * @param metadata Operation metadata.
 * @param nestedDepth Depth of nested operations.
 *
 * @returns Coordinates of gate: [x1, y1, x2, y2].
 */
var _gatePosition = function (metadata, nestedDepth) {
    var x = metadata.x, width = metadata.width, type = metadata.type, targetsY = metadata.targetsY;
    var ys = (targetsY === null || targetsY === void 0 ? void 0 : targetsY.flatMap(function (y) { return y; })) || [];
    var maxY = Math.max.apply(Math, ys);
    var minY = Math.min.apply(Math, ys);
    var x1, y1, x2, y2;
    switch (type) {
        case metadata_1.GateType.Group:
            var padding = constants_1.groupBoxPadding - nestedDepth * constants_1.nestedGroupPadding;
            x1 = x - 2 * padding;
            y1 = minY - constants_1.gateHeight / 2 - padding;
            x2 = width + 2 * padding;
            y2 = maxY + +constants_1.gateHeight / 2 + padding - (minY - constants_1.gateHeight / 2 - padding);
            return [x1, y1, x2, y2];
        default:
            x1 = x - width / 2;
            y1 = minY - constants_1.gateHeight / 2;
            x2 = x + width;
            y2 = maxY + constants_1.gateHeight / 2;
    }
    return [x1, y1, x2, y2];
};
/**
 * Creates a measurement gate at position (x, y).
 *
 * @param x  x coord of measurement gate.
 * @param y  y coord of measurement gate.
 *
 * @returns SVG representation of measurement gate.
 */
var _measure = function (x, y) {
    x -= constants_1.minGateWidth / 2;
    var width = constants_1.minGateWidth, height = constants_1.gateHeight;
    // Draw measurement box
    var mBox = (0, formatUtils_1.box)(x, y - height / 2, width, height, 'gate-measure');
    var mArc = (0, formatUtils_1.arc)(x + 5, y + 2, width / 2 - 5, height / 2 - 8);
    var meter = (0, formatUtils_1.line)(x + width / 2, y + 8, x + width - 8, y - height / 2 + 8);
    return (0, formatUtils_1.group)([mBox, mArc, meter]);
};
exports._measure = _measure;
/**
 * Creates the SVG for a unitary gate on an arbitrary number of qubits.
 *
 * @param label            Gate label.
 * @param x                x coord of gate.
 * @param y                Array of y coords of registers acted upon by gate.
 * @param width            Width of gate.
 * @param displayArgs           Arguments passed in to gate.
 * @param renderDashedLine If true, draw dashed lines between non-adjacent unitaries.
 *
 * @returns SVG representation of unitary gate.
 */
var _unitary = function (label, x, y, width, displayArgs, renderDashedLine) {
    if (renderDashedLine === void 0) { renderDashedLine = true; }
    if (y.length === 0)
        throw new Error("Failed to render unitary gate (".concat(label, "): has no y-values"));
    // Render each group as a separate unitary boxes
    var unitaryBoxes = y.map(function (group) {
        var maxY = group[group.length - 1], minY = group[0];
        var height = maxY - minY + constants_1.gateHeight;
        return _unitaryBox(label, x, minY, width, height, displayArgs);
    });
    // Draw dashed line between disconnected unitaries
    if (renderDashedLine && unitaryBoxes.length > 1) {
        var lastBox = y[y.length - 1];
        var firstBox = y[0];
        var maxY = lastBox[lastBox.length - 1], minY = firstBox[0];
        var vertLine = (0, formatUtils_1.dashedLine)(x, minY, x, maxY);
        return (0, formatUtils_1.group)(__spreadArray([vertLine], unitaryBoxes, true));
    }
    return (0, formatUtils_1.group)(unitaryBoxes);
};
exports._unitary = _unitary;
/**
 * Generates SVG representation of the boxed unitary gate symbol.
 *
 * @param label  Label for unitary operation.
 * @param x      x coord of gate.
 * @param y      y coord of gate.
 * @param width  Width of gate.
 * @param height Height of gate.
 * @param displayArgs Arguments passed in to gate.
 *
 * @returns SVG representation of unitary box.
 */
var _unitaryBox = function (label, x, y, width, height, displayArgs) {
    if (height === void 0) { height = constants_1.gateHeight; }
    y -= constants_1.gateHeight / 2;
    var uBox = (0, formatUtils_1.box)(x - width / 2, y, width, height);
    var labelY = y + height / 2 - (displayArgs == null ? 0 : 7);
    var labelText = (0, formatUtils_1.text)(label, x, labelY);
    var elems = [uBox, labelText];
    if (displayArgs != null) {
        var argStrY = y + height / 2 + 8;
        var argText = (0, formatUtils_1.text)(displayArgs, x, argStrY, constants_1.argsFontSize);
        elems.push(argText);
    }
    return (0, formatUtils_1.group)(elems);
};
/**
 * Creates the SVG for a SWAP gate on y coords given by targetsY.
 *
 * @param x          Centre x coord of SWAP gate.
 * @param targetsY   y coords of target registers.
 *
 * @returns SVG representation of SWAP gate.
 */
var _swap = function (metadata, nestedDepth) {
    var x = metadata.x, targetsY = metadata.targetsY;
    // Get SVGs of crosses
    var _a = _gatePosition(metadata, nestedDepth), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];
    var ys = (targetsY === null || targetsY === void 0 ? void 0 : targetsY.flatMap(function (y) { return y; })) || [];
    var bg = (0, formatUtils_1.box)(x1, y1, x2, y2, 'gate-swap');
    var crosses = ys.map(function (y) { return _cross(x, y); });
    var vertLine = (0, formatUtils_1.line)(x, ys[0], x, ys[1]);
    return (0, formatUtils_1.group)(__spreadArray(__spreadArray([bg], crosses, true), [vertLine], false));
};
exports._swap = _swap;
/**
 * Creates the SVG for an X gate
 *
 * @returns SVG representation of X gate.
 */
var _x = function (metadata, _) {
    var x = metadata.x, targetsY = metadata.targetsY;
    var ys = targetsY.flatMap(function (y) { return y; });
    return _oplus(x, ys[0]);
};
/**
 * Generates cross for display in SWAP gate.
 *
 * @param x x coord of gate.
 * @param y y coord of gate.
 *
 * @returns SVG representation for cross.
 */
var _cross = function (x, y) {
    var radius = 8;
    var line1 = (0, formatUtils_1.line)(x - radius, y - radius, x + radius, y + radius);
    var line2 = (0, formatUtils_1.line)(x - radius, y + radius, x + radius, y - radius);
    return (0, formatUtils_1.group)([line1, line2]);
};
/**
 * Produces the SVG representation of a controlled gate on multiple qubits.
 *
 * @param metadata Metadata of controlled gate.
 *
 * @returns SVG representation of controlled gate.
 */
var _controlledGate = function (metadata, nestedDepth) {
    var targetGateSvgs = [];
    var type = metadata.type, x = metadata.x, controlsY = metadata.controlsY, label = metadata.label, displayArgs = metadata.displayArgs, width = metadata.width;
    var targetsY = metadata.targetsY;
    // Get SVG for target gates
    switch (type) {
        case metadata_1.GateType.Cnot:
            targetsY.forEach(function (y) { return targetGateSvgs.push(_oplus(x, y)); });
            break;
        case metadata_1.GateType.Swap:
            targetsY.forEach(function (y) { return targetGateSvgs.push(_cross(x, y)); });
            break;
        case metadata_1.GateType.ControlledUnitary:
            var groupedTargetsY = targetsY;
            targetGateSvgs.push(_unitary(label, x, groupedTargetsY, width, displayArgs, false));
            targetsY = targetsY.flat();
            break;
        default:
            throw new Error("ERROR: Unrecognized gate: ".concat(label, " of type ").concat(type));
    }
    // Get SVGs for control dots
    var controlledDotsSvg = controlsY.map(function (y) { return (0, formatUtils_1.controlDot)(x, y); });
    // Create control lines
    var maxY = Math.max.apply(Math, __spreadArray(__spreadArray([], controlsY, false), targetsY, false));
    var minY = Math.min.apply(Math, __spreadArray(__spreadArray([], controlsY, false), targetsY, false));
    var vertLine = (0, formatUtils_1.line)(x, minY, x, maxY);
    var svg = _createGate(__spreadArray(__spreadArray([vertLine], controlledDotsSvg, true), targetGateSvgs, true), metadata, nestedDepth);
    return svg;
};
exports._controlledGate = _controlledGate;
/**
 * Generates $\oplus$ symbol for display in CNOT gate.
 *
 * @param x x coordinate of gate.
 * @param y y coordinate of gate.
 * @param r radius of circle.
 *
 * @returns SVG representation of $\oplus$ symbol.
 */
var _oplus = function (x, y, r) {
    if (r === void 0) { r = 15; }
    var circleBorder = (0, formatUtils_1.circle)(x, y, r);
    var vertLine = (0, formatUtils_1.line)(x, y - r, x, y + r);
    var horLine = (0, formatUtils_1.line)(x - r, y, x + r, y);
    return (0, formatUtils_1.group)([circleBorder, vertLine, horLine], { class: 'oplus' });
};
/**
 * Generates the SVG for a group of nested operations.
 *
 * @param metadata Metadata representation of gate.
 * @param nestedDepth Depth of nested operations (used in classically controlled and grouped operations).
 *
 * @returns SVG representation of gate.
 */
var _groupedOperations = function (metadata, nestedDepth) {
    var children = metadata.children;
    var _a = _gatePosition(metadata, nestedDepth), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];
    // Draw dashed box around children gates
    var box = (0, formatUtils_1.dashedBox)(x1, y1, x2, y2);
    var elems = [box];
    if (children != null)
        elems.push(formatGates(children, nestedDepth + 1));
    return _createGate(elems, metadata, nestedDepth);
};
exports._groupedOperations = _groupedOperations;
/**
 * Generates the SVG for a classically controlled group of operations.
 *
 * @param metadata Metadata representation of gate.
 * @param padding  Padding within dashed box.
 *
 * @returns SVG representation of gate.
 */
var _classicalControlled = function (metadata, padding) {
    if (padding === void 0) { padding = constants_1.groupBoxPadding; }
    var controlsY = metadata.controlsY, dataAttributes = metadata.dataAttributes;
    var targetsY = metadata.targetsY;
    var children = metadata.children;
    var x = metadata.x, width = metadata.width;
    var controlY = controlsY[0];
    var elems = [];
    if (children != null) {
        if (children.length !== 2)
            throw new Error("Invalid number of children found for classically-controlled gate: ".concat(children.length));
        // Get SVG for gates controlled on 0
        var childrenZero = formatGates(children[0]);
        childrenZero.setAttribute('class', 'gates-zero');
        elems.push(childrenZero);
        // Get SVG for gates controlled on 1
        var childrenOne = formatGates(children[1]);
        childrenOne.setAttribute('class', 'gates-one');
        elems.push(childrenOne);
    }
    // Draw control button and attached dashed line to dashed box
    var controlCircleX = x + constants_1.controlBtnRadius;
    var controlCircle = _controlCircle(controlCircleX, controlY);
    var lineY1 = controlY + constants_1.controlBtnRadius, lineY2 = controlY + constants_1.classicalRegHeight / 2;
    var vertLine = (0, formatUtils_1.dashedLine)(controlCircleX, lineY1, controlCircleX, lineY2, 'classical-line');
    x += constants_1.controlBtnOffset;
    var horLine = (0, formatUtils_1.dashedLine)(controlCircleX, lineY2, x, lineY2, 'classical-line');
    width = width - constants_1.controlBtnOffset + (padding - constants_1.groupBoxPadding) * 2;
    x += constants_1.groupBoxPadding - padding;
    var y = targetsY[0] - constants_1.gateHeight / 2 - padding;
    var height = targetsY[1] - targetsY[0] + constants_1.gateHeight + padding * 2;
    // Draw dashed box around children gates
    var box = (0, formatUtils_1.dashedBox)(x, y, width, height, 'classical-container');
    elems.push.apply(elems, [horLine, vertLine, controlCircle, box]);
    // Display controlled operation in initial "unknown" state
    var attributes = {
        class: "classically-controlled-group classically-controlled-unknown",
    };
    if (dataAttributes != null)
        Object.entries(dataAttributes).forEach(function (_a) {
            var attr = _a[0], val = _a[1];
            return (attributes["data-".concat(attr)] = val);
        });
    return (0, formatUtils_1.group)(elems, attributes);
};
exports._classicalControlled = _classicalControlled;
/**
 * Generates the SVG representation of the control circle on a classical register with interactivity support
 * for toggling between bit values (unknown, 1, and 0).
 *
 * @param x   x coord.
 * @param y   y coord.
 * @param r   Radius of circle.
 *
 * @returns SVG representation of control circle.
 */
var _controlCircle = function (x, y, r) {
    if (r === void 0) { r = constants_1.controlBtnRadius; }
    return (0, formatUtils_1.group)([(0, formatUtils_1.circle)(x, y, r), (0, formatUtils_1.text)('?', x, y, constants_1.labelFontSize)], { class: 'classically-controlled-btn' });
};
