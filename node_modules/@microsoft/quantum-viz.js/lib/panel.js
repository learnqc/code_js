"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.exportedForTesting = exports.extensionPanel = void 0;
var cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
var range_1 = __importDefault(require("lodash/range"));
var constants_1 = require("./constants");
var draggable_1 = require("./draggable");
var gateFormatter_1 = require("./formatters/gateFormatter");
var metadata_1 = require("./metadata");
var utils_1 = require("./utils");
/**
 * Object to maintain global state of extensionPanel
 */
var context = {
    addMode: true,
    operations: [],
    operation: undefined,
    registerSize: 0,
    container: undefined,
};
/**
 * Entry point to run extensionPanel
 * @param options   User-provided object to customize extensionPanel
 * @returns         Curried function of entry point to run extensionPanel
 */
var extensionPanel = function (options) {
    /**
     * Curried function of entry point to run extensionPanel
     * @param container     HTML element for rendering visualization into
     * @param sqore         Sqore object
     * @param useRefresh    Function to trigger circuit re-rendering
     */
    return function (container, sqore, useRefresh) {
        var dispatch = function (action) {
            update(action, context, useRefresh);
            var panelElem = panel(dispatch, context, options);
            var prevPanelElem = container.querySelector('.panel');
            prevPanelElem && container.replaceChild(panelElem, prevPanelElem);
        };
        addEvents(dispatch, container, sqore);
        var panelElem = panel(dispatch, context, options);
        var prevPanelElem = container.querySelector('.panel');
        prevPanelElem == null && container.prepend(panelElem);
    };
};
exports.extensionPanel = extensionPanel;
/**
 * Function to handle all event listeners
 * @param dispatch      Function to update state and trigger panel re-rendering
 * @param container     HTML element for rendering visualization into
 * @param sqore         Sqore object
 */
var addEvents = function (dispatch, container, sqore) {
    var _a;
    // Gates in SVG circuit are selectable
    var elems = container.querySelectorAll('[data-id]');
    elems.forEach(function (elem) {
        return elem.addEventListener('mousedown', function (ev) {
            ev.stopImmediatePropagation();
            var dataId = elem.getAttribute('data-id');
            var operation = draggable_1._equivOperation(dataId, sqore.circuit.operations);
            dispatch({ type: 'OPERATION', payload: operation });
            dispatch({ type: 'EDIT_MODE' });
        });
    });
    // Context is updated when mouse is over container
    container.addEventListener('mouseover', function () {
        context.registerSize = sqore.circuit.qubits.length;
        context.operations = sqore.circuit.operations;
        context.container = container;
    });
    // addMode triggers
    var svgElem = container.querySelector('svg[id]');
    svgElem === null || svgElem === void 0 ? void 0 : svgElem.addEventListener('mousedown', function () {
        dispatch({ type: 'ADD_MODE' });
    });
    // Drag and drop
    var dropzoneLayer = container.querySelector('.dropzone-layer');
    var dropzoneElems = dropzoneLayer.querySelectorAll('.dropzone');
    dropzoneElems.forEach(function (dropzoneElem) {
        return dropzoneElem.addEventListener('mouseup', function () {
            if (context.operation && //
                context.addMode) {
                var targetId = dropzoneElem.getAttribute('data-dropzone-id');
                var targetWire = dropzoneElem.getAttribute('data-dropzone-wire');
                dispatch({ type: 'ADD_OPERATION', payload: targetId });
                dispatch({ type: 'TARGET', payload: [{ qId: parseInt(targetWire || '') }] });
            }
        });
    });
    // Remove ghost element if drops gate in svgElement
    svgElem === null || svgElem === void 0 ? void 0 : svgElem.addEventListener('mouseup', function () {
        dispatch({ type: 'REMOVE_GHOST_ELEMENT' });
    });
    // Remove ghost element if drops gate in addPanel
    (_a = container.querySelector('.add-panel')) === null || _a === void 0 ? void 0 : _a.addEventListener('mouseup', function () {
        dispatch({ type: 'REMOVE_GHOST_ELEMENT' });
    });
};
/**
 * Primary function for state management
 * @param action        Object to have type and payload
 * @param context       Context object to manage extension state
 * @param useRefresh    Function to trigger circuit re-rendering
 */
var update = function (action, context, useRefresh) {
    switch (action.type) {
        case 'ADD_MODE': {
            context.addMode = true;
            break;
        }
        case 'EDIT_MODE': {
            context.addMode = false;
            break;
        }
        case 'OPERATION': {
            context.operation = action.payload;
            break;
        }
        case 'TARGET': {
            var operation = context.operation;
            var payload = action.payload;
            operation && (operation.targets = payload);
            useRefresh();
            break;
        }
        case 'CONTROLS': {
            var operation = context.operation;
            if (operation) {
                var payload = action.payload;
                operation.controls = payload;
                operation.isControlled = payload.length > 0 ? true : false;
            }
            useRefresh();
            break;
        }
        case 'DISPLAY_ARGS': {
            var operation = context.operation;
            operation && (operation.displayArgs = action.payload);
            useRefresh();
            break;
        }
        case 'ADD_OPERATION': {
            var targetId = action.payload;
            var targetOperationParent = draggable_1._equivParentArray(targetId, context.operations);
            var targetLastIndex = draggable_1._lastIndex(targetId);
            if (targetOperationParent != null && //
                targetLastIndex != null &&
                context.operation != null) {
                targetOperationParent.splice(targetLastIndex, 0, context.operation);
            }
            useRefresh();
            break;
        }
        case 'DISPLAY_DROPZONE_LAYER': {
            var container = context.container;
            if (container) {
                var dropzoneLayer = container.querySelector('.dropzone-layer');
                dropzoneLayer.style.display = 'block';
            }
            break;
        }
        case 'DISPLAY_CURSOR_MOVING': {
            var container = context.container;
            container && container.classList.add('moving');
            break;
        }
        case 'DISPLAY_GHOST_ELEMENT': {
            var handleMouseMove = function (ev) {
                divElem_1.style.left = ev.clientX - constants_1.minGateWidth / 2 + "px";
                divElem_1.style.top = ev.clientY - constants_1.gateHeight / 2 + "px";
            };
            var container = context.container;
            var _a = action.payload, ghostElem = _a.ghostElem, initX = _a.initX, initY = _a.initY;
            // Generate svg element to wrap around ghost element
            var svgElem = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svgElem.append(ghostElem);
            // Generate div element to wrap around svg element
            var divElem_1 = elem('div', 'ghost');
            divElem_1.style.left = initX - constants_1.minGateWidth / 2 + "px";
            divElem_1.style.top = initY - constants_1.gateHeight / 2 + "px";
            divElem_1.appendChild(svgElem);
            if (container) {
                container.appendChild(divElem_1);
                container.addEventListener('mousemove', handleMouseMove);
            }
            break;
        }
        case 'REMOVE_GHOST_ELEMENT': {
            var container = context.container;
            if (container) {
                var ghostElem = container.querySelector('.ghost');
                ghostElem && container.removeChild(ghostElem);
            }
        }
    }
};
/**
 * Function to produce panel element
 * @param dispatch      Function to update state and trigger panel re-rendering
 * @param context       Context object to manage extension state
 * @param options       User-provided object to customize extensionPanel
 * @returns             HTML element for panel
 */
var panel = function (dispatch, context, options) {
    var panelElem = elem('div');
    panelElem.className = 'panel';
    children(panelElem, [
        context.addMode //
            ? addPanel(dispatch, context, options)
            : editPanel(dispatch, context),
    ]);
    return panelElem;
};
/**
 * Function to produce addPanel element
 * @param dispatch      Function to update state and trigger panel re-rendering
 * @param context       Context object to manage extension state
 * @param options       User-provided object to customize extensionPanel
 * @returns             HTML element for addPanel
 */
var addPanel = function (dispatch, context, options) {
    var gateDictionary = defaultGateDictionary;
    var objectKeys = Object.keys(gateDictionary);
    if (options != null) {
        var displaySize = options.displaySize, optionGateDictionary = options.gateDictionary;
        displaySize && (objectKeys = objectKeys.slice(0, displaySize));
        optionGateDictionary && (gateDictionary = optionGateDictionary);
    }
    var prefixX = 0;
    var prefixY = 0;
    var gateElems = objectKeys.map(function (key) {
        var gateWidth = toMetadata(gateDictionary[key], 0, 0).width;
        if (prefixX + gateWidth + constants_1.horizontalGap > constants_1.panelWidth) {
            prefixX = 0;
            prefixY += constants_1.gateHeight + constants_1.verticalGap;
        }
        var gateElem = gate(dispatch, gateDictionary, key.toString(), prefixX, prefixY);
        prefixX += gateWidth + constants_1.horizontalGap;
        return gateElem;
    });
    // Generate svg container to store gate elements
    var svgElem = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svgElem.classList.add('add-panel-svg');
    childrenSvg(svgElem, gateElems);
    // Generate add panel
    var addPanelElem = elem('div', 'add-panel');
    children(addPanelElem, [title('ADD')]);
    addPanelElem.appendChild(svgElem);
    return addPanelElem;
};
/**
 * Function to produce editPanel element
 * @param dispatch      Function to update state and trigger panel re-rendering
 * @param context       Context object to manage extension state
 * @returns             HTML element for editPanel
 */
var editPanel = function (dispatch, context) {
    var _a;
    var operation = context.operation, registerSize = context.registerSize;
    var options = range_1.default(registerSize).map(function (i) { return ({ value: "" + i, text: "q" + i }); });
    var target = operation === null || operation === void 0 ? void 0 : operation.targets[0].qId;
    var controls = (_a = operation === null || operation === void 0 ? void 0 : operation.controls) === null || _a === void 0 ? void 0 : _a.map(function (control) { return control.qId; });
    var editPanelElem = elem('div', 'edit-panel');
    children(editPanelElem, [
        title('EDIT'),
        select('Target', 'target-input', options, target || 0, dispatch, operation),
        checkboxes('Controls', 'controls-input', options, controls || [], dispatch, operation),
        text('Display', 'display-input', dispatch, operation),
    ]);
    return editPanelElem;
};
/**
 * Factory function to produce HTML element
 * @param tag       Tag name
 * @param className Class name
 * @returns         HTML element
 */
var elem = function (tag, className) {
    var _elem = document.createElement(tag);
    className && (_elem.className = className);
    return _elem;
};
/**
 * Append all child elements to a parent HTML element
 * @param parentElem    Parent HTML element
 * @param childElems    Array of HTML child elements
 * @returns             Parent HTML element with all children appended
 */
var children = function (parentElem, childElems) {
    childElems.map(function (elem) { return parentElem.appendChild(elem); });
    return parentElem;
};
/**
 * Append all child elements to a parent SVG element
 * @param parentElem    Parent SVG element
 * @param childElems    Array of SVG child elements
 * @returns             Parent SVG element with all children appended
 */
var childrenSvg = function (parentElem, childElems) {
    childElems.map(function (elem) { return parentElem.appendChild(elem); });
    return parentElem;
};
/**
 * Function to produce title element
 * @param text  Text
 * @returns     Title element
 */
var title = function (text) {
    var titleElem = elem('h2');
    titleElem.className = 'title';
    titleElem.textContent = text;
    return titleElem;
};
/**
 * Function to produce select element
 * @param label         Label
 * @param className     Class name
 * @param options       Array of Option objects contain value and text
 * @param selectedIndex Index of current selected option
 * @param dispatch      Function to update state and trigger panel re-rendering
 * @param operation     Optional Operation object
 * @returns             Select element
 */
var select = function (label, className, options, selectedIndex, dispatch, operation) {
    var optionElems = options.map(function (_a) {
        var value = _a.value, text = _a.text;
        return option(value, text);
    });
    var selectElem = elem('select');
    children(selectElem, optionElems);
    operation == undefined && selectElem.setAttribute('disabled', 'true');
    selectElem.selectedIndex = selectedIndex;
    var labelElem = elem('label');
    labelElem.className = 'block';
    labelElem.textContent = label;
    var divElem = elem('div');
    divElem.className = className;
    children(divElem, [labelElem, selectElem]);
    selectElem.onchange = function () {
        dispatch({ type: 'TARGET', payload: [{ qId: parseInt(selectElem.value) }] });
    };
    return divElem;
};
/**
 * Function to produce option element
 * @param value Value
 * @param text  Text
 * @returns     Option element
 */
var option = function (value, text) {
    var optionElem = elem('option');
    optionElem.value = value;
    optionElem.textContent = text;
    return optionElem;
};
/**
 * Function to produce checkbox elements
 * @param label             Label
 * @param className         Class name
 * @param options           Array of Option objects contain value and text
 * @param selectedIndexes   Array of indexes of current selected options
 * @param dispatch          Function to update state and trigger panel re-rendering
 * @param operation         Optional Operation object
 * @returns                 Parent div containing checkbox elements
 */
var checkboxes = function (label, className, options, selectedIndexes, dispatch, operation) {
    var checkboxElems = options.map(function (option, index) {
        var elem = checkbox(option.value, option.text);
        var inputElem = elem.querySelector('input');
        selectedIndexes.includes(index) && inputElem.setAttribute('checked', 'true');
        operation == undefined && inputElem.setAttribute('disabled', 'true');
        inputElem.onchange = function () {
            // Get all checked options
            var checkedElems = Array.from(divElem.querySelectorAll('input:checked'));
            // Generate new controls from checked options
            var newControls = checkedElems.map(function (elem) { return ({
                qId: parseInt(elem.value),
            }); });
            // Dispatch new controls
            dispatch({ type: 'CONTROLS', payload: newControls });
        };
        return elem;
    });
    var labelElem = elem('label');
    labelElem.className = 'block';
    labelElem.textContent = label;
    var divElem = elem('div');
    divElem.className = className;
    children(divElem, __spreadArrays([labelElem], checkboxElems));
    return divElem;
};
/**
 * Function to produce checkbox element
 * @param value Value
 * @param text  Text
 * @returns     Checkbox element
 */
var checkbox = function (value, text) {
    var inputElem = elem('input');
    inputElem.type = 'checkbox';
    inputElem.value = value;
    var labelElem = elem('label');
    labelElem.textContent = text;
    labelElem.prepend(inputElem);
    return labelElem;
};
/**
 * Function to produce input text element
 * @param label     Label
 * @param className Class name
 * @param dispatch  Function to update state and trigger panel re-rendering
 * @param operation Optional Operation object
 * @returns         Parent div containing input text element
 */
var text = function (label, className, dispatch, operation) {
    var labelElem = elem('label');
    labelElem.className = 'block';
    labelElem.textContent = label;
    var textElem = elem('input');
    operation == undefined && textElem.setAttribute('disabled', 'true');
    textElem.type = 'text';
    textElem.value = (operation === null || operation === void 0 ? void 0 : operation.displayArgs) || '';
    textElem.setAttribute('autofocus', 'true');
    textElem.onchange = function () {
        dispatch({ type: 'DISPLAY_ARGS', payload: textElem.value });
    };
    var divElem = elem('div');
    divElem.className = className;
    children(divElem, [labelElem, textElem]);
    return divElem;
};
/**
 * Wrapper to generate metadata based on _opToMetadata with mock registers and limited support
 * @param operation     Operation object
 * @param x             x coordinate at starting point from the left
 * @param y             y coordinate at starting point from the top
 * @returns             Metata object
 */
var toMetadata = function (operation, x, y) {
    var metadata = {
        type: metadata_1.GateType.Invalid,
        x: x + 1 + constants_1.minGateWidth / 2,
        controlsY: [],
        targetsY: [y + 1 + constants_1.gateHeight / 2],
        label: '',
        width: -1,
    };
    if (operation == null)
        return metadata;
    var gate = operation.gate, displayArgs = operation.displayArgs, isMeasurement = operation.isMeasurement, 
    // isConditional,
    isControlled = operation.isControlled;
    if (isMeasurement) {
        metadata.type = metadata_1.GateType.Measure;
    }
    else if (gate === 'SWAP') {
        metadata.type = metadata_1.GateType.Swap;
    }
    else if (isControlled) {
        metadata.type = gate === 'X' ? metadata_1.GateType.Cnot : metadata_1.GateType.ControlledUnitary;
        metadata.label = gate;
    }
    else if (gate === 'X') {
        metadata.type = metadata_1.GateType.X;
        metadata.label = gate;
    }
    else {
        metadata.type = metadata_1.GateType.Unitary;
        metadata.label = gate;
        metadata.targetsY = [[y + 1 + constants_1.gateHeight / 2]];
        // GateType.Unitary wants matrix array. Also, offset by 1 for top padding
    }
    if (displayArgs != null)
        metadata.displayArgs = displayArgs;
    metadata.width = utils_1.getGateWidth(metadata);
    metadata.x = x + 1 + metadata.width / 2; // offset by 1 for left padding
    return metadata;
};
/**
 * Generate gate element for Add Panel based on type of gate
 * @param dispatch  Function to update state and trigger panel re-rendering
 * @param type      Type of gate. Example: 'H' or 'X'
 */
var gate = function (dispatch, gateDictionary, type, x, y) {
    var operation = gateDictionary[type];
    if (operation == null)
        throw new Error("Gate " + type + " not available");
    var metadata = toMetadata(operation, x, y);
    var gateElem = gateFormatter_1._formatGate(metadata).cloneNode(true);
    gateElem.addEventListener('mousedown', function (ev) {
        // Generate equivalent ghost element with x and y at 0
        var ghostMetadata = toMetadata(operation, 0, 0);
        var ghostElem = gateFormatter_1._formatGate(ghostMetadata).cloneNode(true);
        // Get initial x and y position from 'mousedown' event
        var initX = ev.clientX, initY = ev.clientY;
        // Dispatch relevant events
        dispatch({ type: 'OPERATION', payload: cloneDeep_1.default(operation) });
        dispatch({ type: 'DISPLAY_DROPZONE_LAYER' });
        dispatch({ type: 'DISPLAY_CURSOR_MOVING', payload: true });
        dispatch({ type: 'DISPLAY_GHOST_ELEMENT', payload: { ghostElem: ghostElem, initX: initX, initY: initY } });
    });
    return gateElem;
};
/**
 * Object for default gate dictionary
 */
var defaultGateDictionary = {
    Entangle: {
        gate: 'Entangle',
        targets: [{ qId: 0 }],
    },
    RX: {
        gate: 'RX',
        targets: [{ qId: 0 }],
    },
    RY: {
        gate: 'RY',
        targets: [{ qId: 0 }],
    },
    RZ: {
        gate: 'RZ',
        targets: [{ qId: 0 }],
    },
    H: {
        gate: 'H',
        targets: [{ qId: 0 }],
    },
    X: {
        gate: 'X',
        targets: [{ qId: 0 }],
    },
    S: {
        gate: 'S',
        targets: [{ qId: 0 }],
    },
    T: {
        gate: 'T',
        targets: [{ qId: 0 }],
    },
    Y: {
        gate: 'Y',
        targets: [{ qId: 0 }],
    },
    Z: {
        gate: 'Z',
        targets: [{ qId: 0 }],
    },
    ZZ: {
        gate: 'ZZ',
        targets: [{ qId: 0 }],
    },
};
/**
 * Object exported for unit testing
 */
var exportedForTesting = {
    panel: panel,
    addPanel: addPanel,
    editPanel: editPanel,
    elem: elem,
    children: children,
    childrenSvg: childrenSvg,
    title: title,
    select: select,
    option: option,
    checkboxes: checkboxes,
    checkbox: checkbox,
    text: text,
    toMetadata: toMetadata,
    gate: gate,
    defaultGateDictionary: defaultGateDictionary,
};
exports.exportedForTesting = exportedForTesting;
