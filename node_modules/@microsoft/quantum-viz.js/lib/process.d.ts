import { Operation } from './circuit';
import { Metadata } from './metadata';
import { Register, RegisterMap } from './register';
/**
 * Takes in a list of operations and maps them to `metadata` objects which
 * contains information for formatting the corresponding SVG.
 *
 * @param operations Array of operations.
 * @param registers  Mapping from qubit IDs to register metadata.
 *
 * @returns An object containing `metadataList` (Array of Metadata objects) and
 *          `svgWidth` which is the width of the entire SVG.
 */
declare const processOperations: (operations: Operation[], registers: RegisterMap) => {
    metadataList: Metadata[];
    svgWidth: number;
};
/**
 * Group gates provided by operations into their respective registers.
 *
 * @param operations Array of operations.
 * @param numRegs    Total number of registers.
 *
 * @returns 2D array of indices where `groupedOps[i][j]` is the index of the operations
 *          at register `i` and column `j` (not yet aligned/padded).
 */
declare const _groupOperations: (operations: Operation[], registers: RegisterMap) => number[][];
/**
 * Aligns operations by padding registers with `null`s to make sure that multiqubit
 * gates are in the same column.
 * e.g. ---[x]---[x]--
 *      ----------|---
 *
 * @param ops 2D array of operations. Each row represents a register
 *            and the operations acting on it (in-order).
 *
 * @returns 2D array of aligned operations padded with `null`s.
 */
declare const _alignOps: (ops: number[][]) => (number | null)[][];
/**
 * Retrieves the starting index of each classical register.
 *
 * @param ops     Array of operations.
 * @param idxList 2D array of aligned operation indices.
 *
 * @returns Array of classical register and their starting column indices in the form [[column, register]].
 */
declare const _getClassicalRegStart: (ops: Operation[], idxList: (number | null)[][]) => [number, Register][];
/**
 * Maps operation to metadata (e.g. gate type, position, dimensions, text)
 * required to render the image.
 *
 * @param op        Operation to be mapped into metadata format.
 * @param registers Array of registers.
 *
 * @returns Metadata representation of given operation.
 */
declare const _opToMetadata: (op: Operation | null, registers: RegisterMap) => Metadata;
/**
 * Compute the y coord of a given register.
 *
 * @param reg       Register to compute y coord of.
 * @param registers Map of qubit IDs to RegisterMetadata.
 *
 * @returns The y coord of give register.
 */
declare const _getRegY: (reg: Register, registers: RegisterMap) => number;
/**
 * Splits `targets` if non-adjacent or intersected by classical registers.
 *
 * @param targets       Target qubit registers.
 * @param classicalRegY y coords of classical registers overlapping current column.
 * @param registers     Mapping from register qubit IDs to register metadata.
 *
 * @returns Groups of target qubit y coords.
 */
declare const _splitTargetsY: (targets: Register[], classicalRegY: number[], registers: RegisterMap) => number[][];
/**
 * Updates the x coord of each metadata in the given 2D array of metadata and returns rightmost x coord.
 *
 * @param opsMetadata  2D array of metadata.
 * @param columnWidths Array of column widths.
 *
 * @returns Rightmost x coord.
 */
declare const _fillMetadataX: (opsMetadata: Metadata[][], columnWidths: number[]) => number;
/**
 * Offset x coords of nested children operations.
 *
 * @param children 2D array of children metadata.
 * @param offset   x coord offset.
 */
declare const _offsetChildrenX: (children: (Metadata | Metadata[])[] | undefined, offset: number) => void;
export { processOperations, _groupOperations, _alignOps, _getClassicalRegStart, _opToMetadata, _getRegY, _splitTargetsY, _fillMetadataX, _offsetChildrenX, };
