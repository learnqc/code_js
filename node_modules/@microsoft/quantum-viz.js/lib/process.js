"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports._offsetChildrenX = exports._fillMetadataX = exports._splitTargetsY = exports._getRegY = exports._opToMetadata = exports._getClassicalRegStart = exports._alignOps = exports._groupOperations = exports.processOperations = void 0;
var constants_1 = require("./constants");
var circuit_1 = require("./circuit");
var metadata_1 = require("./metadata");
var register_1 = require("./register");
var utils_1 = require("./utils");
/**
 * Takes in a list of operations and maps them to `metadata` objects which
 * contains information for formatting the corresponding SVG.
 *
 * @param operations Array of operations.
 * @param registers  Mapping from qubit IDs to register metadata.
 *
 * @returns An object containing `metadataList` (Array of Metadata objects) and
 *          `svgWidth` which is the width of the entire SVG.
 */
var processOperations = function (operations, registers) {
    if (operations.length === 0)
        return { metadataList: [], svgWidth: constants_1.startX };
    // Group operations based on registers
    var groupedOps = _groupOperations(operations, registers);
    // Align operations on multiple registers
    var alignedOps = _alignOps(groupedOps);
    // Maintain widths of each column to account for variable-sized gates
    var numColumns = Math.max.apply(Math, __spreadArray([0], alignedOps.map(function (ops) { return ops.length; }), false));
    var columnsWidths = new Array(numColumns).fill(constants_1.minGateWidth);
    // Get classical registers and their starting column index
    var classicalRegs = _getClassicalRegStart(operations, alignedOps);
    // Keep track of which ops are already seen to avoid duplicate rendering
    var visited = {};
    // Map operation index to gate metadata for formatting later
    var opsMetadata = alignedOps.map(function (regOps) {
        return regOps.map(function (opIdx, col) {
            var op = null;
            if (opIdx != null && !visited.hasOwnProperty(opIdx)) {
                op = operations[opIdx];
                visited[opIdx] = true;
            }
            var metadata = _opToMetadata(op, registers);
            if (op != null && [metadata_1.GateType.Unitary, metadata_1.GateType.ControlledUnitary].includes(metadata.type)) {
                // If gate is a unitary type, split targetsY into groups if there
                // is a classical register between them for rendering
                // Get y coordinates of classical registers in the same column as this operation
                var classicalRegY = classicalRegs
                    .filter(function (_a) {
                    var regCol = _a[0], _ = _a[1];
                    return regCol <= col;
                })
                    .map(function (_a) {
                    var _ = _a[0], reg = _a[1];
                    if (reg.cId == null)
                        throw new Error('Could not find cId for classical register.');
                    var children = registers[reg.qId].children;
                    if (children == null)
                        throw new Error("Failed to find classical registers for qubit ID ".concat(reg.qId, "."));
                    return children[reg.cId].y;
                });
                metadata.targetsY = _splitTargetsY(op.targets, classicalRegY, registers);
            }
            // Expand column size, if needed
            if (metadata.width > columnsWidths[col]) {
                columnsWidths[col] = metadata.width;
            }
            return metadata;
        });
    });
    // Fill in x coord of each gate
    var endX = _fillMetadataX(opsMetadata, columnsWidths);
    // Flatten operations and filter out invalid gates
    var metadataList = opsMetadata.flat().filter(function (_a) {
        var type = _a.type;
        return type != metadata_1.GateType.Invalid;
    });
    return { metadataList: metadataList, svgWidth: endX };
};
exports.processOperations = processOperations;
/**
 * Group gates provided by operations into their respective registers.
 *
 * @param operations Array of operations.
 * @param numRegs    Total number of registers.
 *
 * @returns 2D array of indices where `groupedOps[i][j]` is the index of the operations
 *          at register `i` and column `j` (not yet aligned/padded).
 */
var _groupOperations = function (operations, registers) {
    // NOTE: We get the max ID instead of just number of keys because there can be a qubit ID that
    // isn't acted upon and thus does not show up as a key in registers.
    var numRegs = Math.max.apply(Math, __spreadArray([-1], Object.keys(registers).map(Number), false)) + 1;
    var groupedOps = Array.from(Array(numRegs), function () { return new Array(0); });
    operations.forEach(function (_a, instrIdx) {
        var targets = _a.targets, controls = _a.controls;
        var ctrls = controls || [];
        var qRegs = __spreadArray(__spreadArray([], ctrls, true), targets, true).filter(function (_a) {
            var type = _a.type;
            return (type || register_1.RegisterType.Qubit) === register_1.RegisterType.Qubit;
        });
        var qRegIdxList = qRegs.map(function (_a) {
            var qId = _a.qId;
            return qId;
        });
        var clsControls = ctrls.filter(function (_a) {
            var type = _a.type;
            return (type || register_1.RegisterType.Qubit) === register_1.RegisterType.Classical;
        });
        var isClassicallyControlled = clsControls.length > 0;
        if (!isClassicallyControlled && qRegs.length === 0)
            return;
        // If operation is classically-controlled, pad all qubit registers. Otherwise, only pad
        // the contiguous range of registers that it covers.
        var minRegIdx = isClassicallyControlled ? 0 : Math.min.apply(Math, qRegIdxList);
        var maxRegIdx = isClassicallyControlled ? numRegs - 1 : Math.max.apply(Math, qRegIdxList);
        // Add operation also to registers that are in-between target registers
        // so that other gates won't render in the middle.
        for (var i = minRegIdx; i <= maxRegIdx; i++) {
            groupedOps[i].push(instrIdx);
        }
    });
    return groupedOps;
};
exports._groupOperations = _groupOperations;
/**
 * Aligns operations by padding registers with `null`s to make sure that multiqubit
 * gates are in the same column.
 * e.g. ---[x]---[x]--
 *      ----------|---
 *
 * @param ops 2D array of operations. Each row represents a register
 *            and the operations acting on it (in-order).
 *
 * @returns 2D array of aligned operations padded with `null`s.
 */
var _alignOps = function (ops) {
    var maxNumOps = Math.max.apply(Math, __spreadArray([0], ops.map(function (regOps) { return regOps.length; }), false));
    var col = 0;
    // Deep copy ops to be returned as paddedOps
    var paddedOps = JSON.parse(JSON.stringify(ops));
    while (col < maxNumOps) {
        var _loop_1 = function (regIdx) {
            var reg = paddedOps[regIdx];
            if (reg.length <= col)
                return "continue";
            // Should never be null (nulls are only padded to previous columns)
            var opIdx = reg[col];
            // Get position of gate
            var targetsPos = paddedOps.map(function (regOps) { return regOps.indexOf(opIdx); });
            var gatePos = Math.max.apply(Math, __spreadArray([-1], targetsPos, false));
            // If current column is not desired gate position, pad with null
            if (col < gatePos) {
                paddedOps[regIdx].splice(col, 0, null);
                maxNumOps = Math.max(maxNumOps, paddedOps[regIdx].length);
            }
        };
        for (var regIdx = 0; regIdx < paddedOps.length; regIdx++) {
            _loop_1(regIdx);
        }
        col++;
    }
    return paddedOps;
};
exports._alignOps = _alignOps;
/**
 * Retrieves the starting index of each classical register.
 *
 * @param ops     Array of operations.
 * @param idxList 2D array of aligned operation indices.
 *
 * @returns Array of classical register and their starting column indices in the form [[column, register]].
 */
var _getClassicalRegStart = function (ops, idxList) {
    var clsRegs = [];
    idxList.forEach(function (reg) {
        var _loop_2 = function (col) {
            var opIdx = reg[col];
            if (opIdx != null && ops[opIdx].isMeasurement) {
                var targetClsRegs = ops[opIdx].targets.filter(function (reg) { return reg.type === register_1.RegisterType.Classical; });
                targetClsRegs.forEach(function (reg) { return clsRegs.push([col, reg]); });
            }
        };
        for (var col = 0; col < reg.length; col++) {
            _loop_2(col);
        }
    });
    return clsRegs;
};
exports._getClassicalRegStart = _getClassicalRegStart;
/**
 * Maps operation to metadata (e.g. gate type, position, dimensions, text)
 * required to render the image.
 *
 * @param op        Operation to be mapped into metadata format.
 * @param registers Array of registers.
 *
 * @returns Metadata representation of given operation.
 */
var _opToMetadata = function (op, registers) {
    var metadata = {
        type: metadata_1.GateType.Invalid,
        x: 0,
        controlsY: [],
        targetsY: [],
        label: '',
        width: -1,
    };
    if (op == null)
        return metadata;
    var gate = op.gate, dataAttributes = op.dataAttributes, displayArgs = op.displayArgs, isMeasurement = op.isMeasurement, isConditional = op.isConditional, isControlled = op.isControlled, isAdjoint = op.isAdjoint, controls = op.controls, targets = op.targets, children = op.children, conditionalRender = op.conditionalRender;
    // Set y coords
    metadata.controlsY = (controls === null || controls === void 0 ? void 0 : controls.map(function (reg) { return _getRegY(reg, registers); })) || [];
    metadata.targetsY = targets.map(function (reg) { return _getRegY(reg, registers); });
    if (isConditional) {
        // Classically-controlled operations
        if (children == null || children.length == 0)
            throw new Error('No children operations found for classically-controlled operation.');
        // Gates to display when classical bit is 0.
        var onZeroOps = children.filter(function (op) { return op.conditionalRender !== circuit_1.ConditionalRender.OnOne; });
        var childrenInstrs = processOperations(onZeroOps, registers);
        var zeroGates = childrenInstrs.metadataList;
        var zeroChildWidth = childrenInstrs.svgWidth;
        // Gates to display when classical bit is 1.
        var onOneOps = children.filter(function (op) { return op.conditionalRender !== circuit_1.ConditionalRender.OnZero; });
        childrenInstrs = processOperations(onOneOps, registers);
        var oneGates = childrenInstrs.metadataList;
        var oneChildWidth = childrenInstrs.svgWidth;
        // Subtract startX (left-side) and 2*gatePadding (right-side) from nested child gates width
        var width = Math.max(zeroChildWidth, oneChildWidth) - constants_1.startX - constants_1.gatePadding * 2;
        metadata.type = metadata_1.GateType.ClassicalControlled;
        metadata.children = [zeroGates, oneGates];
        // Add additional width from control button and inner box padding for dashed box
        metadata.width = width + constants_1.controlBtnOffset + constants_1.groupBoxPadding * 2;
        // Set targets to first and last quantum registers so we can render the surrounding box
        // around all quantum registers.
        var qubitsY = Object.values(registers).map(function (_a) {
            var y = _a.y;
            return y;
        });
        if (qubitsY.length > 0)
            metadata.targetsY = [Math.min.apply(Math, qubitsY), Math.max.apply(Math, qubitsY)];
    }
    else if (conditionalRender == circuit_1.ConditionalRender.AsGroup && ((children === null || children === void 0 ? void 0 : children.length) || 0) > 0) {
        var childrenInstrs = processOperations(children, registers);
        metadata.type = metadata_1.GateType.Group;
        metadata.children = childrenInstrs.metadataList;
        // _zoomButton function in gateFormatter.ts relies on
        // 'expanded' attribute to render zoom button
        metadata.dataAttributes = { expanded: 'true' };
        // Subtract startX (left-side) and add inner box padding (minus nested gate padding) for dashed box
        metadata.width = childrenInstrs.svgWidth - constants_1.startX + (constants_1.groupBoxPadding - constants_1.gatePadding) * 2;
    }
    else if (isMeasurement) {
        metadata.type = metadata_1.GateType.Measure;
    }
    else if (gate === 'SWAP') {
        metadata.type = metadata_1.GateType.Swap;
    }
    else if (isControlled) {
        metadata.type = gate === 'X' ? metadata_1.GateType.Cnot : metadata_1.GateType.ControlledUnitary;
        metadata.label = gate;
    }
    else if (gate === 'X') {
        metadata.type = metadata_1.GateType.X;
        metadata.label = gate;
    }
    else {
        // Any other gate treated as a simple unitary gate
        metadata.type = metadata_1.GateType.Unitary;
        metadata.label = gate;
    }
    // If adjoint, add ' to the end of gate label
    if (isAdjoint && metadata.label.length > 0)
        metadata.label += "'";
    // If gate has extra arguments, display them
    if (displayArgs != null)
        metadata.displayArgs = displayArgs;
    // Set gate width
    metadata.width = (0, utils_1.getGateWidth)(metadata);
    // Extend existing data attributes with user-provided data attributes
    if (dataAttributes != null)
        metadata.dataAttributes = __assign(__assign({}, metadata.dataAttributes), dataAttributes);
    return metadata;
};
exports._opToMetadata = _opToMetadata;
/**
 * Compute the y coord of a given register.
 *
 * @param reg       Register to compute y coord of.
 * @param registers Map of qubit IDs to RegisterMetadata.
 *
 * @returns The y coord of give register.
 */
var _getRegY = function (reg, registers) {
    var type = reg.type, qId = reg.qId, cId = reg.cId;
    if (!registers.hasOwnProperty(qId))
        throw new Error("ERROR: Qubit register with ID ".concat(qId, " not found."));
    var _a = registers[qId], y = _a.y, children = _a.children;
    switch (type) {
        case undefined:
        case register_1.RegisterType.Qubit:
            return y;
        case register_1.RegisterType.Classical:
            if (children == null)
                throw new Error("ERROR: No classical registers found for qubit ID ".concat(qId, "."));
            if (cId == null)
                throw new Error("ERROR: No ID defined for classical register associated with qubit ID ".concat(qId, "."));
            if (children.length <= cId)
                throw new Error("ERROR: Classical register ID ".concat(cId, " invalid for qubit ID ").concat(qId, " with ").concat(children.length, " classical register(s)."));
            return children[cId].y;
        default:
            throw new Error("ERROR: Unknown register type ".concat(type, "."));
    }
};
exports._getRegY = _getRegY;
/**
 * Splits `targets` if non-adjacent or intersected by classical registers.
 *
 * @param targets       Target qubit registers.
 * @param classicalRegY y coords of classical registers overlapping current column.
 * @param registers     Mapping from register qubit IDs to register metadata.
 *
 * @returns Groups of target qubit y coords.
 */
var _splitTargetsY = function (targets, classicalRegY, registers) {
    if (targets.length === 0)
        return [];
    // Get qIds sorted by ascending y value
    var orderedQIds = Object.keys(registers).map(Number);
    orderedQIds.sort(function (a, b) { return registers[a].y - registers[b].y; });
    var qIdPosition = {};
    orderedQIds.forEach(function (qId, i) { return (qIdPosition[qId] = i); });
    // Sort targets and classicalRegY by ascending y value
    targets = targets.slice();
    targets.sort(function (a, b) {
        var posDiff = qIdPosition[a.qId] - qIdPosition[b.qId];
        if (posDiff === 0 && a.cId != null && b.cId != null)
            return a.cId - b.cId;
        else
            return posDiff;
    });
    classicalRegY = classicalRegY.slice();
    classicalRegY.sort(function (a, b) { return a - b; });
    var prevPos = 0;
    var prevY = 0;
    return targets.reduce(function (groups, target) {
        var y = _getRegY(target, registers);
        var pos = qIdPosition[target.qId];
        // Split into new group if one of the following holds:
        //      1. First target register
        //      2. Non-adjacent qubit registers
        //      3. There is a classical register between current and previous register
        if (groups.length === 0 || pos > prevPos + 1 || (classicalRegY[0] > prevY && classicalRegY[0] < y))
            groups.push([y]);
        else
            groups[groups.length - 1].push(y);
        prevPos = pos;
        prevY = y;
        // Remove classical registers that are higher than current y
        while (classicalRegY.length > 0 && classicalRegY[0] <= y)
            classicalRegY.shift();
        return groups;
    }, []);
};
exports._splitTargetsY = _splitTargetsY;
/**
 * Updates the x coord of each metadata in the given 2D array of metadata and returns rightmost x coord.
 *
 * @param opsMetadata  2D array of metadata.
 * @param columnWidths Array of column widths.
 *
 * @returns Rightmost x coord.
 */
var _fillMetadataX = function (opsMetadata, columnWidths) {
    var currX = constants_1.startX;
    var colStartX = columnWidths.map(function (width) {
        var x = currX;
        currX += width + constants_1.gatePadding * 2;
        return x;
    });
    var endX = currX;
    opsMetadata.forEach(function (regOps) {
        return regOps.forEach(function (metadata, col) {
            var x = colStartX[col];
            switch (metadata.type) {
                case metadata_1.GateType.ClassicalControlled:
                case metadata_1.GateType.Group:
                    // Subtract startX offset from nested gates and add offset and padding
                    var offset = x - constants_1.startX + constants_1.groupBoxPadding;
                    if (metadata.type === metadata_1.GateType.ClassicalControlled)
                        offset += constants_1.controlBtnOffset;
                    // Offset each x coord in children gates
                    _offsetChildrenX(metadata.children, offset);
                    // We don't use the centre x coord because we only care about the rightmost x for
                    // rendering the box around the group of nested gates
                    metadata.x = x;
                    break;
                default:
                    metadata.x = x + columnWidths[col] / 2;
                    break;
            }
        });
    });
    return endX;
};
exports._fillMetadataX = _fillMetadataX;
/**
 * Offset x coords of nested children operations.
 *
 * @param children 2D array of children metadata.
 * @param offset   x coord offset.
 */
var _offsetChildrenX = function (children, offset) {
    if (children == null)
        return;
    children.flat().forEach(function (child) {
        child.x += offset;
        _offsetChildrenX(child.children, offset);
    });
};
exports._offsetChildrenX = _offsetChildrenX;
