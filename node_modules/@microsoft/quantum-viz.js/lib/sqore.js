"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sqore = void 0;
var inputFormatter_1 = require("./formatters/inputFormatter");
var gateFormatter_1 = require("./formatters/gateFormatter");
var registerFormatter_1 = require("./formatters/registerFormatter");
var process_1 = require("./process");
var circuit_1 = require("./circuit");
var metadata_1 = require("./metadata");
var styles_1 = require("./styles");
var utils_1 = require("./utils");
var constants_1 = require("./constants");
/**
 * Entrypoint class for rendering circuit visualizations.
 */
var Sqore = /** @class */ (function () {
    /**
     * Initializes Sqore object with custom styles.
     *
     * @param circuit Circuit to be visualized.
     * @param style Custom visualization style.
     */
    function Sqore(circuit, style) {
        if (style === void 0) { style = {}; }
        this.style = {};
        this.gateRegistry = {};
        this.circuit = circuit;
        this.style = this.getStyle(style);
    }
    /**
     * Render circuit into `container` at the specified layer depth.
     *
     * @param container HTML element for rendering visualization into.
     * @param renderDepth Initial layer depth at which to render gates.
     */
    Sqore.prototype.draw = function (container, renderDepth) {
        var _this = this;
        if (renderDepth === void 0) { renderDepth = 0; }
        // Inject into container
        if (container == null)
            throw new Error("Container not provided.");
        // Create copy of circuit to prevent mutation
        var circuit = JSON.parse(JSON.stringify(this.circuit));
        // Assign unique IDs to each operation
        circuit.operations.forEach(function (op, i) { return _this.fillGateRegistry(op, i.toString()); });
        // Render operations at starting at given depth
        circuit.operations = this.selectOpsAtDepth(circuit.operations, renderDepth);
        // If only one top-level operation, expand automatically:
        if (circuit.operations.length == 1 &&
            circuit.operations[0].dataAttributes != null &&
            circuit.operations[0].dataAttributes.hasOwnProperty('id')) {
            var id = circuit.operations[0].dataAttributes['id'];
            this.expandOperation(circuit.operations, id);
        }
        this.renderCircuit(container, circuit);
    };
    /**
     * Retrieve style for visualization.
     *
     * @param style Custom style or style name.
     *
     * @returns Custom style.
     */
    Sqore.prototype.getStyle = function (style) {
        if (style === void 0) { style = {}; }
        if (typeof style === 'string' || style instanceof String) {
            var styleName = style;
            if (!styles_1.STYLES.hasOwnProperty(styleName)) {
                console.error("No style ".concat(styleName, " found in STYLES."));
                return {};
            }
            style = styles_1.STYLES[styleName];
        }
        return style;
    };
    /**
     * Render circuit into `container`.
     *
     * @param container HTML element for rendering visualization into.
     * @param circuit Circuit object to be rendered.
     */
    Sqore.prototype.renderCircuit = function (container, circuit) {
        // Create visualization components
        var composedSqore = this.compose(circuit);
        var svg = this.generateSvg(composedSqore);
        container.innerHTML = '';
        container.appendChild(svg);
        this.addGateClickHandlers(container, circuit);
    };
    /**
     * Generates the components required for visualization.
     *
     * @param circuit Circuit to be visualized.
     *
     * @returns `ComposedSqore` object containing metadata for visualization.
     */
    Sqore.prototype.compose = function (circuit) {
        var add = function (acc, gate) {
            var _a;
            if (Array.isArray(gate)) {
                gate.forEach(function (g) { return add(acc, g); });
            }
            else {
                acc.push(gate);
                (_a = gate.children) === null || _a === void 0 ? void 0 : _a.forEach(function (g) { return add(acc, g); });
            }
        };
        var flatten = function (gates) {
            var result = [];
            add(result, gates);
            return result;
        };
        var qubits = circuit.qubits, operations = circuit.operations;
        var _a = (0, inputFormatter_1.formatInputs)(qubits), qubitWires = _a.qubitWires, registers = _a.registers, svgHeight = _a.svgHeight;
        var _b = (0, process_1.processOperations)(operations, registers), metadataList = _b.metadataList, svgWidth = _b.svgWidth;
        var formattedGates = (0, gateFormatter_1.formatGates)(metadataList);
        var measureGates = flatten(metadataList).filter(function (_a) {
            var type = _a.type;
            return type === metadata_1.GateType.Measure;
        });
        var formattedRegs = (0, registerFormatter_1.formatRegisters)(registers, measureGates, svgWidth);
        var composedSqore = {
            width: svgWidth,
            height: svgHeight,
            elements: [qubitWires, formattedRegs, formattedGates],
        };
        return composedSqore;
    };
    /**
     * Generates visualization of `composedSqore` as an SVG.
     *
     * @param composedSqore ComposedSqore to be visualized.
     *
     * @returns SVG representation of circuit visualization.
     */
    Sqore.prototype.generateSvg = function (composedSqore) {
        var width = composedSqore.width, height = composedSqore.height, elements = composedSqore.elements;
        var uuid = (0, utils_1.createUUID)();
        var svg = document.createElementNS(constants_1.svgNS, 'svg');
        svg.setAttribute('id', uuid);
        svg.setAttribute('class', 'qviz');
        svg.setAttribute('width', width.toString());
        svg.setAttribute('height', height.toString());
        svg.style.setProperty('max-width', 'fit-content');
        // Add styles
        var css = document.createElement('style');
        css.innerHTML = (0, styles_1.style)(this.style);
        svg.appendChild(css);
        // Add body elements
        elements.forEach(function (element) { return svg.appendChild(element); });
        return svg;
    };
    /**
     * Depth-first traversal to assign unique ID to `operation`.
     * The operation is assigned the id `id` and its `i`th child is recursively given
     * the id `${id}-${i}`.
     *
     * @param operation Operation to be assigned.
     * @param id: ID to assign to `operation`.
     *
     */
    Sqore.prototype.fillGateRegistry = function (operation, id) {
        var _this = this;
        var _a;
        if (operation.dataAttributes == null)
            operation.dataAttributes = {};
        operation.dataAttributes['id'] = id;
        // By default, operations cannot be zoomed-out
        operation.dataAttributes['zoom-out'] = 'false';
        this.gateRegistry[id] = operation;
        (_a = operation.children) === null || _a === void 0 ? void 0 : _a.forEach(function (childOp, i) {
            _this.fillGateRegistry(childOp, "".concat(id, "-").concat(i));
            if (childOp.dataAttributes == null)
                childOp.dataAttributes = {};
            // Children operations can be zoomed out
            childOp.dataAttributes['zoom-out'] = 'true';
        });
        // Composite operations can be zoomed in
        operation.dataAttributes['zoom-in'] = (operation.children != null).toString();
    };
    /**
     * Pick out operations that are at or below `renderDepth`.
     *
     * @param operations List of circuit operations.
     * @param renderDepth Initial layer depth at which to render gates.
     *
     * @returns List of operations at or below specifed depth.
     */
    Sqore.prototype.selectOpsAtDepth = function (operations, renderDepth) {
        var _this = this;
        if (renderDepth < 0)
            throw new Error("Invalid renderDepth of ".concat(renderDepth, ". Needs to be >= 0."));
        if (renderDepth === 0)
            return operations;
        return operations
            .map(function (op) { return (op.children != null ? _this.selectOpsAtDepth(op.children, renderDepth - 1) : op); })
            .flat();
    };
    /**
     * Add interactive click handlers to circuit HTML elements.
     *
     * @param container HTML element containing visualized circuit.
     * @param circuit Circuit to be visualized.
     *
     */
    Sqore.prototype.addGateClickHandlers = function (container, circuit) {
        this.addClassicalControlHandlers(container);
        this.addZoomHandlers(container, circuit);
    };
    /**
     * Add interactive click handlers for classically-controlled operations.
     *
     * @param container HTML element containing visualized circuit.
     *
     */
    Sqore.prototype.addClassicalControlHandlers = function (container) {
        container.querySelectorAll('.classically-controlled-btn').forEach(function (btn) {
            // Zoom in on clicked gate
            btn.addEventListener('click', function (evt) {
                var _a;
                var textSvg = btn.querySelector('text');
                var group = btn.parentElement;
                if (textSvg == null || group == null)
                    return;
                var currValue = (_a = textSvg.firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue;
                var zeroGates = group === null || group === void 0 ? void 0 : group.querySelector('.gates-zero');
                var oneGates = group === null || group === void 0 ? void 0 : group.querySelector('.gates-one');
                switch (currValue) {
                    case '?':
                        textSvg.childNodes[0].nodeValue = '1';
                        group.classList.remove('classically-controlled-unknown');
                        group.classList.remove('classically-controlled-zero');
                        group.classList.add('classically-controlled-one');
                        zeroGates === null || zeroGates === void 0 ? void 0 : zeroGates.classList.add('hidden');
                        oneGates === null || oneGates === void 0 ? void 0 : oneGates.classList.remove('hidden');
                        break;
                    case '1':
                        textSvg.childNodes[0].nodeValue = '0';
                        group.classList.remove('classically-controlled-unknown');
                        group.classList.add('classically-controlled-zero');
                        group.classList.remove('classically-controlled-one');
                        zeroGates === null || zeroGates === void 0 ? void 0 : zeroGates.classList.remove('hidden');
                        oneGates === null || oneGates === void 0 ? void 0 : oneGates.classList.add('hidden');
                        break;
                    case '0':
                        textSvg.childNodes[0].nodeValue = '?';
                        group.classList.add('classically-controlled-unknown');
                        group.classList.remove('classically-controlled-zero');
                        group.classList.remove('classically-controlled-one');
                        zeroGates === null || zeroGates === void 0 ? void 0 : zeroGates.classList.remove('hidden');
                        oneGates === null || oneGates === void 0 ? void 0 : oneGates.classList.remove('hidden');
                        break;
                }
                evt.stopPropagation();
            });
        });
    };
    /**
     * Add interactive click handlers for zoom-in/out functionality.
     *
     * @param container HTML element containing visualized circuit.
     * @param circuit Circuit to be visualized.
     *
     */
    Sqore.prototype.addZoomHandlers = function (container, circuit) {
        var _this = this;
        container.querySelectorAll('.gate .gate-control').forEach(function (ctrl) {
            // Zoom in on clicked gate
            ctrl.addEventListener('click', function (ev) {
                var _a;
                var gateId = (_a = ctrl.parentElement) === null || _a === void 0 ? void 0 : _a.getAttribute('data-id');
                if (typeof gateId == 'string') {
                    if (ctrl.classList.contains('gate-collapse')) {
                        _this.collapseOperation(circuit.operations, gateId);
                    }
                    else if (ctrl.classList.contains('gate-expand')) {
                        _this.expandOperation(circuit.operations, gateId);
                    }
                    _this.renderCircuit(container, circuit);
                    ev.stopPropagation();
                }
            });
        });
    };
    /**
     * Expand selected operation for zoom-in interaction.
     *
     * @param operations List of circuit operations.
     * @param id ID of operation to expand.
     *
     */
    Sqore.prototype.expandOperation = function (operations, id) {
        var _this = this;
        operations.forEach(function (op) {
            if (op.conditionalRender === circuit_1.ConditionalRender.AsGroup)
                _this.expandOperation(op.children || [], id);
            if (op.dataAttributes == null)
                return op;
            var opId = op.dataAttributes['id'];
            if (opId === id && op.children != null) {
                op.conditionalRender = circuit_1.ConditionalRender.AsGroup;
                op.dataAttributes['expanded'] = 'true';
            }
        });
    };
    /**
     * Collapse selected operation for zoom-out interaction.
     *
     * @param operations List of circuit operations.
     * @param id ID of operation to collapse.
     *
     */
    Sqore.prototype.collapseOperation = function (operations, parentId) {
        var _this = this;
        operations.forEach(function (op) {
            if (op.conditionalRender === circuit_1.ConditionalRender.AsGroup)
                _this.collapseOperation(op.children || [], parentId);
            if (op.dataAttributes == null)
                return op;
            var opId = op.dataAttributes['id'];
            // Collapse parent gate and its children
            if (opId.startsWith(parentId)) {
                op.conditionalRender = circuit_1.ConditionalRender.Always;
                delete op.dataAttributes['expanded'];
            }
        });
    };
    return Sqore;
}());
exports.Sqore = Sqore;
